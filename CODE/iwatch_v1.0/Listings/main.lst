C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Objects\main.obj
COMPILER INVOKED BY: E:\install_files\keil\C51\BIN\C51.EXE ..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\
                    -oled;..\User\rtc;..\User\System;..\User;..\User\bluetooth;..\User\radio;..\User\sensor) DEBUG OBJECTEXTEND PRINT(..\List
                    -ings\main.lst) TABS(2) OBJECT(..\Objects\main.obj)

line level    source

   1          #include "Sys.h"
   2          #include "bmp.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "stdlib.h"
   6          #include "string.h"
   7          #include "math.h"
   8          #include "Delay.h"
   9          #include "PowerManage.h"
  10          #include "Buzzer.h"
  11          #include "Display.h"
  12          #include "PW02.h"
  13          #include "PCF8563.h"
  14          #include "BME280.h"                  
  15          #include "HMC5883L.h"                 
  16          #include "RDA5807M.h"
  17          #include "LSM6DSM.h"
  18          #include "Ellipsoid fitting.h"
  19          
  20          
  21          void PCF8563ReadTime(struct pcf8563_time *t);
  22          
  23          
  24          
  25          /***********************状态机相关变量*********************/
  26          enum function func_num = WATCH;    //功能号
  27          char func_index;               //功能索引
  28          bit ON_OPEN = 0;
  29          bit ON_CLOSE = 0;
  30          bit ON_RETURN = 0;
  31          /********************************************************/
  32          /************************时基信号************************/
  33          bit tick_1ms = 0;             //1000Hz
  34          bit tick_8ms = 0;             //125hz
  35          bit tick_20ms = 0;            //50hz
  36          
  37          /*************************工作状态相关变量*******************************/
  38          bit action = 0;             //动态标志位
  39          bit active_flag =1;       //活动标志位
  40          bit sleep_flag = 0;         //睡眠标志位
  41          bit powerdown_flag = 0;     //掉电标志位
  42          bit deep_powerdown_flag = 0;    //深度掉电标志位
  43          unsigned int inactive_time =0;  //自动息屏的时间
  44          unsigned int sleep_time = 0;    //自动待机时间
  45          unsigned int autowake_cnt = 0;  //自动唤醒的次数
  46          bit screen_on_flag = 1;     //屏幕状态标志位
  47          bit PCF8563_int_flag = 0;   //pcf8563中断产生标志位
  48          bit alarm_flag = 0;         //闹铃标志位
  49          bit radio_on_flag = 0;      //收音机工作标志位
  50          bit timer_on_flag = 0;      //计时器工作标志位
  51          /*************************按键相关变量*********************/
  52          unsigned char Trg = 0;      //按键触发值
  53          unsigned char Cont = 0;     //按键持续值
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 2   

  54          /*************************显示缓存*******************************/
  55          extern unsigned char xdata main_cache[];
  56          extern unsigned char xdata sub_cache1[];
  57          extern unsigned char xdata sub_cache2[];          
  58          
  59          struct sys_config config;   //设置信息结构体
  60          struct pcf8563_time RTC;    //时间信息结构体
  61          struct bme280_data BME280;  //bme280数据结构体
  62          struct lsm6dsm_data LSM6DSM;//LSM6DSM 数据结构体
  63          struct cal_data magnet_cal_data;  //磁力计校准数据结构体
  64          float battery_life;         //电池电量
  65          unsigned int  timer_cnt = 0;//定时器0溢出次数
  66          
  67          /****
  68          void  LED1_ON()
  69          {
  70            P35 = 1;
  71          }  
  72          void  LED1_OFF()
  73          {
  74            P35 = 0;
  75          }
  76          
  77          void BreathingLamp(void)
  78          {
  79            unsigned int  i=0,  j=0,num=500;
  80            for(i=0;i<num;i++)
  81              {
  82                for(j=0;j<num;j++)
  83                 {
  84                    if(i>j)
  85                  {
  86                    LED1_ON();
  87                    Delay1us(1);
  88                  }
  89                  else
  90                  {
  91                    LED1_OFF();
  92                    Delay1us(1);
  93                  } 
  94                }
  95              }
  96              FeedWatchDog();   
  97              Delay1us(1);
  98              for(i=0;i<num;i++)
  99              {
 100                for(j=0;j<num;j++)
 101                {
 102                  if(i>j)
 103                  {
 104                    LED1_OFF();
 105                    Delay1us(1);
 106                  }
 107                  else
 108                  {
 109                    LED1_ON();
 110                    Delay1us(1);
 111                    
 112                  } 
 113                }
 114              }
 115          }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 3   

 116          ********/
 117          void KeyScan(void)
 118          {
 119   1        unsigned char dat = 0x00;
 120   1        if(K1 == 0)              //m按键被按下
 121   1          dat |= KEY1;          //被按下的键的键码是0x01
 122   1        if(K2 == 0)             //按键up被按下
 123   1          dat |= KEY2;          //被按下的键码是0x02
 124   1        if(K3 ==0)              //按键down被按下
 125   1          dat |= KEY3;          //被按下的键码是0x04
 126   1        Trg = dat&(dat^Cont);   //按键触发值等于被按下的键码值  与上按键持续值          0x01 & 0x01 =0x01,说明按键
             -的触发次数为1
 127   1        Cont = dat;             //按下键码赋值给按键持续值
 128   1      }
 129          
 130          void TM3_Ist()  interrupt 19 using 1    //  mcu TIM3 定时器定时1ms中断
 131          {
 132   1        
 133   1        static unsigned int t_count = 0;
 134   1        static unsigned int t_key_press =0;   
 135   1        AUXINTIF &= ~T3IF;                    //清除中断标志位
 136   1        if((K1 == 0) && (K2 == 0) && (K3 == 0))
 137   1        {
 138   2          while ((K1 == 0) ||(K2 == 0) ||(K3 == 0) ); //三个按键均抬起
 139   2          MCUSoftReset();                         //软复位MCU
 140   2        }
 141   1          if(t_count % 50 == 0)
 142   1        {
 143   2          KeyScan();
 144   2          if(Trg)
 145   2          {
 146   3            Bee();          
 147   3            action = 1;
 148   3             
 149   3            if(sleep_flag || powerdown_flag || alarm_flag)
 150   3            {
 151   4              Trg = 0;        
 152   4              if(alarm_flag)
 153   4              {
 154   5                alarm_flag = 0;
 155   5                LED(OFF);
 156   5              }
 157   4          } 
 158   3        }
 159   2          if(Cont)
 160   2          {
 161   3            if(++t_key_press > 10)  //判断是否长按
 162   3              Trg = Cont;           //重复触发
 163   3          }
 164   2          else
 165   2            t_key_press = 0;
 166   2        }
 167   1        tick_1ms = 1;
 168   1        if(t_count % 8 == 0)
 169   1          tick_8ms = 1;
 170   1        if(t_count % 20 == 0)
 171   1          tick_20ms = 1;  
 172   1        if(++t_count == 1000)
 173   1        {
 174   2          t_count = 0;
 175   2          if(active_flag)
 176   2          {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 4   

 177   3            if(++inactive_time == config.t_inactive_max)
 178   3            {
 179   4              active_flag = 0;
 180   4              inactive_time = 0;
 181   4              sleep_flag = 1;
 182   4            }
 183   3          }
 184   2          if(sleep_flag)
 185   2          {
 186   3            if(++sleep_time == config.t_sleep_max)
 187   3            {
 188   4              sleep_flag = 0;
 189   4              sleep_time = 0;
 190   4              powerdown_flag = 1;
 191   4              ON_CLOSE = 1;
 192   4            }
 193   3          }
 194   2        }
 195   1      }
 196          
 197          void INT0_Isr() interrupt 0           //PCF8563中断
 198          {
 199   1        PCF8563_int_flag = 1;
 200   1      }
 201          void TM0_Isr() interrupt 1 using 1    //计数器0溢出中断
 202          {
 203   1        timer_cnt++;
 204   1      }
 205          void INT1_Isr() interrupt 2 using 1   //双击中断   是基于LSM6DSM                          
 206          {
 207   1        action = 1;
 208   1        alarm_flag = 0;
 209   1        Bee();
 210   1        if(sleep_flag || powerdown_flag || alarm_flag)
 211   1          Trg = 0;
 212   1        else
 213   1          Trg = DOUBLE_TAP;
 214   1        if(active_flag && func_num == WATCH)
 215   1        {
 216   2          action = 0;
 217   2          active_flag = 0;
 218   2          inactive_time = 0;
 219   2          ScreenOnOff(OFF);
 220   2          sleep_flag = 1;
 221   2                            
 222   2        }
 223   1      }
 224          void INT2_Isr() interrupt 10 using 1  //抬腕唤醒中断
 225          {
 226   1        action = 1;
 227   1        if(sleep_flag || powerdown_flag)
 228   1        {Trg = 0;}
 229   1        else 
 230   1        {Trg = AWT;}
 231   1      }
 232          void INT3_Isr() interrupt 11          //按键2中断
 233          {
 234   1        action = 1;
 235   1      }
 236          void SensorInit(void)
 237          {
 238   1        unsigned char y = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 5   

 239   1        unsigned int time_out = 700;
 240   1        unsigned char error_count = 0;
 241   1        if(BME280Init() == 0)
 242   1        {
 243   2          y += ShowString(0, y, "BME280 ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 244   2          error_count++;
 245   2        }
 246   1        if(HMC5883L_Init() == 0)
 247   1        {
 248   2          y += ShowString(0, y, "HMC5883L ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 249   2          error_count++;
 250   2        }
 251   1        if(LSM6DSMInit() == 0)
 252   1        {
 253   2          y += ShowString(0, y, "LSM6DSM ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 254   2          error_count++;       
 255   2        } 
 256   1        if(RDA5807MInit() == 0)
 257   1        {
 258   2          y += ShowString(0, y, "RDA5807M ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 259   2          error_count++;
 260   2        }
 261   1        if(error_count != 0)
 262   1        {
 263   2          while(Trg == 0)
 264   2          {
 265   3            Delay1ms(1);
 266   3            if(--time_out == 0)
 267   3              break;
 268   3          }
 269   2        }
 270   1      }
 271          
 272          void main()
 273          { 
 274   1        SysInit();            //系统初始化
 275   1        DisplayInit(&config); //显示初始化     
 276   1        PCF8563Init();        //实时时钟初始化        
 277   1        SensorInit();         //传感器初始化
 278   1        ClearCache(main_cache); //清空主显存  
 279   1        while(1)
 280   1        {
 281   2          FeedWatchDog();     //喂看门狗
 282   2          if(func_num == WATCH)           //显示表盘
 283   2          {
 284   3            unsigned char x, n, m;
 285   3            unsigned char str[16];    
 286   3            if(ON_OPEN)     //进入该功能时执行的内容
 287   3            {
 288   4              ON_OPEN = 0;
 289   4              if(func_index == FIRST_FUNC)
 290   4                ScreenPushAnimation(sub_cache1, DOWN);
 291   4              else if(func_index == LAST_FUNC)
 292   4                ScreenPushAnimation(sub_cache1, UP);
 293   4              func_index = WATCH;
 294   4            }     
 295   3            if(ON_RETURN)   //返回该功能时执行的内容
 296   3            {
 297   4              ON_RETURN = 0;    
 298   4            }   
 299   3            if(tick_20ms)   //在功能里时，每20ms执行一次功能内容
 300   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 6   

 301   4              tick_20ms = 0;
 302   4              //显示时间
 303   4              PCF8563ReadTime(&RTC);
 304   4              //printf("%d:%d:%d\n", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
 305   4              DisplayTime(RTC.hour, RTC.minute, RTC.second);    
 306   4              //显示小图标
 307   4              ClearCacheArea(0, 0, 35, 8, main_cache);
 308   4              x = 0;
 309   4              BMPToCache(x, 0, 8, 8, BLUETOOTH_SMALL_ICON, main_cache, 0);
 310   4              x += 9;
 311   4              if(timer_on_flag)
 312   4              {
 313   5                BMPToCache(x, 0, 8, 8, TIMER_SMALL_ICON, main_cache, 0);
 314   5                x += 9;
 315   5              }
 316   4              if(config.alarm_mode != ALARM_DISABLE)
 317   4              {
 318   5                BMPToCache(x, 0, 8, 8, CLOCK_SMALL_ICON, main_cache, 0);
 319   5                x += 9;
 320   5              }
 321   4              if(radio_on_flag)
 322   4                BMPToCache(x, 0, 8, 8, RADIO_SMALL_ICON, main_cache, 0);
 323   4              
 324   4              //显示日期，星期
 325   4              ClearCacheArea(0, 7, 128, 8, main_cache);
 326   4              sprintf(str, "%d/%d/%d ", (int)RTC.year, (int)RTC.month, (int)RTC.day);
 327   4              strcat(str, WEEKDAY_IN_STR[RTC.weekday - 1]);
 328   4              ShowString(0, 7, str, main_cache, FONT6X8, NO_INVERSED, 1);
 329   4              //显示电量
 330   4      //        battery_life = GetBatteryLife();
 331   4      //        for(n = 0; n < 24; n++)
 332   4      //          str[n] = BATTERY_LIFE_ICON[n];          
 333   4      //        m = 18 * battery_life;
 334   4      //        for(n = 2; n < 2 + m; n++)
 335   4      //          str[n] |= 0x3c;
 336   4      //        BMPToCache(104, 0, 24, 8, str, main_cache, 0);
 337   4      //        sprintf(str, "%3d%%", (int)(battery_life * 100));
 338   4      //        ShowString(78, 0, str, main_cache, FONT6X8, NO_INVERSED, 1);
 339   4            }
 340   3          } 
 341   2            if(Trg != 0)    //在该功能下对按键事件的处理
 342   2            {   
 343   3              switch(Trg)
 344   3              {     
 345   4                case KEY1:
 346   4                {
 347   5                  func_num = SUB_MENU;
 348   5                  ON_CLOSE = 1;
 349   5                  break;
 350   5                }
 351   4                case KEY2:
 352   4                {
 353   5                  func_index = FIRST_FUNC;
 354   5                  func_num = MENU;
 355   5                  ON_CLOSE = 1;
 356   5                  break;
 357   5                } 
 358   4                case KEY3:
 359   4                {
 360   5                  func_index = LAST_FUNC;
 361   5                  func_num = MENU;
 362   5                  ON_CLOSE = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 7   

 363   5                  break;
 364   5                }
 365   4                case KEY13:
 366   4                {
 367   5                  active_flag = 0;
 368   5                  sleep_flag = 0;
 369   5                  powerdown_flag = 0;
 370   5                  inactive_time = 0;
 371   5                  sleep_time = 0;
 372   5                  deep_powerdown_flag = 1;
 373   5                  ON_CLOSE = 1;
 374   5                  break;
 375   5                }
 376   4              }
 377   3              Trg = 0;
 378   3              
 379   3            }
 380   2            if(ON_CLOSE)    //关闭该功能时执行的内容
 381   2            {
 382   3              
 383   3              ON_CLOSE = 0;
 384   3              SaveScreen();
 385   3              ON_OPEN = 1;
 386   3            }
 387   2          else if(func_num == MENU)       //主菜单    ok
 388   2          {   
 389   3            if(ON_OPEN)
 390   3            {
 391   4              ClearCache(sub_cache2);
 392   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 393   4              if(func_index == FIRST_FUNC)
 394   4                ScreenPushAnimation(sub_cache2, UP);
 395   4              else
 396   4                ScreenPushAnimation(sub_cache2, DOWN);
 397   4              ON_OPEN = 0;
 398   4            }
 399   3            if(ON_RETURN)
 400   3            {
 401   4              ON_RETURN = 0;
 402   4              ClearCache(sub_cache2);
 403   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 404   4              ScreenPushAnimation(sub_cache2, RIGHT);
 405   4            }
 406   3            
 407   3            if(Trg != 0)
 408   3            {
 409   4              switch(Trg)
 410   4              {
 411   5                case KEY1:
 412   5                {
 413   6                  goto case_AWT;
 414   6                  break;
 415   6                }
 416   5                case KEY2:
 417   5                {
 418   6                  if(++func_index > FUNC_NUM_MAX - 1)
 419   6                  {
 420   7                    func_index = LAST_FUNC;
 421   7                    func_num = WATCH;
 422   7                    ON_CLOSE = 1;
 423   7                  }
 424   6                  else
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 8   

 425   6                  {
 426   7                    ClearCache(sub_cache2);
 427   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 428   7                    ScreenPushAnimation(sub_cache2, UP);
 429   7                  }
 430   6                  break;
 431   6                }
 432   5                case KEY3:
 433   5                {
 434   6                  if(--func_index < 0)
 435   6                  {
 436   7                    func_index = FIRST_FUNC;
 437   7                    func_num = WATCH;
 438   7                    ON_CLOSE = 1;
 439   7                  }
 440   6                  else
 441   6                  {
 442   7                    ClearCache(sub_cache2);
 443   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 444   7                    ScreenPushAnimation(sub_cache2, DOWN);
 445   7                  }
 446   6                  break;
 447   6                }
 448   5                case DOUBLE_TAP:
 449   5                {
 450   6                  func_num = func_index;
 451   6                  ON_CLOSE= 1;
 452   6                  break;
 453   6                }
 454   5                case AWT:
 455   5                {
 456   6                  case_AWT:
 457   6                  if(func_index <= (FUNC_NUM_MAX - func_index))
 458   6                  {
 459   7                    while(func_index > 0)
 460   7                    {
 461   8                      func_index --;
 462   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 463   8                      ScreenPushAnimation(sub_cache2, DOWN);
 464   8                    }
 465   7                  }
 466   6                  else
 467   6                  {
 468   7                    while(func_index < FUNC_NUM_MAX - 1)
 469   7                    {
 470   8                      func_index ++;
 471   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 472   8                      ScreenPushAnimation(sub_cache2, UP);
 473   8                    }
 474   7                  }
 475   6                  func_num = WATCH;
 476   6                  ON_CLOSE = 1;
 477   6                  break;
 478   6                }
 479   5              }
 480   4              Trg = 0;
 481   4            }
 482   3            if(ON_CLOSE)
 483   3            {
 484   4              ON_CLOSE = 0;
 485   4              ON_OPEN = 1;
 486   4            }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 9   

 487   3          }
 488   2        
 489   2          else if(func_num == SUB_MENU)   //次菜单    ok
 490   2          {
 491   3            char x, y;    
 492   3            if(ON_OPEN)
 493   3            {
 494   4              ON_OPEN = 0;
 495   4              ClearCache(sub_cache2);
 496   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, sub_cache2, COVER);
 497   4              ScreenPushAnimation(sub_cache2, LEFT);
 498   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 499   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 500   4              LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 501   4            }
 502   3            if(tick_8ms)        //姿态解算频率：125hz
 503   3            {
 504   4              tick_8ms = 0;
 505   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
 506   4              IMUupdate(&LSM6DSM);
 507   4            }
 508   3            if(tick_20ms)
 509   3            {
 510   4              tick_20ms = 0;
 511   4              LSM6DSM.AngleX -= config.cal_anglex;  //倾角减去偏移
 512   4              LSM6DSM.AngleY -= config.cal_angley;  //倾角减去偏移
 513   4              LSM6DSM.AngleY -= 30;
 514   4              LSM6DSM.AngleX *= 3;      //调整一下横向灵敏度
 515   4              LSM6DSM.AngleY *= 2;      //调整一下纵向灵敏度
 516   4              if(LSM6DSM.AngleX > 63)   //对计算结果进行限幅
 517   4                LSM6DSM.AngleX = 63;
 518   4              else if(LSM6DSM.AngleX < -64)
 519   4                LSM6DSM.AngleX = -64;
 520   4              if(LSM6DSM.AngleY > 31)
 521   4                LSM6DSM.AngleY = 31;
 522   4              else if(LSM6DSM.AngleY < -31)
 523   4                LSM6DSM.AngleY = -31;
 524   4              x = 64 + LSM6DSM.AngleX;
 525   4              y = 32 + LSM6DSM.AngleY;
 526   4              if(x > 96)
 527   4                x = 96;
 528   4              if(y > 32)
 529   4                y = 32;
 530   4              ClearCache(main_cache);       //清空主缓存
 531   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, main_cache, COVER); //画菜单背景到主显存上
 532   4              DrawSelectionFrame(x, y);     //根据xy坐标画选择框到主显存上
 533   4              ScreenRefreshAll(main_cache); //将主显存刷新到OLED屏幕上
 534   4            }
 535   3            if(Cont == 0)
 536   3            {
 537   4              func_index = (enum function)((x + 16) / 32 + ((y + 16) / 32) * 4);
 538   4              func_num = func_index;
 539   4              ON_CLOSE = 1;
 540   4            }
 541   3            if(ON_CLOSE)
 542   3            {
 543   4              ON_CLOSE = 0;
 544   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
 545   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 546   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 547   4              ON_OPEN = 1;
 548   4            }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 10  

 549   3          }
 550   2      
 551   2          else if(func_num == STOPWATCH)  //计时器    ok
 552   2          { 
 553   3            unsigned char t = 0, t_x = 0, t_y = 2;
 554   3            static int ms = 0, sec = 0, min = 0;
 555   3            static unsigned char n = 0, x = 0, y = 2;
 556   3            static unsigned char str1[10][11];
 557   3            unsigned char str2[10];
 558   3            if(ON_OPEN)
 559   3            {
 560   4              ON_OPEN = 0;
 561   4              ClearCache(sub_cache2);
 562   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 563   4              sec = ms / 100 % 60;
 564   4              min = sec / 60;
 565   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 566   4              ShowString(32, 0, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 567   4              if(n != 0)
 568   4              {
 569   5                for(t = 0; t < n; t++)
 570   5                {
 571   6                  if(t == 6)
 572   6                  {
 573   7                    t_x = 64;
 574   7                    t_y = 2;
 575   7                  }
 576   6                  ShowString(t_x, t_y++, str1[t], sub_cache2, FONT6X8, NO_INVERSED, 0);
 577   6                }
 578   5              }
 579   4              ScreenPushAnimation(sub_cache2, LEFT);
 580   4              ClearCache(sub_cache2);
 581   4            }
 582   3            if(tick_1ms)
 583   3            {
 584   4              tick_1ms = 0;
 585   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 586   4              sec = ms / 100;
 587   4              min = sec / 60;
 588   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 589   4              ShowString(32, 0, str2, main_cache, FONT8X16, NO_INVERSED, 1);
 590   4              sleep_time = 0;
 591   4            }
 592   3            if(Trg != 0)
 593   3            {
 594   4              switch(Trg)
 595   4              {
 596   5                case KEY1:
 597   5                {
 598   6                  ON_CLOSE = 1;
 599   6                  break;
 600   6                }
 601   5                case KEY2:
 602   5                {
 603   6                  if(TR0)
 604   6                  {
 605   7                    TR0 = 0;
 606   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, DISABLE_CLKOUT);
 607   7                    timer_on_flag = 0;
 608   7                  }
 609   6                  else
 610   6                  {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 11  

 611   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, ENABLE_CLKOUT);
 612   7                    TR0 = 1;
 613   7                    timer_on_flag = 1;
 614   7                  }
 615   6                  break;
 616   6                }
 617   5                case KEY3:
 618   5                {
 619   6                  timer_cnt = 0;
 620   6                  TH0 = 0;
 621   6                  TL0 = 0;
 622   6                  ms = 0;
 623   6                  sec = 0;
 624   6                  min = 0;
 625   6                  n = 0;
 626   6                  x = 0;
 627   6                  y = 2;
 628   6                  ClearCache(main_cache);
 629   6                  break;
 630   6                }
 631   5                case DOUBLE_TAP:
 632   5                {
 633   6                  if(n < 9 && timer_on_flag == 1)
 634   6                  {
 635   7                    if(n == 6)
 636   7                    {
 637   8                      x = 64;
 638   8                      y = 2;
 639   8                    }
 640   7                    sprintf(str1[n], "%d.%02d:%02d:%02d\0", (int)(n + 1), min, sec % 60, ms % 100);
 641   7                    ShowString(x + 0, y++, str1[n++], main_cache, FONT6X8, NO_INVERSED, 1);
 642   7                  }
 643   6                  break;
 644   6                }
 645   5              }
 646   4              Trg = 0;
 647   4            }
 648   3            if(ON_CLOSE)
 649   3            {
 650   4              ON_CLOSE = 0;
 651   4              func_num = MENU;
 652   4              ON_RETURN = 1;
 653   4            }
 654   3          }
 655   2          else if(func_num == PEDOMETER)  //计步器    ok
 656   2          {
 657   3            unsigned char n;
 658   3            unsigned int step;
 659   3            unsigned char buf[8];
 660   3            if(ON_OPEN)
 661   3            {
 662   4              ON_OPEN = 0;
 663   4              PCF8563ReadTime(&RTC);
 664   4              ClearCache(sub_cache2);
 665   4              ShowString(0, 0, "Today:    History:", sub_cache2, FONT6X8, NO_INVERSED, 0);
 666   4              step = LSM6DSMGetCurrentStep();
 667   4              sprintf(buf, "%d ", step);
 668   4              ShowString(0, 1, buf, sub_cache2, FONT8X16, NO_INVERSED, 0);    
 669   4              ScreenPushAnimation(sub_cache2, LEFT);
 670   4            }
 671   3            if(tick_20ms)
 672   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 12  

 673   4              tick_20ms = 0;
 674   4              step = LSM6DSMGetCurrentStep();
 675   4              sprintf(buf, "%d ", step);
 676   4              ShowString(0, 1, buf, main_cache, FONT8X16, NO_INVERSED, 0);
 677   4              for(n = 0; n < 7; n++)
 678   4              {
 679   5                ShowString(64, n + 1, config.history_step[n], main_cache, FONT6X8, NO_INVERSED, 1);
 680   5              }
 681   4            }
 682   3            if(Trg != 0)
 683   3            {
 684   4              switch(Trg)
 685   4              {
 686   5                case KEY1:
 687   5                {
 688   6                  ON_CLOSE = 1;
 689   6                  break;
 690   6                }
 691   5                case KEY2:
 692   5                {
 693   6                  //LSM6DSMResetStepCounter();
 694   6                  break;
 695   6                } 
 696   5              }
 697   4              Trg = 0;
 698   4            }
 699   3            if(ON_CLOSE)
 700   3            {
 701   4              ON_CLOSE = 0;
 702   4              func_num = MENU;
 703   4              ON_RETURN = 1;
 704   4            }
 705   3          }
 706   2          else if(func_num == THPMETER)   //温湿度计  ok
 707   2          {   
 708   3            float altitude;
 709   3            unsigned char str1[10] = {0};
 710   3            if(ON_OPEN)
 711   3            {
 712   4              ON_OPEN = 0;
 713   4              ClearCache(sub_cache2);
 714   4              BMPToCache(0, 0, 48, 64, T_H_P_A, sub_cache2, 0);
 715   4              sprintf(str1, "%.1f", BME280.temperature);
 716   4              ShowString(48, 0, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 717   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, sub_cache2, 0);
 718   4              sprintf(str1, "%.1f%%", BME280.humidity);
 719   4              ShowString(48, 2, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 720   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 721   4              ShowString(48, 4, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 722   4              ScreenPushAnimation(sub_cache2, LEFT);
 723   4              BME280ContinuousMeasurement(MS_125);    //连续测量模式，测量间隔125ms
 724   4            }
 725   3            if(tick_20ms)
 726   3            {
 727   4              tick_20ms = 0;
 728   4              BME280GetSensorData(&BME280);         //读BME280测量数据并显示
 729   4              altitude = 44330.77 * (1 - pow((BME280.pressure / 101500), 0.190263));
 730   4              ClearCache(main_cache);
 731   4              BMPToCache(0, 0, 48, 64, T_H_P_A, main_cache, 0);
 732   4              sprintf(str1, "%.1f", BME280.temperature);
 733   4              ShowString(48, 0, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 734   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, main_cache, 0);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 13  

 735   4              sprintf(str1, "%.1f %%", BME280.humidity);
 736   4              ShowString(48, 2, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 737   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 738   4              ShowString(48, 4, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 739   4              sprintf(str1, "%d m", (int)altitude);
 740   4              ShowString(48, 6, str1, main_cache, FONT8X16, NO_INVERSED, 1);
 741   4            }
 742   3            if(Trg == KEY1)
 743   3            {
 744   4              Trg = 0;
 745   4              ON_CLOSE = 1;
 746   4            }
 747   3            if(ON_CLOSE)
 748   3            {
 749   4              ON_CLOSE = 0;
 750   4              BME280SetMode(SLEEP_MODE);
 751   4              func_num = MENU;
 752   4              ON_RETURN = 1;
 753   4            }
 754   3          }
 755   2          else if(func_num == RADIO)      //收音机    ok
 756   2          {
 757   3            static unsigned char index = 0;
 758   3            static bit searching_flag = 0;
 759   3            static unsigned char search_direction;
 760   3            float temp;
 761   3            unsigned char str2[16];
 762   3            if(ON_OPEN)
 763   3            {
 764   4              ON_OPEN = 0;
 765   4              ClearCache(sub_cache2);
 766   4              ShowString(80, 0, "volume", sub_cache2, FONT8X16, NO_INVERSED, 0);
 767   4              sprintf(str2,"%.1fMHz",config.radio_channel);
 768   4              ShowString(40, 3, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 769   4              ShowString(0, 6, "tune", sub_cache2, FONT8X16, NO_INVERSED, 0);
 770   4              ShowString(80, 6, "search", sub_cache2, FONT8X16, NO_INVERSED, 0);
 771   4              ShowString(0, 0, "close", main_cache, FONT8X16, NO_INVERSED, 0);
 772   4              ScreenPushAnimation(sub_cache2, LEFT);
 773   4              if(radio_on_flag != 1)
 774   4              {
 775   5                RDA5807MPowerUp();
 776   5                RDA5807MSetFq(config.radio_channel);
 777   5                if(config.radio_volume > 0x0f)
 778   5                  config.radio_volume = 0;
 779   5                RDA5807MSetVOLUME(config.radio_volume);
 780   5                radio_on_flag = 1;
 781   5              }
 782   4            }
 783   3            if(tick_20ms)
 784   3            {
 785   4              tick_20ms = 0;
 786   4              ClearCache(main_cache);
 787   4              ShowString(80, 0, "volume", main_cache, FONT8X16, index == 0?INVERSED:NO_INVERSED, 0);
 788   4              sprintf(str2,"%.1fMHz", config.radio_channel);
 789   4              ShowString(40, 3, str2, main_cache, FONT8X16, NO_INVERSED, 0);
 790   4              if(searching_flag)
 791   4              {
 792   5                temp = RDA5807MSEEK(search_direction);
 793   5                if(temp == 0)
 794   5                  ShowString(28, 5, "searching...", main_cache, FONT6X8, NO_INVERSED, 0);
 795   5                else
 796   5                {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 14  

 797   6                  config.radio_channel = temp;
 798   6                  searching_flag = 0;
 799   6                }
 800   5              }
 801   4              ShowString(80, 6, "search", main_cache, FONT8X16, index == 1?INVERSED:NO_INVERSED, 0);
 802   4              ShowString(0, 6, "tune", main_cache, FONT8X16, index == 2?INVERSED:NO_INVERSED, 0);
 803   4              ShowString(0, 0, "close", main_cache, FONT8X16, index == 3?INVERSED:NO_INVERSED, 1);
 804   4            }
 805   3            if(Trg != 0)
 806   3            {
 807   4              switch(Trg)
 808   4              {
 809   5                case KEY1:
 810   5                {
 811   6                  ON_CLOSE = 1;
 812   6                  break;
 813   6                }
 814   5                case KEY2:
 815   5                {
 816   6                  if(index == 0)
 817   6                  {
 818   7                    if(++config.radio_volume > 0x0f)
 819   7                      config.radio_volume = 0x0f;
 820   7                    RDA5807MSetVOLUME(config.radio_volume);
 821   7                  }
 822   6                  else if(index == 1)
 823   6                  {
 824   7                    search_direction = UPWARD;
 825   7                    searching_flag = 1;
 826   7                  }
 827   6                  else if(index == 2)
 828   6                  {
 829   7                    config.radio_channel += 0.1;
 830   7                    if(config.radio_channel > 108)
 831   7                      config.radio_channel = 87;
 832   7                    RDA5807MSetFq(config.radio_channel);
 833   7                  }
 834   6                  break;
 835   6                } 
 836   5                case KEY3:
 837   5                {
 838   6                  if(index == 0)
 839   6                  {
 840   7                    if(--config.radio_volume == 255)
 841   7                      config.radio_volume = 0;
 842   7                    RDA5807MSetVOLUME(config.radio_volume);
 843   7                  }
 844   6                  else if(index == 1)
 845   6                  {
 846   7                    search_direction = DOWNWARD;
 847   7                    searching_flag = 1;
 848   7                  }
 849   6                  else if(index == 2)
 850   6                  {
 851   7                    config.radio_channel -= 0.1;
 852   7                    if(config.radio_channel < 87)
 853   7                      config.radio_channel = 108;
 854   7                    RDA5807MSetFq(config.radio_channel);
 855   7                  }
 856   6                  break;
 857   6                }
 858   5                case DOUBLE_TAP:
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 15  

 859   5                {
 860   6                  if(++index == 4)
 861   6                    index = 0;
 862   6                  break;
 863   6                }
 864   5              }
 865   4              Trg = 0;
 866   4            }
 867   3            if(ON_CLOSE)
 868   3            {
 869   4              ON_CLOSE = 0;
 870   4              if(powerdown_flag == 0 && index == 3)
 871   4              {
 872   5                RDA5807MPowerDown();
 873   5                radio_on_flag = 0;
 874   5                index = 0;  
 875   5                EEPROMWriteConfiguration(&config);
 876   5              }
 877   4              func_num = MENU;
 878   4              ON_RETURN = 1;
 879   4            }
 880   3          }
 881   2          else if(func_num == COMPASS)    //磁力计    ok
 882   2          {
 883   3            //显示角度和指针
 884   3            static char mode = 0;
 885   3            int magnet_data[3] = {0};
 886   3            unsigned char str3[16];
 887   3            if(mode == 0)     
 888   3            {
 889   4              unsigned char n;
 890   4              int angle_from_north;
 891   4              if(ON_OPEN)
 892   4              {
 893   5                ON_OPEN = 0;
 894   5                ClearCache(sub_cache2);
 895   5                sprintf(str3, "%d  ", angle_from_north);
 896   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 897   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 898   5                ScreenPushAnimation(sub_cache2, LEFT);
 899   5                //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 900   5                LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 901   5                LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 902   5                HMC5883L_Set_Mode(0);                   //设置连续测量模式
 903   5                HMC5883L_Set_Calibration_Value(config.cal_magnet_x0, config.cal_magnet_y0, config.cal_magnet_z0, 
 904   5                                              config.cal_magnet_ab, config.cal_magnet_ac);  //设置校准参数
 905   5              }
 906   4              if(ON_RETURN)
 907   4              {
 908   5                ON_RETURN = 0;
 909   5                ClearCache(sub_cache2);
 910   5                BMPToCache(16, 2, 32, 16, NESW[n], sub_cache2, COVER);
 911   5                sprintf(str3, "%d  ", angle_from_north);
 912   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, COVER);
 913   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 914   5                ScreenPushAnimation(sub_cache2, RIGHT);
 915   5              }
 916   4              if(tick_8ms)
 917   4              {
 918   5                tick_8ms = 0; 
 919   5                LSM6DSMReadGYRAndACC(&LSM6DSM);
 920   5                IMUupdate(&LSM6DSM);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 16  

 921   5              }
 922   4              if(tick_20ms)
 923   4              {
 924   5                tick_20ms = 0;
 925   5                Read_HMC5883L(magnet_data);
 926   5                angle_from_north = (int)HMC5883L_Get_AngleXY(magnet_data, (int)LSM6DSM.AngleX, (int)LSM6DSM.AngleY);
 927   5                angle_from_north += 90;
 928   5                if(angle_from_north >= 360)
 929   5                  angle_from_north -= 360;
 930   5                n = (angle_from_north + 22.5) / 45;
 931   5                if(n == 8)
 932   5                  n = 0;
 933   5                BMPToCache(16, 2, 32, 16, NESW[n], main_cache, 0);
 934   5                sprintf(str3, "%d  ", angle_from_north);
 935   5                ShowString(24, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 936   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, main_cache, 0);
 937   5                angle_from_north -= 90;
 938   5                if(angle_from_north < 0)
 939   5                  angle_from_north += 360;
 940   5                DrawArm(95, 31, 18, angle_from_north);
 941   5                ScreenRefreshAll(main_cache);
 942   5              }
 943   4              if(Trg != 0)
 944   4              {
 945   5                switch(Trg)
 946   5                {
 947   6                  case KEY1:
 948   6                  {
 949   7                    ON_CLOSE = 1;
 950   7                    break;
 951   7                  }
 952   6                  case KEY2:
 953   6                  {
 954   7                    mode = 1;
 955   7                    ON_OPEN = 1;
 956   7                    break;
 957   7                  } 
 958   6                }
 959   5                Trg = 0;
 960   5              }
 961   4              if(ON_CLOSE)
 962   4              {
 963   5                ON_CLOSE = 0;
 964   5                HMC5883L_Set_Mode(2);  //设置睡眠模式
 965   5                LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 966   5                LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 967   5                func_num = MENU;
 968   5                ON_RETURN = 1;
 969   5              }
 970   4            }
 971   3            else if(mode == 1)  //磁力计椭球校准
 972   3            {
 973   4              static int data_cnt = 0;
 974   4              if(ON_OPEN)
 975   4              {
 976   5                ON_OPEN = 0;
 977   5                ClearCache(sub_cache2);
 978   5                sprintf(str3, "x:%d", magnet_data[0]);
 979   5                ShowString(0, 0, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 980   5                sprintf(str3, "y:%d", magnet_data[1]);
 981   5                ShowString(0, 2, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 982   5                sprintf(str3, "z:%d", magnet_data[2]);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 17  

 983   5                ShowString(0, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 984   5                ScreenPushAnimation(sub_cache2, LEFT);
 985   5                ResetMatrix();
 986   5                HMC5883L_Set_Calibration_Value(0, 0, 0, 1, 1);  //清除校准参数
 987   5              }
 988   4              if(tick_20ms)
 989   4              {
 990   5                tick_20ms = 0;
 991   5                Read_HMC5883L(magnet_data);
 992   5                CalcData_Input(magnet_data[0], magnet_data[1], magnet_data[2]);
 993   5                sprintf(str3, "x:%d", magnet_data[0]);
 994   5                ShowString(0, 0, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 995   5                sprintf(str3, "y:%d", magnet_data[1]);
 996   5                ShowString(0, 2, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 997   5                sprintf(str3, "z:%d", magnet_data[2]);
 998   5                ShowString(0, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 999   5                sprintf(str3, "data_cnt:%d", data_cnt);
1000   5                ShowString(0, 6, str3, main_cache, FONT8X16, NO_INVERSED, 1);
1001   5                if(++data_cnt == 5000)
1002   5                {
1003   6                  ON_CLOSE = 1;
1004   6                  Bee();
1005   6                }
1006   5              }
1007   4              if(Trg == KEY1)
1008   4              {
1009   5                Trg = 0;
1010   5                ON_CLOSE = 1;
1011   5              }
1012   4              if(ON_CLOSE)
1013   4              {
1014   5                ON_CLOSE = 0;
1015   5                Ellipsoid_fitting_Process(&magnet_cal_data);    //椭球校准算法
1016   5                HMC5883L_Set_Calibration_Value(magnet_cal_data.X0, magnet_cal_data.Y0, magnet_cal_data.Z0, 
1017   5                                              magnet_cal_data.A / magnet_cal_data.B, 
1018   5                                              magnet_cal_data.A / magnet_cal_data.C);//设置校准参数
1019   5                config.cal_magnet_x0 = magnet_cal_data.X0;
1020   5                config.cal_magnet_y0 = magnet_cal_data.Y0;
1021   5                config.cal_magnet_z0 = magnet_cal_data.Z0;
1022   5                config.cal_magnet_ab = magnet_cal_data.A / magnet_cal_data.B;
1023   5                config.cal_magnet_ac = magnet_cal_data.A / magnet_cal_data.C;
1024   5                EEPROMWriteConfiguration(&config);
1025   5                data_cnt = 0;
1026   5                mode = 0;
1027   5                ON_RETURN = 1;
1028   5              }
1029   4            }
1030   3          }
1031   2          
1032   2          else if(func_num == BLUETOOTH)  //蓝牙    ok
1033   2          {
1034   3            unsigned char bluetooth_data[128] = "\0";
1035   3            static bit bluetooth_init = 0;
1036   3            static unsigned char y = 0;
1037   3            static unsigned char connected = 0;
1038   3            if(ON_OPEN)
1039   3            {
1040   4              ON_OPEN = 0;
1041   4              ClearCache(sub_cache2);
1042   4              ScreenPushAnimation(sub_cache2, LEFT);
1043   4              if(bluetooth_init == 0)
1044   4              {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 18  

1045   5                while(PW02Init() == 0);       //蓝牙初始化
1046   5                bluetooth_init = 1;
1047   5              }
1048   4              PW02SetMode(1);
1049   4              y = 0;
1050   4            }
1051   3            if(tick_20ms)
1052   3            {
1053   4              tick_20ms = 0;
1054   4              if(connected == 0)
1055   4              {
1056   5                if(PW02CheckConnection())
1057   5                {
1058   6                  connected = 1;
1059   6                  y = 6;
1060   6                }
1061   5              }
1062   4              if((connected == 1) && PW02GetRxData(bluetooth_data))
1063   4                y += ShowString(0, y, bluetooth_data, main_cache, FONT8X16, NO_INVERSED, 1);
1064   4            }
1065   3            if(Trg != 0)
1066   3            {
1067   4              switch(Trg)
1068   4              {
1069   5                case KEY1:
1070   5                {
1071   6                  ON_CLOSE = 1;
1072   6                  break;
1073   6                }
1074   5                case KEY2:
1075   5                {
1076   6                  ClearCache(main_cache);
1077   6                  y = 0;
1078   6                  y += ShowString(0, y, "Screen cleaned", main_cache, FONT8X16, NO_INVERSED, 1);
1079   6                  break;
1080   6                } 
1081   5              }
1082   4              Trg = 0;
1083   4            }
1084   3            if(ON_CLOSE)
1085   3            {
1086   4              ON_CLOSE = 0;
1087   4              if(connected == 0)
1088   4                while(PW02ExitATMode() == 0);
1089   4              else
1090   4                connected = 0;
1091   4              PW02SetMode(0);
1092   4              func_num = MENU;
1093   4              ON_RETURN = 1;
1094   4            }
1095   3          }
1096   2          else if(func_num == SPIRIT_LEVEL) //水平仪  ok
1097   2          {
1098   3            int x, y;
1099   3            unsigned char str[16];
1100   3            if(ON_OPEN)
1101   3            {
1102   4              ON_OPEN = 0;
1103   4              ClearCache(sub_cache2);
1104   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1105   4              ShowString(0, 0, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1106   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 19  

1107   4              ShowString(0, 1, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1108   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1109   4              ShowString(0, 2, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1110   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, sub_cache2, 0);
1111   4              ScreenPushAnimation(sub_cache2, LEFT);
1112   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
1113   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
1114   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
1115   4            }
1116   3            if(tick_8ms)
1117   3            {
1118   4              tick_8ms = 0;
1119   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
1120   4              IMUupdate(&LSM6DSM);
1121   4            }
1122   3            if(tick_20ms)
1123   3            {
1124   4              tick_20ms = 0;
1125   4              ClearCache(main_cache);
1126   4              LSM6DSM.AngleX -= config.cal_anglex;
1127   4              LSM6DSM.AngleY -= config.cal_angley;
1128   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1129   4              ShowString(0, 0, str, main_cache, FONT6X8, NO_INVERSED, 0);
1130   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1131   4              ShowString(0, 1, str, main_cache, FONT6X8, NO_INVERSED, 0);
1132   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1133   4              ShowString(0, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
1134   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, main_cache, 0);
1135   4              x = 64 + LSM6DSM.AngleX;
1136   4              y = 32 + LSM6DSM.AngleY;
1137   4              if(x > 126)
1138   4                x = 126;
1139   4              else if(x < 1)
1140   4                x = 1;
1141   4              if(y > 62)
1142   4                y = 62;
1143   4              else if(y < 1)
1144   4                y = 1;
1145   4              if(x ==63 && y == 32)
1146   4                ScreenSetInverse(config.screen_inverse == NO_INVERSED?INVERSED:NO_INVERSED);
1147   4              else
1148   4                ScreenSetInverse(config.screen_inverse);
1149   4              DrawDot(x, y);
1150   4              DrawDot(x - 1, y);
1151   4              DrawDot(x + 1, y);
1152   4              DrawDot(x, y + 1);
1153   4              DrawDot(x, y - 1);
1154   4              ScreenRefreshAll(main_cache);
1155   4            }
1156   3            if(Trg != 0)
1157   3            {
1158   4              switch(Trg)
1159   4              {
1160   5                case KEY1:
1161   5                {
1162   6                  ON_CLOSE = 1;
1163   6                  break;
1164   6                }
1165   5                case KEY2:
1166   5                {
1167   6                  config.cal_anglex = LSM6DSM.AngleX;
1168   6                  config.cal_angley = LSM6DSM.AngleY;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 20  

1169   6                  break;
1170   6                } 
1171   5                case KEY3:
1172   5                {
1173   6                  break;
1174   6                }
1175   5              }
1176   4              Trg = 0;
1177   4            }
1178   3            if(ON_CLOSE)
1179   3            {
1180   4              ON_CLOSE = 0;
1181   4              ScreenSetInverse(config.screen_inverse);
1182   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
1183   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
1184   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
1185   4              EEPROMWriteConfiguration(&config);
1186   4              func_num = MENU;
1187   4              ON_RETURN = 1;
1188   4            }
1189   3          }
1190   2        
1191   2          else if(func_num == FLASH_LIGHT)  //手电筒  ok
1192   2          {
1193   3            static char flash_mode = 0;
1194   3            static char flash_t_cnt = 0;
1195   3            static bit k = 0;
1196   3            if(ON_OPEN)
1197   3            {
1198   4              ON_OPEN = 0;
1199   4              ClearCache(sub_cache2);
1200   4              ShowString(28, 3, "Torch ON", sub_cache2, FONT8X16, NO_INVERSED, 0);
1201   4              ScreenPushAnimation(sub_cache2, LEFT);
1202   4              ScreenSetInverse(INVERSED);
1203   4              ScreenSetBrightness(255);
1204   4              LED(ON);
1205   4            }
1206   3            if(tick_20ms)
1207   3            {
1208   4              tick_20ms = 0;
1209   4              inactive_time = 0;
1210   4              if(flash_mode)
1211   4              {
1212   5                if(flash_t_cnt++ == 5)
1213   5                {
1214   6                  flash_t_cnt = 0;
1215   6                  k = ~k;
1216   6                  LED(k);
1217   6                }
1218   5              }
1219   4            }
1220   3            if(Trg != 0)
1221   3            {
1222   4              switch(Trg)
1223   4              {
1224   5                case KEY1:
1225   5                {
1226   6                  ON_CLOSE = 1;
1227   6                  break;
1228   6                }
1229   5                case KEY2:
1230   5                {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 21  

1231   6                  if(flash_mode == 0)
1232   6                    flash_mode = 1;
1233   6                  else
1234   6                  {
1235   7                    flash_mode = 0;
1236   7                    LED(ON);
1237   7                  }
1238   6                  break;
1239   6                }
1240   5              }
1241   4              Trg = 0;
1242   4            }
1243   3            if(ON_CLOSE)
1244   3            {
1245   4              ON_CLOSE = 0;
1246   4              ScreenSetBrightness(config.screen_brightness);
1247   4              ScreenSetInverse(config.screen_inverse);
1248   4              LED(OFF);
1249   4              flash_mode = 0;
1250   4              flash_t_cnt = 0;
1251   4              func_num = MENU;
1252   4              ON_RETURN = 1;  
1253   4            }
1254   3          }
1255   2          
1256   2          else if(func_num == SETTING)      //设置    ok
1257   2          {
1258   3            
1259   3            static char index = 0;    //菜单的索引(0~MENU_MAX_ROW-1)
1260   3            static char pointer = 0;  //当前所选项在屏幕上的位置(0~3)
1261   3            static char mode = -1;
1262   3            unsigned char str[21];
1263   3            unsigned char *cache;
1264   3            
1265   3            if(mode == -1)  //设置菜单界面
1266   3            {
1267   4              if(ON_OPEN | ON_RETURN)
1268   4              {
1269   5                cache = &sub_cache2;
1270   5              }
1271   4              else
1272   4                cache = &main_cache;
1273   4              if(tick_20ms)
1274   4              {
1275   5                tick_20ms = 0;
1276   5                ClearCache(cache);
1277   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1278   5                ShowString(16, 0, SETTING_MENU[index - pointer], cache, FONT8X16, NO_INVERSED, 0);
1279   5                ShowString(16, 2, SETTING_MENU[index - pointer + 1], cache, FONT8X16, NO_INVERSED, 0);
1280   5                ShowString(16, 4, SETTING_MENU[index - pointer + 2], cache, FONT8X16, NO_INVERSED, 0);
1281   5                ShowString(16, 6, SETTING_MENU[index - pointer + 3], cache, FONT8X16, NO_INVERSED, 1);
1282   5                if(ON_OPEN)
1283   5                {
1284   6                  ScreenPushAnimation(sub_cache2, LEFT);
1285   6                  ON_OPEN = 0;
1286   6                }
1287   5                else if(ON_RETURN)
1288   5                {
1289   6                  ScreenPushAnimation(sub_cache2, RIGHT);
1290   6                  ON_RETURN = 0;
1291   6                } 
1292   5              }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 22  

1293   4              if(Trg != 0)
1294   4              {
1295   5                switch(Trg)
1296   5                {
1297   6                  case KEY1:
1298   6                  {
1299   7                    ON_CLOSE = 1;
1300   7                    break;
1301   7                  }
1302   6                  case KEY2:
1303   6                  {
1304   7                    index--;
1305   7                    if(--pointer < 0)
1306   7                    {
1307   8                      pointer = 0;
1308   8                      if(index != -1)
1309   8                      {
1310   9                        ClearCache(sub_cache2);
1311   9                        ShowString(16, 6, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1312   9                        ScreeRollDown(sub_cache2, 16);
1313   9                      }
1314   8                      else
1315   8                        index = 0;
1316   8                    }
1317   7                    break;
1318   7                  } 
1319   6                  case KEY3:
1320   6                  {
1321   7                    index++;
1322   7                    if(++pointer == 4)
1323   7                    {
1324   8                      pointer = 3;
1325   8                      if(index != MENU_MAX_ROW)
1326   8                      {
1327   9                        ClearCache(sub_cache2);
1328   9                        ShowString(16, 0, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1329   9                        ScreeRollUp(sub_cache2, 16);
1330   9                      }
1331   8                      else
1332   8                        index = MENU_MAX_ROW - 1;
1333   8                    }
1334   7                    break;
1335   7                  }
1336   6                  case DOUBLE_TAP:
1337   6                  {
1338   7                    mode = index;
1339   7                    ON_OPEN = 1;
1340   7                    break;
1341   7                  }
1342   6                }
1343   5                Trg = 0;
1344   5              }
1345   4              if(ON_CLOSE)
1346   4              {
1347   5                ON_CLOSE = 0;
1348   5                func_num = MENU;
1349   5                ON_RETURN = 1;
1350   5              }
1351   4            }
1352   3            else if(mode == 0)  //设置时间  
1353   3            {
1354   4              static char pointer = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 23  

1355   4              static char set_index = 0;
1356   4              if(ON_OPEN)
1357   4              {
1358   5                ON_OPEN = 0;
1359   5                PCF8563ReadTime(&RTC);
1360   5                ClearCache(sub_cache2);
1361   5                ShowString(0, 0, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1362   5                sprintf(str, "%2d:%2d:%2d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1363   5                ShowString(16, 0, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1364   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1365   5                ShowString(16, 2, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1366   5                ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], sub_cache2, FONT6X8, NO_INVERSED, 0);
1367   5                ScreenPushAnimation(sub_cache2, LEFT);
1368   5              }
1369   4              if(tick_20ms)
1370   4              {
1371   5                tick_20ms = 0;
1372   5                ClearCache(main_cache);
1373   5                if(set_index == 0)
1374   5                  PCF8563ReadTime(&RTC);
1375   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1376   5                sprintf(str, "%02d:%02d:%02d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1377   5                ShowString(16, 0, str, main_cache, FONT8X16, NO_INVERSED, 0);
1378   5                if(pointer == 0 && set_index != 0)
1379   5                {
1380   6                  if(set_index == 1)
1381   6                  {
1382   7                    sprintf(str, "%02d", (int)RTC.hour);
1383   7                    ShowString(16, 0, str, main_cache, FONT8X16, INVERSED, 0);
1384   7                  }
1385   6                  else if(set_index == 2)
1386   6                  {
1387   7                    sprintf(str, "%02d", (int)RTC.minute);
1388   7                    ShowString(40, 0, str, main_cache, FONT8X16, INVERSED, 0);
1389   7                  }
1390   6                  else if(set_index == 3)
1391   6                  {
1392   7                    sprintf(str, "%02d", (int)RTC.second);
1393   7                    ShowString(64, 0, str, main_cache, FONT8X16, INVERSED, 0);
1394   7                  }
1395   6                }
1396   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1397   5                ShowString(16, 2, str, main_cache, FONT8X16, NO_INVERSED, 0);
1398   5                if(pointer == 1 && set_index != 0)
1399   5                {
1400   6                  if(set_index == 1)
1401   6                  {
1402   7                    sprintf(str, "%4d", (int)RTC.year);
1403   7                    ShowString(16, 2, str, main_cache, FONT8X16, INVERSED, 0);
1404   7                  }
1405   6                  else if(set_index == 2)
1406   6                  {
1407   7                    sprintf(str, "%2d", (int)RTC.month);
1408   7                    ShowString(56, 2, str, main_cache, FONT8X16, INVERSED, 0);
1409   7                  }
1410   6                  else if(set_index == 3)
1411   6                  {
1412   7                    sprintf(str, "%2d", (int)RTC.day);
1413   7                    ShowString(80, 2, str, main_cache, FONT8X16, INVERSED, 0);
1414   7                  }
1415   6                }
1416   5                if(pointer == 2 && set_index != 0)
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 24  

1417   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, INVERSED, 1);
1418   5                else
1419   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, NO_INVERSED, 1);
1420   5              }
1421   4              if(Trg != 0)
1422   4              {
1423   5                switch(Trg)
1424   5                {
1425   6                  case KEY1:
1426   6                  {
1427   7                    if(set_index != 0)
1428   7                    {
1429   8                      set_index = 0;
1430   8                      PCF8563WriteTime(RTC.hour, RTC.minute, RTC.second);
1431   8                      PCF8563WriteDate(RTC.year, RTC.month, RTC.day, RTC.weekday);
1432   8                    }
1433   7                    else
1434   7                      ON_CLOSE = 1;
1435   7                    break;
1436   7                  }
1437   6                  case KEY2:
1438   6                  {
1439   7                    if(set_index == 0)
1440   7                    {
1441   8                      if(--pointer < 0)
1442   8                        pointer = 2;
1443   8                    }
1444   7                    else
1445   7                    {
1446   8                      if(pointer == 0)
1447   8                      {
1448   9                        if(set_index == 1)
1449   9                        {
1450  10                          if(++RTC.hour == 24)
1451  10                            RTC.hour = 0;
1452  10                        }
1453   9                        else if(set_index == 2)
1454   9                        {
1455  10                          if(++RTC.minute == 60)
1456  10                            RTC.minute = 0;
1457  10                        }
1458   9                        else if(set_index == 3)
1459   9                        {
1460  10                          if(++RTC.second == 60)
1461  10                            RTC.second = 0;
1462  10                        }
1463   9                      }
1464   8                      else if(pointer == 1)
1465   8                      {
1466   9                        if(set_index == 1)
1467   9                        {
1468  10                          if(++RTC.year == 2100)
1469  10                            RTC.year = 2000;
1470  10                        }
1471   9                        else if(set_index == 2)
1472   9                        {
1473  10                          if(++RTC.month == 13)
1474  10                            RTC.month = 1;
1475  10                        }
1476   9                        else if(set_index == 3)
1477   9                        {
1478  10                          if(++RTC.day == 32)
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 25  

1479  10                            RTC.day = 1;
1480  10                        }
1481   9                      }
1482   8                      else if(pointer == 2)
1483   8                      {
1484   9                        if(set_index == 1)
1485   9                          if(++RTC.weekday == 8)
1486   9                            RTC.weekday = 1;
1487   9                      }
1488   8                    }
1489   7                    break;
1490   7                  }
1491   6                  case KEY3:
1492   6                  {
1493   7                    if(set_index == 0)
1494   7                    {
1495   8                      if(++pointer == 3)
1496   8                        pointer = 0;
1497   8                    }
1498   7                    else
1499   7                    {
1500   8                      if(pointer == 0)
1501   8                      {
1502   9                        if(set_index == 1)
1503   9                        {
1504  10                          if(--RTC.hour == 255)
1505  10                            RTC.hour = 23;
1506  10                        }
1507   9                        else if(set_index == 2)
1508   9                        {
1509  10                          if(--RTC.minute == 255)
1510  10                            RTC.minute = 59;
1511  10                        }
1512   9                        else if(set_index == 3)
1513   9                        {
1514  10                          if(--RTC.second == 255)
1515  10                            RTC.second = 59;
1516  10                        }
1517   9                      }
1518   8                      else if(pointer == 1)
1519   8                      {
1520   9                        if(set_index == 1)
1521   9                        {
1522  10                          if(--RTC.year == 1999)
1523  10                            RTC.year = 2099;
1524  10                        }
1525   9                        else if(set_index == 2)
1526   9                        {
1527  10                          if(--RTC.month == 255)
1528  10                            RTC.month = 12;
1529  10                        }
1530   9                        else if(set_index == 3)
1531   9                        {
1532  10                          if(--RTC.day == 255)
1533  10                            RTC.day = 31;
1534  10                        }
1535   9                      }
1536   8                      else if(pointer == 2)
1537   8                      {
1538   9                        if(set_index == 1)
1539   9                          if(--RTC.weekday == 0)
1540   9                            RTC.weekday = 7;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 26  

1541   9                      }
1542   8                    }
1543   7                    break;
1544   7                  }
1545   6                  case DOUBLE_TAP:
1546   6                  {
1547   7                    if(pointer < 2)
1548   7                    {
1549   8                      if(++set_index == 4)
1550   8                        set_index = 1;
1551   8                    }
1552   7                    else if(pointer == 2)
1553   7                    {
1554   8                      if(++set_index == 2)
1555   8                        set_index = 1;
1556   8                    }
1557   7                    break;
1558   7                  }
1559   6                }
1560   5                Trg = 0;
1561   5              }
1562   4              if(ON_CLOSE)
1563   4              {
1564   5                ON_CLOSE = 0;
1565   5                set_index = 0;
1566   5                pointer = 0;
1567   5                mode = -1;
1568   5                ON_RETURN = 1;
1569   5              }
1570   4            }
1571   3            else if(mode == 1)  //设置闹钟
1572   3            {
1573   4              static unsigned char pointer = 0;
1574   4              static unsigned char set_index = 0;
1575   4              if(ON_OPEN)
1576   4              {
1577   5                ON_OPEN = 0;
1578   5                ClearCache(sub_cache2);
1579   5                ShowString(16, 0, "Alarm:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1580   5                ShowString(0, 1, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1581   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1582   5                ShowString(16, 1, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1583   5                ShowString(16, 3, "Mode:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1584   5                ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], sub_cache2, FONT8X16, NO_INVERSED, 0);
1585   5                ScreenPushAnimation(sub_cache2, LEFT);
1586   5              }
1587   4              if(tick_20ms)
1588   4              {
1589   5                tick_20ms = 0;
1590   5                ClearCache(main_cache);
1591   5                ShowString(0, 1 + pointer * 3, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1592   5                ShowString(16, 0, "Alarm:", main_cache, FONT6X8, NO_INVERSED, 0);
1593   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1594   5                ShowString(16, 1, str, main_cache, FONT8X16, NO_INVERSED, 0);
1595   5                if(pointer == 0 && set_index != 0)
1596   5                {
1597   6                  if(set_index == 1)
1598   6                  {
1599   7                    sprintf(str, "%02d", (int)config.alarm_hour);
1600   7                    ShowString(16, 1, str, main_cache, FONT8X16, INVERSED, 0);
1601   7                  }
1602   6                  else if(set_index == 2)
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 27  

1603   6                  {
1604   7                    sprintf(str, "%02d", (int)config.alarm_min);
1605   7                    ShowString(40, 1, str, main_cache, FONT8X16, INVERSED, 0);
1606   7                  }
1607   6                }
1608   5                ShowString(16, 3, "Mode:", main_cache, FONT6X8, NO_INVERSED, 0);
1609   5                if(pointer == 1 && set_index != 0)
1610   5                {
1611   6                  
1612   6                  if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1613   6                  {
1614   7                    sprintf(str, "%02d", (int)config.alarm_day);
1615   7                    ShowString(16, 6, str, main_cache, FONT8X16, set_index==1?NO_INVERSED:INVERSED, 0);
1616   7                  }
1617   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, INVERSED, 1); 
1618   6                }
1619   5                else
1620   5                {
1621   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, NO_INVERSED, 1);            
1622   6                }
1623   5              }
1624   4              if(Trg != 0)
1625   4              {
1626   5                switch(Trg)
1627   5                {
1628   6                  case KEY1:
1629   6                  {
1630   7                    if(set_index != 0)
1631   7                      set_index = 0;
1632   7                    else
1633   7                      ON_CLOSE = 1;
1634   7                    break;
1635   7                  }
1636   6                  case KEY2:
1637   6                  {
1638   7                    if(set_index == 0)
1639   7                    {
1640   8                      if(++pointer == 2)
1641   8                        pointer = 0;
1642   8                    }
1643   7                    else
1644   7                    {
1645   8                      if(pointer == 0)
1646   8                      {
1647   9                        if(set_index == 1)
1648   9                        {
1649  10                          if(++config.alarm_hour == 24)
1650  10                            config.alarm_hour = 0;
1651  10                        }
1652   9                        else if(set_index == 2)
1653   9                        {
1654  10                          if(++config.alarm_min == 60)
1655  10                          config.alarm_min = 0;
1656  10                        }
1657   9                      }
1658   8                      else if(pointer == 1)
1659   8                      {
1660   9                        if(set_index == 1)
1661   9                        {
1662  10                          if(++config.alarm_mode == ALARM_MODE_NUM)
1663  10                            config.alarm_mode = 0;
1664  10                        }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 28  

1665   9                        else if(set_index == 2)
1666   9                        {
1667  10                          if(++config.alarm_day == 32)
1668  10                          {
1669  11                            config.alarm_day = 1;
1670  11                          }
1671  10                        }
1672   9                      }
1673   8                    }
1674   7                    break;
1675   7                  } 
1676   6                  case KEY3:
1677   6                  {
1678   7                    if(set_index == 0)
1679   7                    {
1680   8                      if(--pointer == 255)
1681   8                        pointer = 1;
1682   8                    }
1683   7                    else 
1684   7                    {
1685   8                      if(pointer == 0)
1686   8                      {
1687   9                        if(set_index == 1)
1688   9                        {
1689  10                          if(--config.alarm_hour == 255)
1690  10                            config.alarm_hour = 23;
1691  10                        }
1692   9                        else if(set_index == 2)
1693   9                        {
1694  10                          if(--config.alarm_min == 255)
1695  10                            config.alarm_min = 59;
1696  10                        }
1697   9                      }
1698   8                      else if(pointer == 1)
1699   8                      {
1700   9                        if(set_index == 1)
1701   9                        {
1702  10                          if(--config.alarm_mode == 255)
1703  10                            config.alarm_mode = ALARM_MODE_NUM - 1;
1704  10                        }
1705   9                        else if(set_index == 2)
1706   9                        {
1707  10                          if(--config.alarm_day == 0)
1708  10                          {
1709  11                            config.alarm_day = 31;
1710  11                          }
1711  10                        }
1712   9                      }
1713   8                    }
1714   7                    break;
1715   7                  }
1716   6                  case DOUBLE_TAP:
1717   6                  {
1718   7                    if(set_index == 0)
1719   7                      set_index ++;
1720   7                    else
1721   7                    {
1722   8                      if(pointer == 0)
1723   8                      {
1724   9                        if(++set_index == 3)
1725   9                          set_index = 1;
1726   9                      }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 29  

1727   8                      else if(pointer == 1)
1728   8                      {
1729   9                        if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1730   9                        {
1731  10                          if(++set_index == 3)
1732  10                          set_index = 1;
1733  10                        }
1734   9                      }
1735   8                    }
1736   7                    break;
1737   7                  }
1738   6                }
1739   5                Trg = 0;
1740   5              }
1741   4              if(ON_CLOSE)
1742   4              {
1743   5                ON_CLOSE = 0;
1744   5                set_index = 0;
1745   5                pointer = 0;
1746   5                if(config.alarm_mode != ALARM_DISABLE)
1747   5                {
1748   6                  if(config.alarm_mode == ALARM_WORKDAY)
1749   6                  {
1750   7                    PCF8563ReadTime(&RTC);
1751   7                    if(RTC.weekday > 5)
1752   7                      config.alarm_weekday = 1;
1753   7                    else
1754   7                    {
1755   8                      if((config.alarm_hour > RTC.hour) && (config.alarm_min > RTC.minute))
1756   8                        config.alarm_weekday = RTC.weekday;
1757   8                      else
1758   8                      {
1759   9                        if(RTC.weekday != 5)
1760   9                          config.alarm_weekday = RTC.weekday;
1761   9                        else
1762   9                          config.alarm_weekday = RTC.weekday + 1;
1763   9                      }
1764   8                    }
1765   7                  }
1766   6                  PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.
             -alarm_mode);
1767   6                }
1768   5                else
1769   5                  PCF8563DisableAlarm();
1770   5                EEPROMWriteConfiguration(&config);
1771   5                mode = -1;
1772   5                ON_RETURN = 1;
1773   5              }
1774   4            }
1775   3            else if(mode == 2)  //设置亮度
1776   3            {
1777   4              static char temp;
1778   4              //unsigned char *cache;
1779   4              if(ON_OPEN)
1780   4              {
1781   5                ON_OPEN = 0;
1782   5                temp = config.screen_brightness / 50;
1783   5                ClearCache(sub_cache2);
1784   5                ShowString(0, 0, "Set the contrast ratio of the screen.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1785   5                sprintf(str, "%d", (int)temp);
1786   5                ShowString(56, 3, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1787   5                ScreenPushAnimation(sub_cache2, LEFT);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 30  

1788   5              }
1789   4              if(tick_20ms)
1790   4              {
1791   5                tick_20ms = 0;  
1792   5                ClearCache(main_cache);
1793   5                ShowString(0, 0, "Set the contrast ratio of the screen.", main_cache, FONT6X8, NO_INVERSED, 0);
1794   5                sprintf(str, "%d", (int)temp);
1795   5                ShowString(56, 3, str, main_cache, FONT8X16, NO_INVERSED, 1);
1796   5              }
1797   4              if(Trg != 0)
1798   4              {
1799   5                switch(Trg)
1800   5                {
1801   6                  case 0x01:
1802   6                  {
1803   7                    ON_CLOSE = 1;
1804   7                    break;
1805   7                  }
1806   6                  case 0x02:
1807   6                  {
1808   7                    if(++temp == 6)
1809   7                      temp = 5;
1810   7                    config.screen_brightness = temp * 50 + 1;
1811   7                    ScreenSetBrightness(config.screen_brightness);
1812   7                    break;
1813   7                  } 
1814   6                  case 0x04:
1815   6                  {
1816   7                    if(--temp < 0)
1817   7                      temp = 0;
1818   7                    config.screen_brightness = temp * 50 + 1;
1819   7                    ScreenSetBrightness(config.screen_brightness);
1820   7                    break;
1821   7                  }
1822   6                  case 0x08:
1823   6                    break;
1824   6                }
1825   5                Trg = 0;
1826   5              }
1827   4              if(ON_CLOSE)
1828   4              {
1829   5                ON_CLOSE = 0;
1830   5                EEPROMWriteConfiguration(&config);
1831   5                mode = -1;
1832   5                ON_RETURN = 1;
1833   5              }
1834   4            }
1835   3            else if(mode == 3)  //设置自动息屏时间
1836   3            {
1837   4              static int temp;
1838   4              if(ON_OPEN)
1839   4              {
1840   5                ON_OPEN = 0;
1841   5                temp = config.t_inactive_max;
1842   5                ClearCache(sub_cache2);
1843   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1844   5                sprintf(str, "%d", temp);
1845   5                ShowString(56, 5, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1846   5                ShowString(72, 6, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1847   5                ScreenPushAnimation(sub_cache2, LEFT);
1848   5              }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 31  

1849   4              if(tick_20ms)
1850   4              {
1851   5                tick_20ms = 0;
1852   5                ClearCache(main_cache);
1853   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", main_cache, FONT6X8, NO_INVERSED, 0);
1854   5                sprintf(str, "%d", temp);
1855   5                ShowString(56, 5, str, main_cache, FONT8X16, NO_INVERSED, 0);
1856   5                ShowString(72, 6, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1857   5              }
1858   4              if(Trg != 0)
1859   4              {
1860   5                switch(Trg)
1861   5                {
1862   6                  case KEY1:
1863   6                  {
1864   7                    ON_CLOSE = 1;
1865   7                    break;
1866   7                  }
1867   6                  case KEY2:
1868   6                  {
1869   7                    if(++temp == 100)
1870   7                      temp = 99;
1871   7                    break;
1872   7                  } 
1873   6                  case KEY3:
1874   6                  {
1875   7                    if(--temp < 0)
1876   7                      temp = 0;
1877   7                    break;
1878   7                  }
1879   6                }
1880   5                Trg = 0;
1881   5              }
1882   4              if(ON_CLOSE)
1883   4              {
1884   5                ON_CLOSE = 0;
1885   5                config.t_inactive_max = temp;
1886   5                EEPROMWriteConfiguration(&config);
1887   5                mode = -1;
1888   5                ON_RETURN = 1;
1889   5              }
1890   4            }
1891   3            else if(mode == 4)  //设置自动关机时间
1892   3            {
1893   4              static int temp;
1894   4              if(ON_OPEN)
1895   4              {
1896   5                ON_OPEN = 0;
1897   5                temp = config.t_sleep_max;
1898   5                ClearCache(sub_cache2);
1899   5                ShowString(0, 0, "The time which mcu stay active for without any operation before power-down,when set
             - to 0,the mcu will never power down.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1900   5                sprintf(str, "%d", temp);
1901   5                ShowString(56, 6, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1902   5                ShowString(72, 7, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1903   5                ScreenPushAnimation(sub_cache2, LEFT);
1904   5              }
1905   4              if(tick_20ms)
1906   4              {
1907   5                tick_20ms = 0;
1908   5                ClearCache(main_cache);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 32  

1909   5                ShowString(0, 0, "The time which mcu stay active for before without any operation power-down,when set
             - to 0,the mcu will never power down.", main_cache, FONT6X8, NO_INVERSED, 0);
1910   5                sprintf(str, "%d", temp);
1911   5                ShowString(56, 6, str, main_cache, FONT8X16, NO_INVERSED, 0);
1912   5                ShowString(72, 7, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1913   5              }
1914   4              if(Trg != 0)
1915   4              {
1916   5                switch(Trg)
1917   5                {
1918   6                  case 0x01:
1919   6                  {
1920   7                    ON_CLOSE = 1;
1921   7                    break;
1922   7                  }
1923   6                  case 0x02:
1924   6                  {
1925   7                    if(++temp == 100)
1926   7                      temp = 99;
1927   7                    break;
1928   7                  } 
1929   6                  case 0x04:
1930   6                  {
1931   7                    if(--temp < 0)
1932   7                      temp = 0;
1933   7                    break;
1934   7                  }
1935   6                }
1936   5                Trg = 0;
1937   5              }
1938   4              if(ON_CLOSE)
1939   4              {
1940   5                ON_CLOSE = 0;
1941   5                config.t_sleep_max = temp;
1942   5                EEPROMWriteConfiguration(&config);
1943   5                mode = -1;
1944   5                ON_RETURN = 1;
1945   5              }
1946   4            }
1947   3            else if(mode == 5)  //设置屏幕反色
1948   3            {
1949   4              if(ON_OPEN)
1950   4              {
1951   5                ON_OPEN = 0;
1952   5                ClearCache(sub_cache2);
1953   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", sub_cache2, FONT8X16, NO_INVERSED, 0)
             -;
1954   5                ScreenPushAnimation(sub_cache2, LEFT);
1955   5              }
1956   4              if(tick_20ms)
1957   4              {
1958   5                tick_20ms = 0;
1959   5                ClearCache(main_cache);
1960   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", main_cache, FONT8X16, NO_INVERSED, 1)
             -;
1961   5              }
1962   4              if(Trg != 0)
1963   4              {
1964   5                switch(Trg)
1965   5                {
1966   6                  case KEY1:
1967   6                  {
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 33  

1968   7                    ON_CLOSE = 1;
1969   7                    break;
1970   7                  }
1971   6                  case DOUBLE_TAP:
1972   6                  {
1973   7                    if(config.screen_inverse == INVERSED)
1974   7                      config.screen_inverse = NO_INVERSED;
1975   7                    else
1976   7                      config.screen_inverse = INVERSED;
1977   7                    ScreenSetInverse(config.screen_inverse);
1978   7                    break;
1979   7                  } 
1980   6                }
1981   5                Trg = 0;
1982   5              }
1983   4              if(ON_CLOSE)
1984   4              {
1985   5                ON_CLOSE = 0;
1986   5                EEPROMWriteConfiguration(&config);
1987   5                mode = -1;
1988   5                ON_RETURN = 1;
1989   5              }
1990   4            }
1991   3            else if(mode == 6)  //设置屏幕方向
1992   3            {
1993   4              if(ON_OPEN)
1994   4              {
1995   5                ON_OPEN = 0;
1996   5                ClearCache(sub_cache2);
1997   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", sub_cache2, FONT8X16, NO
             -_INVERSED, 0);
1998   5                ScreenPushAnimation(sub_cache2, LEFT);
1999   5              }
2000   4              if(tick_20ms)
2001   4              {
2002   5                tick_20ms = 0;
2003   5                ClearCache(main_cache);
2004   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", main_cache, FONT8X16, NO
             -_INVERSED, 1);
2005   5              }
2006   4              if(Trg != 0)
2007   4              {
2008   5                switch(Trg)
2009   5                {
2010   6                  case KEY1:
2011   6                  {
2012   7                    ON_CLOSE = 1;
2013   7                    break;
2014   7                  }
2015   6                  case DOUBLE_TAP:
2016   6                  {
2017   7                    if(config.screen_direction == UPSIDEDOWN)
2018   7                      config.screen_direction = NORMAL;
2019   7                    else
2020   7                      config.screen_direction = UPSIDEDOWN;
2021   7                    ScreenSetDirection(config.screen_direction);
2022   7                    break;
2023   7                  } 
2024   6                }
2025   5                Trg = 0;
2026   5              }
2027   4              if(ON_CLOSE)
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 34  

2028   4              {
2029   5                ON_CLOSE = 0;
2030   5                EEPROMWriteConfiguration(&config);
2031   5                mode = -1;
2032   5                ON_RETURN = 1;
2033   5              }
2034   4            }
2035   3            else if(mode == 7)  //设置按键音
2036   3            {
2037   4              if(ON_OPEN)
2038   4              {
2039   5                ON_OPEN = 0;
2040   5                ClearCache(sub_cache2);
2041   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", sub_cache2, FONT8X16, NO_INVERSED,
             - 0);
2042   5                ScreenPushAnimation(sub_cache2, LEFT);
2043   5              }
2044   4              if(tick_20ms)
2045   4              {
2046   5                tick_20ms = 0;
2047   5                ClearCache(main_cache);
2048   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", main_cache, FONT8X16, NO_INVERSED,
             - 1);
2049   5              }
2050   4              if(Trg != 0)
2051   4              {
2052   5                switch(Trg)
2053   5                {
2054   6                  case KEY1:
2055   6                  {
2056   7                    ON_CLOSE = 1;
2057   7                    break;
2058   7                  }
2059   6                  case DOUBLE_TAP:
2060   6                  {
2061   7                    if(config.key_sound == ON)
2062   7                      config.key_sound = OFF;
2063   7                    else
2064   7                      config.key_sound = ON;
2065   7                    EnableBuzzer(config.key_sound);
2066   7                    break;
2067   7                  }
2068   6                }
2069   5                Trg = 0;
2070   5              }
2071   4              if(ON_CLOSE)
2072   4              {
2073   5                ON_CLOSE = 0;
2074   5                EEPROMWriteConfiguration(&config);
2075   5                mode = -1;
2076   5                ON_RETURN = 1;
2077   5              }
2078   4            }
2079   3            else if(mode == 8)  //单片机复位
2080   3            {
2081   4              MCUSoftReset();
2082   4            }
2083   3            else if(mode == 9)  //系统掉电
2084   3            {
2085   4              ON_OPEN = 0;
2086   4              active_flag = 0;
2087   4              action = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 35  

2088   4              sleep_flag = 0;
2089   4              powerdown_flag = 0;
2090   4              inactive_time = 0;
2091   4              sleep_time = 0;
2092   4              deep_powerdown_flag = 1;
2093   4              mode = -1;
2094   4              func_num = WATCH;
2095   4            }
2096   3          }
2097   2          
2098   2          else if(func_num == SNAKES)       //贪吃蛇  ok
2099   2          {
2100   3            #define PANEL_WIDTH   92
2101   3            #define PANEL_HEIGHT  64
2102   3            #define MAX_SNAKE_SPEED 50
2103   3                
2104   3            unsigned char i = 0;
2105   3            unsigned char str[6];
2106   3            static unsigned char snake_direction = 0;//means sneak direction
2107   3            static unsigned char snake_speed = 10;
2108   3            static unsigned char past_x[256];
2109   3            static unsigned char past_y[256];
2110   3            static unsigned char snake_head_x = 64, snake_head_y = 32, snake_len = 20;
2111   3            static unsigned char test_now = 0, delicious_x= 80,delicious_y = 40;
2112   3            static unsigned char best_score = 0;
2113   3            static bit game_loop = 0;
2114   3            static bit game_over = 0;
2115   3            static bit game_pause = 0;
2116   3          
2117   3            if(ON_OPEN)
2118   3            {
2119   4              ON_OPEN = 0;
2120   4              ClearCache(sub_cache2);
2121   4              ScreenPushAnimation(sub_cache2, LEFT);//设定该界面左移进入屏幕
2122   4              snake_direction = 0;
2123   4              snake_head_x = 64;
2124   4              snake_head_y = 32;
2125   4              snake_len = 20;
2126   4              game_over = 0;
2127   4              game_pause = 0;
2128   4              for(i = 0; i < snake_len; i++)
2129   4              {
2130   5                past_x[i] = 64;
2131   5                past_y[i] = 32;
2132   5              }
2133   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
2134   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
2135   4            }
2136   3            if(tick_8ms)
2137   3            {
2138   4              tick_8ms = 0;
2139   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
2140   4              IMUupdate(&LSM6DSM);
2141   4            }
2142   3            if(tick_1ms)
2143   3            {
2144   4              static unsigned char t_cnt = 0;
2145   4              tick_1ms = 0;
2146   4              if(++t_cnt == (MAX_SNAKE_SPEED - snake_speed))
2147   4              {
2148   5                t_cnt = 0;
2149   5                game_loop = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 36  

2150   5              }
2151   4            }
2152   3            if(game_loop)
2153   3            {
2154   4              game_loop = 0;
2155   4              inactive_time = 0;//to not close screen
2156   4              if(game_pause != 1)
2157   4              {
2158   5                ClearCache(main_cache);
2159   5                for(i = 0; i < PANEL_WIDTH; i++)  //画一个框
2160   5                {
2161   6                  DrawDot(i, 0);
2162   6                  DrawDot(i, PANEL_HEIGHT - 1);
2163   6                }
2164   5                for(i = 0; i < PANEL_HEIGHT; i++)
2165   5                {
2166   6                  DrawDot(0, i);
2167   6                  DrawDot(PANEL_WIDTH - 1, i);
2168   6                }
2169   5                ShowString(PANEL_WIDTH, 1, "Score:", main_cache, FONT6X8, NO_INVERSED, 0);
2170   5                sprintf(str, "%3d", (int)snake_len);
2171   5                ShowString(PANEL_WIDTH, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
2172   5                ShowString(PANEL_WIDTH, 5, "Best:", main_cache, FONT6X8, NO_INVERSED, 0);
2173   5                if(snake_len > best_score)
2174   5                  best_score = snake_len;
2175   5                sprintf(str, "%3d", (int)best_score);
2176   5                ShowString(PANEL_WIDTH, 6, str, main_cache, FONT6X8, NO_INVERSED, 0);
2177   5                if(snake_direction == 0)
2178   5                {
2179   6                  if(LSM6DSM.AngleY > 10)
2180   6                    snake_direction = 1;
2181   6                  else if(LSM6DSM.AngleY < -10)
2182   6                    snake_direction = 3;
2183   6                }
2184   5                else if(snake_direction == 1)
2185   5                {
2186   6                  if(LSM6DSM.AngleX > 10)
2187   6                    snake_direction = 0;
2188   6                  else if(LSM6DSM.AngleX < -10)
2189   6                    snake_direction = 2;
2190   6                }
2191   5                else if(snake_direction == 2)
2192   5                {
2193   6                  if(LSM6DSM.AngleY > 10)
2194   6                    snake_direction = 1;
2195   6                  else if(LSM6DSM.AngleY < -10)
2196   6                    snake_direction = 3;
2197   6                }
2198   5                else if(snake_direction == 3)
2199   5                {
2200   6                  if(LSM6DSM.AngleX > 10)
2201   6                    snake_direction = 0;
2202   6                  else if(LSM6DSM.AngleX < -10)
2203   6                    snake_direction = 2;
2204   6                }
2205   5                //这段是按键程序解析后转换为方向以及点位置的程序，
2206   5                //sneak_direction是方向，test_x是头部的x轴值，test_y是头部的y轴值
2207   5                switch(snake_direction)
2208   5                {
2209   6                  case 0:   //右
2210   6                    snake_head_x++;
2211   6                    break;
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 37  

2212   6                  case 1:   //下
2213   6                    snake_head_y++;
2214   6                    break;
2215   6                  case 2:   //左
2216   6                    snake_head_x--;
2217   6                    break;
2218   6                  case 3:   //上
2219   6                    snake_head_y--;
2220   6                    break;
2221   6                }
2222   5                if(snake_head_x >= PANEL_WIDTH)
2223   5                  snake_head_x = 1;
2224   5                else if(snake_head_x <= 0)
2225   5                  snake_head_x = PANEL_WIDTH - 1;
2226   5                if(snake_head_y >= PANEL_HEIGHT)
2227   5                  snake_head_y = 1;
2228   5                else if(snake_head_y <= 0)
2229   5                  snake_head_y = PANEL_HEIGHT - 1;
2230   5                //检查是否碰到自己的身体
2231   5                for(i = 0; i < snake_len; i++)
2232   5                {
2233   6                  if((snake_head_x == past_x[i]) && (snake_head_y == past_y[i]))
2234   6                  {
2235   7                    game_over = 1;
2236   7                    game_pause = 1;
2237   7                    break;
2238   7                  }
2239   6                }
2240   5                //这段是可以让贪吃蛇有可变长度尾巴的测试程序，test_num就是尾巴的数量，最大50，
2241   5                //程序原理是把每次过去的坐标都记录在数组里面。显示的时候就把过去的点也都显示出来
2242   5                test_now++;
2243   5                test_now = test_now % snake_len;
2244   5                past_x[test_now] = snake_head_x;
2245   5                past_y[test_now] = snake_head_y;
2246   5                for(i = 0; i < snake_len; i++)
2247   5                {
2248   6                  DrawDot(past_x[i], past_y[i]);
2249   6                }
2250   5                //这段程序放被吃掉的小东西，设计delicious_x,delicious_y为食物的坐标
2251   5                //吃掉食物以后会放一个新的食物，并且test_num也就是尾巴的数量会大1
2252   5                if((snake_head_x <= delicious_x+1) && (snake_head_y <= delicious_y+1) && (snake_head_x >= delicious_x
             --1) && (snake_head_y>=delicious_y-1))
2253   5                {
2254   6                  snake_len++;
2255   6                  past_x[snake_len - 1] = past_x[snake_len - 2];//解决小白点的问题
2256   6                  past_y[snake_len - 1] = past_y[snake_len - 2];
2257   6                  Bee();
2258   6                  delicious_x = rand() % 92;
2259   6                  if(delicious_x > PANEL_WIDTH - 2)
2260   6                    delicious_x = PANEL_WIDTH - 2;
2261   6                  else if(delicious_x < 2)
2262   6                    delicious_x  = 2;
2263   6                  delicious_y = rand() % 64;
2264   6                  if(delicious_y > PANEL_HEIGHT - 2)
2265   6                    delicious_y = PANEL_HEIGHT - 2;
2266   6                  else if(delicious_y < 2)
2267   6                    delicious_y  = 2;
2268   6                }
2269   5                DrawDot(delicious_x,delicious_y);
2270   5                DrawDot(delicious_x+1,delicious_y);
2271   5                DrawDot(delicious_x-1,delicious_y);
2272   5                DrawDot(delicious_x,delicious_y+1);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 38  

2273   5                DrawDot(delicious_x+1,delicious_y+1);
2274   5                DrawDot(delicious_x-1,delicious_y+1);
2275   5                DrawDot(delicious_x,delicious_y-1);
2276   5                DrawDot(delicious_x+1,delicious_y-1);
2277   5                DrawDot(delicious_x-1,delicious_y-1);
2278   5                if(snake_len < 30)
2279   5                  snake_speed = 10;
2280   5                else if(snake_len < 40)
2281   5                  snake_speed = 20;
2282   5                else if(snake_len < 60)
2283   5                  snake_speed = 30;
2284   5                else if(snake_len < 90)
2285   5                  snake_speed = 35;
2286   5                else if(snake_len < 130)
2287   5                  snake_speed = 40;
2288   5                else
2289   5                  snake_speed = 45;
2290   5              }
2291   4              if(game_over)
2292   4              {
2293   5                ShowString(30, 2, "GAME", main_cache, FONT8X16, NO_INVERSED, 0);
2294   5                ShowString(30, 4, "OVER", main_cache, FONT8X16, NO_INVERSED, 0);
2295   5              }
2296   4              ScreenRefreshAll(main_cache);
2297   4            }
2298   3            if(Trg != 0)
2299   3            {
2300   4              switch(Trg)
2301   4              {
2302   5                case KEY1:
2303   5                {
2304   6                  ON_CLOSE = 1;
2305   6                  break;
2306   6                }
2307   5                case KEY2:
2308   5                {
2309   6                  if(game_over != 1)
2310   6                  {
2311   7                    if(game_pause)
2312   7                      game_pause = 0;
2313   7                    else
2314   7                      game_pause = 1;
2315   7                  }
2316   6                  break;
2317   6                }
2318   5                case KEY3:
2319   5                {
2320   6                  ON_OPEN = 1;
2321   6                  break;
2322   6                }
2323   5              }
2324   4              Trg = 0;
2325   4            }
2326   3            if(ON_CLOSE)
2327   3            {
2328   4              ON_CLOSE = 0;
2329   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
2330   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
2331   4              func_num = MENU;
2332   4              ON_RETURN = 1;  
2333   4            }
2334   3          }
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 39  

2335   2          
2336   2          if(action)          //系统在不同状态下对动作的处理
2337   2          {
2338   3            action = 0;
2339   3            if(active_flag)
2340   3              inactive_time = 0;
2341   3            else if(sleep_flag)
2342   3            {
2343   4              sleep_flag = 0;
2344   4              sleep_time = 0;
2345   4              active_flag = 1;
2346   4              ScreenOnOff(ON);
2347   4              screen_on_flag = 1;
2348   4            }
2349   3            else if(powerdown_flag)
2350   3            {
2351   4              powerdown_flag = 0;
2352   4              active_flag = 1;
2353   4              SystemPowerOn();
2354   4              ScreenOnOff(ON);
2355   4              screen_on_flag = 1;
2356   4              ON_OPEN = 1;
2357   4            }
2358   3            else if(deep_powerdown_flag)
2359   3            {
2360   4              deep_powerdown_flag = 0;
2361   4              active_flag = 1;
2362   4              SystemPowerOn();
2363   4              DisplayInit(&config);
2364   4              screen_on_flag = 1;
2365   4              SensorInit();
2366   4              PW02SetMode(0);
2367   4              PCF8563EnableTimer(TIMERCLK_1_60_HZ, 1);  //自动唤醒频率1min一次
2368   4              ON_OPEN = 1;
2369   4            }
2370   3            autowake_cnt = 0;
2371   3          }
2372   2          if(sleep_flag)
2373   2          {
2374   3          
2375   3            if(screen_on_flag)
2376   3            {
2377   4              ScreenOnOff(ON);
2378   4              screen_on_flag = 0;
2379   4            }
2380   3          }   
2381   2          if(powerdown_flag)    
2382   2          {
2383   3            if(ON_CLOSE == 0)
2384   3            {
2385   4              SystemPowerDown();
2386   4            }
2387   3          }
2388   2          if(deep_powerdown_flag)
2389   2          {
2390   3            if(ON_CLOSE == 0)
2391   3            {
2392   4              SystemDeepPowerDown();
*** WARNING C206 IN LINE 2392 OF ..\User\main.c: 'SystemDeepPowerDown': missing function-prototype
2393   4            }
2394   3            Enable3V3Output(1);
2395   3            Delay1ms(10);
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 40  

2396   3          
2397   3          if(alarm_flag)
2398   3          {
2399   4            sleep_time = 0;     //闹铃被关掉前不会待机
2400   4          }
2401   3          if(timer_on_flag)
2402   3          {
2403   4            sleep_time = 0;     //计时器在工作时不会待机
2404   4          }
2405   3          if(PCF8563_int_flag)  //PCF8563产生了中断信号
2406   3          {
2407   4            unsigned char pcf8563_int_src;
2408   4            PCF8563_int_flag = 0;
2409   4            pcf8563_int_src = PCF8563ReadIntSrc();  //读PCF8563状态寄存器
2410   4            PCF8563ReadTime(&RTC);
2411   4            
2412   4            if(pcf8563_int_src & ALARM_INT)       //如果是闹钟中断
2413   4            {
2414   5                     
2415   5              PCF8563ClearAlarmFlag();  //清除闹钟中断标志位
2416   5              action = 1;       //产生动作
2417   5              alarm_flag = 1;   //置位闹钟标志位
2418   5              Beebeebee();      //响铃
2419   5              Delay1ms(5);
2420   5              if(config.alarm_mode == ALARM_WORKDAY) 
2421   5              {
2422   6                if(RTC.weekday + 1 > 5)
2423   6                  config.alarm_weekday = 1;
2424   6                else
2425   6                  config.alarm_weekday = RTC.weekday + 1;
2426   6                PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.a
             -larm_mode);
2427   6              }
2428   5              else if(config.alarm_mode != ALARM_EVERYDAY)  //如果闹钟模式不是每天都响
2429   5              {
2430   6                config.alarm_mode = ALARM_DISABLE;  //关闭闹钟
2431   6                PCF8563DisableAlarm();              //关闭闹钟
2432   6              }
2433   5              EEPROMWriteConfiguration(&config);
2434   5            }
2435   4            if(pcf8563_int_src & TIMER_INT)       //如果是定时器中断
2436   4            {
2437   5              PCF8563ClearTimerFlag();  //清除定时器中断标志位
2438   5              //PCF8563以固定的时间间隔唤醒MCU
2439   5              //唤醒之后执行以下内容  
2440   5              battery_life = GetBatteryLife();
2441   5              if(active_flag || sleep_flag || powerdown_flag)      
2442   5              {
2443   6                if((RTC.hour == 22) && (RTC.minute == 4))   //22:04,记录当天的步数数据
2444   6                {
2445   7                  char i, j;
2446   7                  for(i = 6; i > 0; i--)
2447   7                  {
2448   8                    for(j = 0; j < 10; j++)
2449   8                    {
2450   9                      config.history_step[i][j] = config.history_step[i - 1][j];
2451   9                    }
2452   8                  }
2453   7                  sprintf(config.history_step[0], "%d/%d %d", (int)RTC.month, (int)RTC.day, (int)LSM6DSMGetCurrentStep
             -());
2454   7                  EEPROMWriteConfiguration(&config);
2455   7                  LSM6DSMResetStepCounter();
C51 COMPILER V9.52.0.0   MAIN                                                              08/26/2021 06:14:25 PAGE 41  

2456   7                }
2457   6              }
2458   5              if(powerdown_flag)
2459   5              {
2460   6                if(++autowake_cnt >= 1440)    //1440分钟 = 1天
2461   6                {
2462   7                  autowake_cnt = 0;
2463   7                  powerdown_flag = 0;
2464   7                  PCF8563EnableTimer(TIMERCLK_1_60_HZ, 10); //自动唤醒频率改为10min一次，本来1min一次
2465   7                  deep_powerdown_flag = 1;
2466   7                }
2467   6              }
2468   5            } 
2469   4          
2470   4          }
2471   3            
2472   3        }          
2473   2        }
2474   1      } 
*** WARNING C280 IN LINE 284 OF ..\User\main.c: 'n': unreferenced local variable
*** WARNING C280 IN LINE 284 OF ..\User\main.c: 'm': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  17961    ----
   CONSTANT SIZE    =   9016    ----
   XDATA SIZE       =    862     132
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
