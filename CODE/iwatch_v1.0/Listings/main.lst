C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Objects\main.obj
COMPILER INVOKED BY: E:\install_files\keil\C51\BIN\C51.EXE ..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\
                    -oled;..\User\rtc;..\User\System;..\User;..\User\bluetooth;..\User\radio;..\User\sensor) DEBUG OBJECTEXTEND PRINT(..\List
                    -ings\main.lst) TABS(2) OBJECT(..\Objects\main.obj)

line level    source

   1          #include "Sys.h"
   2          #include "bmp.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "stdlib.h"
   6          #include "string.h"
   7          #include "math.h"
   8          #include "Delay.h"
   9          #include "PowerManage.h"
  10          #include "Buzzer.h"
  11          #include "Display.h"
  12          #include "PW02.h"
  13          #include "PCF8563.h"
  14          #include "BME280.h"                  
  15          #include "HMC5883L.h"                 
  16          #include "RDA5807M.h"
  17          #include "LSM6DSM.h"
  18          #include "Ellipsoid fitting.h"
  19          #include "stc8a.h"
  20          
  21          
  22          
  23          
  24          /***********************状态机相关变量*********************/
  25          enum function func_num = WATCH;    //功能号
  26          char func_index;               //功能索引
  27          bit ON_OPEN = 0;
  28          bit ON_CLOSE = 0;
  29          bit ON_RETURN = 0;
  30          /********************************************************/
  31          /************************时基信号************************/
  32          bit tick_1ms = 0;             //1000Hz
  33          bit tick_8ms = 0;             //125hz
  34          bit tick_20ms = 0;            //50hz
  35          
  36          /*************************工作状态相关变量*******************************/
  37          bit action = 0;             //动态标志位
  38          bit active_flag =1;       //活动标志位
  39          bit sleep_flag = 0;         //睡眠标志位
  40          bit powerdown_flag = 0;     //掉电标志位
  41          bit deep_powerdown_flag = 0;    //深度掉电标志位
  42          unsigned int inactive_time =0;  //自动息屏的时间
  43          unsigned int sleep_time = 0;    //自动待机时间
  44          unsigned int autowake_cnt = 0;  //自动唤醒的次数
  45          bit screen_on_flag = 1;     //屏幕状态标志位
  46          bit PCF8563_int_flag = 0;   //pcf8563中断产生标志位
  47          bit alarm_flag = 0;         //闹铃标志位
  48          bit radio_on_flag = 0;      //收音机工作标志位
  49          bit timer_on_flag = 0;      //计时器工作标志位
  50          /*************************按键相关变量*********************/
  51          unsigned char Trg = 0;      //按键触发值
  52          unsigned char Cont = 0;     //按键持续值
  53          /*************************显示缓存*******************************/
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 2   

  54          extern unsigned char xdata main_cache[];
  55          extern unsigned char xdata sub_cache1[];
  56          extern unsigned char xdata sub_cache2[];          
  57          
  58          struct sys_config config;   //设置信息结构体
  59          struct pcf8563_time RTC;    //时间信息结构体
  60          struct bme280_data BME280;  //bme280数据结构体
  61          struct lsm6dsm_data LSM6DSM;//LSM6DSM 数据结构体
  62          struct cal_data magnet_cal_data;  //磁力计叫做数据结构体
  63          float battery_life;         //电池电量
  64          unsigned int  timer_cnt = 0;//定时器0溢出次数
  65          
  66          
  67          void KeyScan(void)
  68          {
  69   1        unsigned char dat = 0x00;
  70   1        if(K1 == 0)
  71   1          dat |= KEY1;
  72   1        if(K2 == 0)
  73   1          dat |= KEY2;
  74   1        if(K3 ==0)
  75   1          dat |= KEY3;
  76   1        Trg = dat&(dat^Cont);
  77   1        Cont = dat;
  78   1      }
  79          
  80          void TM3_Ist()  interrupt 19 using 1    //  mcu定时器中断
  81          {
  82   1        static unsigned int t_count = 0;
  83   1        static unsigned int t_key_press =0; 
  84   1        AUXINTIF &= ~T3IF;                    //清除中断标志位
  85   1        if((K1 == 0) && (K2 == 0) && (K3 == 0))
  86   1        {
  87   2          while ((K1 == 0) ||(K2 == 0) ||(K3 == 0) ); //三个按键均抬起
  88   2            MCUSoftReset();                         //软复位MCU
  89   2        }
  90   1          if(t_count % 50 == 0)
  91   1        {
  92   2          KeyScan();
  93   2          if(Trg)
  94   2          {
  95   3            Bee();
  96   3            action = 1;
  97   3            if(sleep_flag || powerdown_flag || alarm_flag)
  98   3            {
  99   4              Trg = 0;
 100   4              if(alarm_flag)
 101   4              {
 102   5                alarm_flag = 0;
 103   5                LED(OFF);
 104   5              }
 105   4            }
 106   3          }
 107   2          if(Cont)
 108   2          {
 109   3            if(++t_key_press > 10)  //判断是否长按
 110   3              Trg = Cont;           //重复触发
 111   3          }
 112   2          else
 113   2            t_key_press = 0;
 114   2        }
 115   1        tick_1ms = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 3   

 116   1        if(t_count % 8 == 0)
 117   1          tick_8ms = 1;
 118   1        if(t_count % 20 == 0)
 119   1          tick_20ms = 1;
 120   1        if(++t_count == 1000)
 121   1        {
 122   2          t_count = 0;
 123   2          if(active_flag)
 124   2          {
 125   3            if(++inactive_time == config.t_inactive_max)
 126   3            {
 127   4              active_flag = 0;
 128   4              inactive_time = 0;
 129   4              sleep_flag = 1;
 130   4            }
 131   3          }
 132   2          if(sleep_flag)
 133   2          {
 134   3            if(++sleep_time == config.t_sleep_max)
 135   3            {
 136   4              sleep_flag = 0;
 137   4              sleep_time = 0;
 138   4              powerdown_flag = 1;
 139   4              ON_CLOSE = 1;
 140   4            }
 141   3          }
 142   2        }
 143   1      }
 144          
 145          //void INT0_Isr() interrupt 0           //PCF8563中断
 146          //{
 147          //  PCF8563_int_flag = 1;
 148          //}
 149          void TM0_Isr() interrupt 1 using 1    //计数器0溢出中断
 150          {
 151   1        timer_cnt++;
 152   1      }
 153          void INT1_Isr() interrupt 2 using 1   //双击中断
 154          {
 155   1        action = 1;
 156   1        alarm_flag = 0;
 157   1        Bee();
 158   1        if(sleep_flag || powerdown_flag || alarm_flag)
 159   1          Trg = 0;
 160   1        else
 161   1          Trg = DOUBLE_TAP;
 162   1        if(active_flag && func_num == WATCH)
 163   1        {
 164   2          action = 0;
 165   2          active_flag = 0;
 166   2          inactive_time = 0;
 167   2          ScreenOnOff(OFF);
 168   2          sleep_flag = 1;
 169   2        }
 170   1      }
 171          void INT2_Isr() interrupt 10 using 1  //抬腕唤醒中断
 172          {
 173   1        action = 1;
 174   1        if(sleep_flag || powerdown_flag)
 175   1        {Trg = 0;}
 176   1        else 
 177   1        {Trg = AWT;}
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 4   

 178   1      }
 179          void INT3_Isr() interrupt 11          //按键2中断
 180          {
 181   1        action = 1;
 182   1      }
 183          void SensorInit(void)
 184          {
 185   1        unsigned char y = 0;
 186   1        unsigned int time_out = 700;
 187   1        unsigned char error_count = 0;
 188   1        if(BME280Init() == 0)
 189   1        {
 190   2          y += ShowString(0, y, "BME280 ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 191   2          error_count++;
 192   2        }
 193   1        if(HMC5883L_Init() == 0)
 194   1        {
 195   2          y += ShowString(0, y, "HMC5883L ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 196   2          error_count++;
 197   2        }
 198   1        if(LSM6DSMInit() == 0)
 199   1        {
 200   2          y += ShowString(0, y, "LSM6DSM ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 201   2          error_count++;
 202   2        }
 203   1        if(RDA5807MInit() == 0)
 204   1        {
 205   2          y += ShowString(0, y, "RDA5807M ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 206   2          error_count++;
 207   2        }
 208   1        if(error_count != 0)
 209   1        {
 210   2          while(Trg == 0)
 211   2          {
 212   3            Delay1ms(1);
 213   3            if(--time_out == 0)
 214   3              break;
 215   3          }
 216   2        }
 217   1      }
 218          
 219          
 220          
 221          
 222          
 223          
 224          /****
 225          //void  LED1_ON()
 226          //{
 227          //  P35 = 1;
 228          //}  
 229          //void  LED1_OFF()
 230          //{
 231          //  P35 = 0;
 232          //}
 233          
 234          void BreathingLamp(void)
 235          {
 236            unsigned int  i=0,  j=0,num=500;
 237            for(i=0;i<num;i++)
 238              {
 239                for(j=0;j<num;j++)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 5   

 240                {
 241                  if(i>j)
 242                  {
 243                    LED1_ON();
 244                    Delay1us(1);
 245                  }
 246                  else
 247                  {
 248                    LED1_OFF();
 249                    Delay1us(1);
 250                  } 
 251                }
 252              }
 253              Delay1us(1);
 254              for(i=0;i<num;i++)
 255              {
 256                for(j=0;j<num;j++)
 257                {
 258                  if(i>j)
 259                  {
 260                    LED1_OFF();
 261                    Delay1us(1);
 262                  }
 263                
 264                  else
 265                  {
 266                    LED1_ON();
 267                    Delay1us(1);
 268                    
 269                  } 
 270                }
 271              }
 272          }
 273          ********/
 274          
 275          void main()
 276          { 
 277   1        
 278   1        
 279   1        SysInit();            //系统初始化
 280   1        DisplayInit(&config); //显示初始化     
 281   1      //  PCF8563Init();        //实时时钟初始化        
 282   1      //  SensorInit();         //传感器初始化
 283   1        //ClearCache(main_cache); //清空主显存
 284   1        
 285   1        
 286   1        while(1)
 287   1        
 288   1        {
 289   2          FeedWatchDog();     //喂看门狗
 290   2      //    BreathingLamp();
 291   2       
 292   2      //*******
 293   2       
 294   2          if(func_num == WATCH)           //显示表盘
 295   2          {
 296   3            unsigned char x, n, m;
 297   3            unsigned char str[16];
 298   3            if(ON_OPEN)     //进入该功能时执行的内容
 299   3            {
 300   4              ON_OPEN = 0;
 301   4              if(func_index == FIRST_FUNC)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 6   

 302   4                ScreenPushAnimation(sub_cache1, DOWN);
 303   4              else if(func_index == LAST_FUNC)
 304   4                ScreenPushAnimation(sub_cache1, UP);
 305   4              func_index = WATCH;
 306   4            }
 307   3            if(ON_RETURN)   //返回该功能时执行的内容
 308   3            {
 309   4              ON_RETURN = 0;
 310   4            }
 311   3            
 312   3            if(tick_20ms)   //在功能里时，每20ms执行一次功能内容
 313   3            {
 314   4              tick_20ms = 0;
 315   4              //显示时间
 316   4              PCF8563ReadTime(&RTC);
 317   4              //printf("%d:%d:%d\n", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
 318   4              DisplayTime(RTC.hour, RTC.minute, RTC.second);
 319   4              //显示小图标
 320   4              ClearCacheArea(0, 0, 35, 8, main_cache);
 321   4              x = 0;
 322   4              BMPToCache(x, 0, 8, 8, BLUETOOTH_SMALL_ICON, main_cache, 0);
 323   4              x += 9;
 324   4              if(timer_on_flag)
 325   4              {
 326   5                BMPToCache(x, 0, 8, 8, TIMER_SMALL_ICON, main_cache, 0);
 327   5                x += 9;
 328   5              }
 329   4              if(config.alarm_mode != ALARM_DISABLE)
 330   4              {
 331   5                BMPToCache(x, 0, 8, 8, CLOCK_SMALL_ICON, main_cache, 0);
 332   5                x += 9;
 333   5              }
 334   4              if(radio_on_flag)
 335   4                BMPToCache(x, 0, 8, 8, RADIO_SMALL_ICON, main_cache, 0);
 336   4              //显示日期，星期
 337   4              ClearCacheArea(0, 7, 128, 8, main_cache);
 338   4              sprintf(str, "%d/%d/%d ", (int)RTC.year, (int)RTC.month, (int)RTC.day);
 339   4              strcat(str, WEEKDAY_IN_STR[RTC.weekday - 1]);
 340   4              ShowString(0, 7, str, main_cache, FONT6X8, NO_INVERSED, 0);
 341   4              //显示电量
 342   4              battery_life = GetBatteryLife();
 343   4              for(n = 0; n < 24; n++)
 344   4                str[n] = BATTERY_LIFE_ICON[n];
 345   4              m = 18 * battery_life;
 346   4              for(n = 2; n < 2 + m; n++)
 347   4                str[n] |= 0x3c;
 348   4              BMPToCache(104, 0, 24, 8, str, main_cache, 0);
 349   4              sprintf(str, "%3d%%", (int)(battery_life * 100));
 350   4              ShowString(78, 0, str, main_cache, FONT6X8, NO_INVERSED, 1);
 351   4            }
 352   3            
 353   3            if(Trg != 0)    //在该功能下对按键事件的处理
 354   3            {
 355   4              switch(Trg)
 356   4              {
 357   5                case KEY1:
 358   5                {
 359   6                  func_num = SUB_MENU;
 360   6                  ON_CLOSE = 1;
 361   6                  break;
 362   6                }
 363   5                case KEY2:
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 7   

 364   5                {
 365   6                  func_index = FIRST_FUNC;
 366   6                  func_num = MENU;
 367   6                  ON_CLOSE = 1;
 368   6                  break;
 369   6                } 
 370   5                case KEY3:
 371   5                {
 372   6                  func_index = LAST_FUNC;
 373   6                  func_num = MENU;
 374   6                  ON_CLOSE = 1;
 375   6                  break;
 376   6                }
 377   5                case KEY13:
 378   5                {
 379   6                  active_flag = 0;
 380   6                  sleep_flag = 0;
 381   6                  powerdown_flag = 0;
 382   6                  inactive_time = 0;
 383   6                  sleep_time = 0;
 384   6                  deep_powerdown_flag = 1;
 385   6                  ON_CLOSE = 1;
 386   6                  break;
 387   6                }
 388   5              }
 389   4              Trg = 0;
 390   4            }
 391   3            if(ON_CLOSE)    //关闭该功能时执行的内容
 392   3            {
 393   4              ON_CLOSE = 0;
 394   4              SaveScreen();
 395   4              ON_OPEN = 1;
 396   4            }
 397   3          }
 398   2          else if(func_num == MENU)       //主菜单    ok
 399   2              {
 400   3            if(ON_OPEN)
 401   3            {
 402   4              ClearCache(sub_cache2);
 403   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 404   4              if(func_index == FIRST_FUNC)
 405   4                ScreenPushAnimation(sub_cache2, UP);
 406   4              else
 407   4                ScreenPushAnimation(sub_cache2, DOWN);
 408   4              ON_OPEN = 0;
 409   4            }
 410   3            if(ON_RETURN)
 411   3            {
 412   4              ON_RETURN = 0;
 413   4              ClearCache(sub_cache2);
 414   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 415   4              ScreenPushAnimation(sub_cache2, RIGHT);
 416   4            }
 417   3            if(Trg != 0)
 418   3            {
 419   4              switch(Trg)
 420   4              {
 421   5                case KEY1:
 422   5                {
 423   6                  goto case_AWT;
 424   6                  break;
 425   6                }
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 8   

 426   5                case KEY2:
 427   5                {
 428   6                  if(++func_index > FUNC_NUM_MAX - 1)
 429   6                  {
 430   7                    func_index = LAST_FUNC;
 431   7                    func_num = WATCH;
 432   7                    ON_CLOSE = 1;
 433   7                  }
 434   6                  else
 435   6                  {
 436   7                    ClearCache(sub_cache2);
 437   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 438   7                    ScreenPushAnimation(sub_cache2, UP);
 439   7                  }
 440   6                  break;
 441   6                }
 442   5                case KEY3:
 443   5                {
 444   6                  if(--func_index < 0)
 445   6                  {
 446   7                    func_index = FIRST_FUNC;
 447   7                    func_num = WATCH;
 448   7                    ON_CLOSE = 1;
 449   7                  }
 450   6                  else
 451   6                  {
 452   7                    ClearCache(sub_cache2);
 453   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 454   7                    ScreenPushAnimation(sub_cache2, DOWN);
 455   7                  }
 456   6                  break;
 457   6                }
 458   5                case DOUBLE_TAP:
 459   5                {
 460   6                  func_num = func_index;
 461   6                  ON_CLOSE= 1;
 462   6                  break;
 463   6                }
 464   5                case AWT:
 465   5                {
 466   6                  case_AWT:
 467   6                  if(func_index <= (FUNC_NUM_MAX - func_index))
 468   6                  {
 469   7                    while(func_index > 0)
 470   7                    {
 471   8                      func_index --;
 472   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 473   8                      ScreenPushAnimation(sub_cache2, DOWN);
 474   8                    }
 475   7                  }
 476   6                  else
 477   6                  {
 478   7                    while(func_index < FUNC_NUM_MAX - 1)
 479   7                    {
 480   8                      func_index ++;
 481   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 482   8                      ScreenPushAnimation(sub_cache2, UP);
 483   8                    }
 484   7                  }
 485   6                  func_num = WATCH;
 486   6                  ON_CLOSE = 1;
 487   6                  break;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 9   

 488   6                }
 489   5              }
 490   4              Trg = 0;
 491   4            }
 492   3            if(ON_CLOSE)
 493   3            {
 494   4              ON_CLOSE = 0;
 495   4              ON_OPEN = 1;
 496   4            }
 497   3          }
 498   2          else if(func_num == SUB_MENU)   //次菜单    ok
 499   2          {
 500   3            
 501   3            char x, y;
 502   3            if(ON_OPEN)
 503   3            {
 504   4              ON_OPEN = 0;
 505   4              ClearCache(sub_cache2);
 506   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, sub_cache2, COVER);
 507   4              ScreenPushAnimation(sub_cache2, LEFT);
 508   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 509   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 510   4              LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 511   4            }
 512   3            if(tick_8ms)        //姿态解算频率：125hz
 513   3            {
 514   4              tick_8ms = 0;
 515   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
 516   4              IMUupdate(&LSM6DSM);
 517   4            }
 518   3            if(tick_20ms)
 519   3            {
 520   4              tick_20ms = 0;
 521   4              LSM6DSM.AngleX -= config.cal_anglex;  //倾角减去偏移
 522   4              LSM6DSM.AngleY -= config.cal_angley;  //倾角减去偏移
 523   4              LSM6DSM.AngleY -= 30;
 524   4              LSM6DSM.AngleX *= 3;      //调整一下横向灵敏度
 525   4              LSM6DSM.AngleY *= 2;      //调整一下纵向灵敏度
 526   4              if(LSM6DSM.AngleX > 63)   //对计算结果进行限幅
 527   4                LSM6DSM.AngleX = 63;
 528   4              else if(LSM6DSM.AngleX < -64)
 529   4                LSM6DSM.AngleX = -64;
 530   4              if(LSM6DSM.AngleY > 31)
 531   4                LSM6DSM.AngleY = 31;
 532   4              else if(LSM6DSM.AngleY < -31)
 533   4                LSM6DSM.AngleY = -31;
 534   4              x = 64 + LSM6DSM.AngleX;
 535   4              y = 32 + LSM6DSM.AngleY;
 536   4              if(x > 96)
 537   4                x = 96;
 538   4              if(y > 32)
 539   4                y = 32;
 540   4              ClearCache(main_cache);       //清空主缓存
 541   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, main_cache, COVER); //画菜单背景到主显存上
 542   4              DrawSelectionFrame(x, y);     //根据xy坐标画选择框到主显存上
 543   4              ScreenRefreshAll(main_cache); //将主显存刷新到OLED屏幕上
 544   4            }
 545   3            if(Cont == 0)
 546   3            {
 547   4              func_index = (enum function)((x + 16) / 32 + ((y + 16) / 32) * 4);
 548   4              func_num = func_index;
 549   4              ON_CLOSE = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 10  

 550   4            }
 551   3            if(ON_CLOSE)
 552   3            {
 553   4              ON_CLOSE = 0;
 554   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
 555   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 556   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 557   4              ON_OPEN = 1;
 558   4            }
 559   3          }
 560   2          else if(func_num == STOPWATCH)  //计时器    ok
 561   2          { 
 562   3            unsigned char t = 0, t_x = 0, t_y = 2;
 563   3            static int ms = 0, sec = 0, min = 0;
 564   3            static unsigned char n = 0, x = 0, y = 2;
 565   3            static unsigned char str1[10][11];
 566   3            unsigned char str2[10];
 567   3            if(ON_OPEN)
 568   3            {
 569   4              ON_OPEN = 0;
 570   4              ClearCache(sub_cache2);
 571   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 572   4              sec = ms / 100 % 60;
 573   4              min = sec / 60;
 574   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 575   4              ShowString(32, 0, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 576   4              if(n != 0)
 577   4              {
 578   5                for(t = 0; t < n; t++)
 579   5                {
 580   6                  if(t == 6)
 581   6                  {
 582   7                    t_x = 64;
 583   7                    t_y = 2;
 584   7                  }
 585   6                  ShowString(t_x, t_y++, str1[t], sub_cache2, FONT6X8, NO_INVERSED, 0);
 586   6                }
 587   5              }
 588   4              ScreenPushAnimation(sub_cache2, LEFT);
 589   4              ClearCache(sub_cache2);
 590   4            }
 591   3            if(tick_1ms)
 592   3            {
 593   4              tick_1ms = 0;
 594   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 595   4              sec = ms / 100;
 596   4              min = sec / 60;
 597   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 598   4              ShowString(32, 0, str2, main_cache, FONT8X16, NO_INVERSED, 1);
 599   4              sleep_time = 0;
 600   4            }
 601   3            if(Trg != 0)
 602   3            {
 603   4              switch(Trg)
 604   4              {
 605   5                case KEY1:
 606   5                {
 607   6                  ON_CLOSE = 1;
 608   6                  break;
 609   6                }
 610   5                case KEY2:
 611   5                {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 11  

 612   6                  if(TR0)
 613   6                  {
 614   7                    TR0 = 0;
 615   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, DISABLE_CLKOUT);
 616   7                    timer_on_flag = 0;
 617   7                  }
 618   6                  else
 619   6                  {
 620   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, ENABLE_CLKOUT);
 621   7                    TR0 = 1;
 622   7                    timer_on_flag = 1;
 623   7                  }
 624   6                  break;
 625   6                }
 626   5                case KEY3:
 627   5                {
 628   6                  timer_cnt = 0;
 629   6                  TH0 = 0;
 630   6                  TL0 = 0;
 631   6                  ms = 0;
 632   6                  sec = 0;
 633   6                  min = 0;
 634   6                  n = 0;
 635   6                  x = 0;
 636   6                  y = 2;
 637   6                  ClearCache(main_cache);
 638   6                  break;
 639   6                }
 640   5                case DOUBLE_TAP:
 641   5                {
 642   6                  if(n < 9 && timer_on_flag == 1)
 643   6                  {
 644   7                    if(n == 6)
 645   7                    {
 646   8                      x = 64;
 647   8                      y = 2;
 648   8                    }
 649   7                    sprintf(str1[n], "%d.%02d:%02d:%02d\0", (int)(n + 1), min, sec % 60, ms % 100);
 650   7                    ShowString(x + 0, y++, str1[n++], main_cache, FONT6X8, NO_INVERSED, 1);
 651   7                  }
 652   6                  break;
 653   6                }
 654   5              }
 655   4              Trg = 0;
 656   4            }
 657   3            if(ON_CLOSE)
 658   3            {
 659   4              ON_CLOSE = 0;
 660   4              func_num = MENU;
 661   4              ON_RETURN = 1;
 662   4            }
 663   3          }
 664   2          else if(func_num == PEDOMETER)  //计步器    ok
 665   2          {
 666   3            unsigned char n;
 667   3            unsigned int step;
 668   3            unsigned char buf[8];
 669   3            if(ON_OPEN)
 670   3            {
 671   4              ON_OPEN = 0;
 672   4      //        PCF8563ReadTime(&RTC);
 673   4              ClearCache(sub_cache2);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 12  

 674   4              ShowString(0, 0, "Today:    History:", sub_cache2, FONT6X8, NO_INVERSED, 0);
 675   4              step = LSM6DSMGetCurrentStep();
 676   4              sprintf(buf, "%d ", step);
 677   4              ShowString(0, 1, buf, sub_cache2, FONT8X16, NO_INVERSED, 0);    
 678   4              ScreenPushAnimation(sub_cache2, LEFT);
 679   4            }
 680   3            if(tick_20ms)
 681   3            {
 682   4              tick_20ms = 0;
 683   4              step = LSM6DSMGetCurrentStep();
 684   4              sprintf(buf, "%d ", step);
 685   4              ShowString(0, 1, buf, main_cache, FONT8X16, NO_INVERSED, 0);
 686   4              for(n = 0; n < 7; n++)
 687   4              {
 688   5                ShowString(64, n + 1, config.history_step[n], main_cache, FONT6X8, NO_INVERSED, 1);
 689   5              }
 690   4            }
 691   3            if(Trg != 0)
 692   3            {
 693   4              switch(Trg)
 694   4              {
 695   5                case KEY1:
 696   5                {
 697   6                  ON_CLOSE = 1;
 698   6                  break;
 699   6                }
 700   5                case KEY2:
 701   5                {
 702   6                  //LSM6DSMResetStepCounter();
 703   6                  break;
 704   6                } 
 705   5              }
 706   4              Trg = 0;
 707   4            }
 708   3            if(ON_CLOSE)
 709   3            {
 710   4              ON_CLOSE = 0;
 711   4              func_num = MENU;
 712   4              ON_RETURN = 1;
 713   4            }
 714   3          }
 715   2          else if(func_num == THPMETER)   //温湿度计  ok
 716   2          {   
 717   3            float altitude;
 718   3            unsigned char str1[10] = {0};
 719   3            if(ON_OPEN)
 720   3            {
 721   4              ON_OPEN = 0;
 722   4              ClearCache(sub_cache2);
 723   4              BMPToCache(0, 0, 48, 64, T_H_P_A, sub_cache2, 0);
 724   4              sprintf(str1, "%.1f", BME280.temperature);
 725   4              ShowString(48, 0, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 726   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, sub_cache2, 0);
 727   4              sprintf(str1, "%.1f%%", BME280.humidity);
 728   4              ShowString(48, 2, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 729   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 730   4              ShowString(48, 4, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 731   4              ScreenPushAnimation(sub_cache2, LEFT);
 732   4              BME280ContinuousMeasurement(MS_125);    //连续测量模式，测量间隔125ms
 733   4            }
 734   3            if(tick_20ms)
 735   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 13  

 736   4              tick_20ms = 0;
 737   4              BME280GetSensorData(&BME280);         //读BME280测量数据并显示
 738   4              altitude = 44330.77 * (1 - pow((BME280.pressure / 101500), 0.190263));
 739   4              ClearCache(main_cache);
 740   4              BMPToCache(0, 0, 48, 64, T_H_P_A, main_cache, 0);
 741   4              sprintf(str1, "%.1f", BME280.temperature);
 742   4              ShowString(48, 0, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 743   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, main_cache, 0);
 744   4              sprintf(str1, "%.1f %%", BME280.humidity);
 745   4              ShowString(48, 2, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 746   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 747   4              ShowString(48, 4, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 748   4              sprintf(str1, "%d m", (int)altitude);
 749   4              ShowString(48, 6, str1, main_cache, FONT8X16, NO_INVERSED, 1);
 750   4            }
 751   3            if(Trg == KEY1)
 752   3            {
 753   4              Trg = 0;
 754   4              ON_CLOSE = 1;
 755   4            }
 756   3            if(ON_CLOSE)
 757   3            {
 758   4              ON_CLOSE = 0;
 759   4              BME280SetMode(SLEEP_MODE);
 760   4              func_num = MENU;
 761   4              ON_RETURN = 1;
 762   4            }
 763   3          }
 764   2          else if(func_num == RADIO)      //收音机    ok
 765   2          {
 766   3            static unsigned char index = 0;
 767   3            static bit searching_flag = 0;
 768   3            static unsigned char search_direction;
 769   3            float temp;
 770   3            unsigned char str2[16];
 771   3            if(ON_OPEN)
 772   3            {
 773   4              ON_OPEN = 0;
 774   4              ClearCache(sub_cache2);
 775   4              ShowString(80, 0, "volume", sub_cache2, FONT8X16, NO_INVERSED, 0);
 776   4              sprintf(str2,"%.1fMHz",config.radio_channel);
 777   4              ShowString(40, 3, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 778   4              ShowString(0, 6, "tune", sub_cache2, FONT8X16, NO_INVERSED, 0);
 779   4              ShowString(80, 6, "search", sub_cache2, FONT8X16, NO_INVERSED, 0);
 780   4              ShowString(0, 0, "close", main_cache, FONT8X16, NO_INVERSED, 0);
 781   4              ScreenPushAnimation(sub_cache2, LEFT);
 782   4              if(radio_on_flag != 1)
 783   4              {
 784   5                RDA5807MPowerUp();
 785   5                RDA5807MSetFq(config.radio_channel);
 786   5                if(config.radio_volume > 0x0f)
 787   5                  config.radio_volume = 0;
 788   5                RDA5807MSetVOLUME(config.radio_volume);
 789   5                radio_on_flag = 1;
 790   5              }
 791   4            }
 792   3            if(tick_20ms)
 793   3            {
 794   4              tick_20ms = 0;
 795   4              ClearCache(main_cache);
 796   4              ShowString(80, 0, "volume", main_cache, FONT8X16, index == 0?INVERSED:NO_INVERSED, 0);
 797   4              sprintf(str2,"%.1fMHz", config.radio_channel);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 14  

 798   4              ShowString(40, 3, str2, main_cache, FONT8X16, NO_INVERSED, 0);
 799   4              if(searching_flag)
 800   4              {
 801   5                temp = RDA5807MSEEK(search_direction);
 802   5                if(temp == 0)
 803   5                  ShowString(28, 5, "searching...", main_cache, FONT6X8, NO_INVERSED, 0);
 804   5                else
 805   5                {
 806   6                  config.radio_channel = temp;
 807   6                  searching_flag = 0;
 808   6                }
 809   5              }
 810   4              ShowString(80, 6, "search", main_cache, FONT8X16, index == 1?INVERSED:NO_INVERSED, 0);
 811   4              ShowString(0, 6, "tune", main_cache, FONT8X16, index == 2?INVERSED:NO_INVERSED, 0);
 812   4              ShowString(0, 0, "close", main_cache, FONT8X16, index == 3?INVERSED:NO_INVERSED, 1);
 813   4            }
 814   3            if(Trg != 0)
 815   3            {
 816   4              switch(Trg)
 817   4              {
 818   5                case KEY1:
 819   5                {
 820   6                  ON_CLOSE = 1;
 821   6                  break;
 822   6                }
 823   5                case KEY2:
 824   5                {
 825   6                  if(index == 0)
 826   6                  {
 827   7                    if(++config.radio_volume > 0x0f)
 828   7                      config.radio_volume = 0x0f;
 829   7                    RDA5807MSetVOLUME(config.radio_volume);
 830   7                  }
 831   6                  else if(index == 1)
 832   6                  {
 833   7                    search_direction = UPWARD;
 834   7                    searching_flag = 1;
 835   7                  }
 836   6                  else if(index == 2)
 837   6                  {
 838   7                    config.radio_channel += 0.1;
 839   7                    if(config.radio_channel > 108)
 840   7                      config.radio_channel = 87;
 841   7                    RDA5807MSetFq(config.radio_channel);
 842   7                  }
 843   6                  break;
 844   6                } 
 845   5                case KEY3:
 846   5                {
 847   6                  if(index == 0)
 848   6                  {
 849   7                    if(--config.radio_volume == 255)
 850   7                      config.radio_volume = 0;
 851   7                    RDA5807MSetVOLUME(config.radio_volume);
 852   7                  }
 853   6                  else if(index == 1)
 854   6                  {
 855   7                    search_direction = DOWNWARD;
 856   7                    searching_flag = 1;
 857   7                  }
 858   6                  else if(index == 2)
 859   6                  {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 15  

 860   7                    config.radio_channel -= 0.1;
 861   7                    if(config.radio_channel < 87)
 862   7                      config.radio_channel = 108;
 863   7                    RDA5807MSetFq(config.radio_channel);
 864   7                  }
 865   6                  break;
 866   6                }
 867   5                case DOUBLE_TAP:
 868   5                {
 869   6                  if(++index == 4)
 870   6                    index = 0;
 871   6                  break;
 872   6                }
 873   5              }
 874   4              Trg = 0;
 875   4            }
 876   3            if(ON_CLOSE)
 877   3            {
 878   4              ON_CLOSE = 0;
 879   4              if(powerdown_flag == 0 && index == 3)
 880   4              {
 881   5                RDA5807MPowerDown();
 882   5                radio_on_flag = 0;
 883   5                index = 0;  
 884   5                EEPROMWriteConfiguration(&config);
 885   5              }
 886   4              func_num = MENU;
 887   4              ON_RETURN = 1;
 888   4            }
 889   3          }
 890   2          else if(func_num == COMPASS)    //磁力计    ok
 891   2          {
 892   3            //显示角度和指针
 893   3            static char mode = 0;
 894   3            int magnet_data[3] = {0};
 895   3            unsigned char str3[16];
 896   3            if(mode == 0)     
 897   3            {
 898   4              unsigned char n;
 899   4              int angle_from_north;
 900   4              if(ON_OPEN)
 901   4              {
 902   5                ON_OPEN = 0;
 903   5                ClearCache(sub_cache2);
 904   5                sprintf(str3, "%d  ", angle_from_north);
 905   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 906   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 907   5                ScreenPushAnimation(sub_cache2, LEFT);
 908   5                //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 909   5                LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 910   5                LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 911   5                HMC5883L_Set_Mode(0);                   //设置连续测量模式
 912   5                HMC5883L_Set_Calibration_Value(config.cal_magnet_x0, config.cal_magnet_y0, config.cal_magnet_z0, 
 913   5                                              config.cal_magnet_ab, config.cal_magnet_ac);  //设置校准参数
 914   5              }
 915   4              if(ON_RETURN)
 916   4              {
 917   5                ON_RETURN = 0;
 918   5                ClearCache(sub_cache2);
 919   5                BMPToCache(16, 2, 32, 16, NESW[n], sub_cache2, COVER);
 920   5                sprintf(str3, "%d  ", angle_from_north);
 921   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, COVER);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 16  

 922   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 923   5                ScreenPushAnimation(sub_cache2, RIGHT);
 924   5              }
 925   4              if(tick_8ms)
 926   4              {
 927   5                tick_8ms = 0; 
 928   5                LSM6DSMReadGYRAndACC(&LSM6DSM);
 929   5                IMUupdate(&LSM6DSM);
 930   5              }
 931   4              if(tick_20ms)
 932   4              {
 933   5                tick_20ms = 0;
 934   5                Read_HMC5883L(magnet_data);
 935   5                angle_from_north = (int)HMC5883L_Get_AngleXY(magnet_data, (int)LSM6DSM.AngleX, (int)LSM6DSM.AngleY);
 936   5                angle_from_north += 90;
 937   5                if(angle_from_north >= 360)
 938   5                  angle_from_north -= 360;
 939   5                n = (angle_from_north + 22.5) / 45;
 940   5                if(n == 8)
 941   5                  n = 0;
 942   5                BMPToCache(16, 2, 32, 16, NESW[n], main_cache, 0);
 943   5                sprintf(str3, "%d  ", angle_from_north);
 944   5                ShowString(24, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 945   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, main_cache, 0);
 946   5                angle_from_north -= 90;
 947   5                if(angle_from_north < 0)
 948   5                  angle_from_north += 360;
 949   5                DrawArm(95, 31, 18, angle_from_north);
 950   5                ScreenRefreshAll(main_cache);
 951   5              }
 952   4              if(Trg != 0)
 953   4              {
 954   5                switch(Trg)
 955   5                {
 956   6                  case KEY1:
 957   6                  {
 958   7                    ON_CLOSE = 1;
 959   7                    break;
 960   7                  }
 961   6                  case KEY2:
 962   6                  {
 963   7                    mode = 1;
 964   7                    ON_OPEN = 1;
 965   7                    break;
 966   7                  } 
 967   6                }
 968   5                Trg = 0;
 969   5              }
 970   4              if(ON_CLOSE)
 971   4              {
 972   5                ON_CLOSE = 0;
 973   5                HMC5883L_Set_Mode(2);  //设置睡眠模式
 974   5                LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 975   5                LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 976   5                func_num = MENU;
 977   5                ON_RETURN = 1;
 978   5              }
 979   4            }
 980   3            else if(mode == 1)  //磁力计椭球校准
 981   3            {
 982   4              static int data_cnt = 0;
 983   4              if(ON_OPEN)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 17  

 984   4              {
 985   5                ON_OPEN = 0;
 986   5                ClearCache(sub_cache2);
 987   5                sprintf(str3, "x:%d", magnet_data[0]);
 988   5                ShowString(0, 0, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 989   5                sprintf(str3, "y:%d", magnet_data[1]);
 990   5                ShowString(0, 2, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 991   5                sprintf(str3, "z:%d", magnet_data[2]);
 992   5                ShowString(0, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 993   5                ScreenPushAnimation(sub_cache2, LEFT);
 994   5                ResetMatrix();
 995   5                HMC5883L_Set_Calibration_Value(0, 0, 0, 1, 1);  //清除校准参数
 996   5              }
 997   4              if(tick_20ms)
 998   4              {
 999   5                tick_20ms = 0;
1000   5                Read_HMC5883L(magnet_data);
1001   5                CalcData_Input(magnet_data[0], magnet_data[1], magnet_data[2]);
1002   5                sprintf(str3, "x:%d", magnet_data[0]);
1003   5                ShowString(0, 0, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1004   5                sprintf(str3, "y:%d", magnet_data[1]);
1005   5                ShowString(0, 2, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1006   5                sprintf(str3, "z:%d", magnet_data[2]);
1007   5                ShowString(0, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1008   5                sprintf(str3, "data_cnt:%d", data_cnt);
1009   5                ShowString(0, 6, str3, main_cache, FONT8X16, NO_INVERSED, 1);
1010   5                if(++data_cnt == 5000)
1011   5                {
1012   6                  ON_CLOSE = 1;
1013   6                  Bee();
1014   6                }
1015   5              }
1016   4              if(Trg == KEY1)
1017   4              {
1018   5                Trg = 0;
1019   5                ON_CLOSE = 1;
1020   5              }
1021   4              if(ON_CLOSE)
1022   4              {
1023   5                ON_CLOSE = 0;
1024   5                Ellipsoid_fitting_Process(&magnet_cal_data);    //椭球校准算法
1025   5                HMC5883L_Set_Calibration_Value(magnet_cal_data.X0, magnet_cal_data.Y0, magnet_cal_data.Z0, 
1026   5                                              magnet_cal_data.A / magnet_cal_data.B, 
1027   5                                              magnet_cal_data.A / magnet_cal_data.C);//设置校准参数
1028   5                config.cal_magnet_x0 = magnet_cal_data.X0;
1029   5                config.cal_magnet_y0 = magnet_cal_data.Y0;
1030   5                config.cal_magnet_z0 = magnet_cal_data.Z0;
1031   5                config.cal_magnet_ab = magnet_cal_data.A / magnet_cal_data.B;
1032   5                config.cal_magnet_ac = magnet_cal_data.A / magnet_cal_data.C;
1033   5                EEPROMWriteConfiguration(&config);
1034   5                data_cnt = 0;
1035   5                mode = 0;
1036   5                ON_RETURN = 1;
1037   5              }
1038   4            }
1039   3          }
1040   2          
1041   2          else if(func_num == BLUETOOTH)  //蓝牙    ok
1042   2          {
1043   3            unsigned char bluetooth_data[128] = "\0";
1044   3            static bit bluetooth_init = 0;
1045   3            static unsigned char y = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 18  

1046   3            static unsigned char connected = 0;
1047   3            if(ON_OPEN)
1048   3            {
1049   4              ON_OPEN = 0;
1050   4              ClearCache(sub_cache2);
1051   4              ScreenPushAnimation(sub_cache2, LEFT);
1052   4              if(bluetooth_init == 0)
1053   4              {
1054   5                while(PW02Init() == 0);       //蓝牙初始化
1055   5                bluetooth_init = 1;
1056   5              }
1057   4              PW02SetMode(1);
1058   4              y = 0;
1059   4            }
1060   3            if(tick_20ms)
1061   3            {
1062   4              tick_20ms = 0;
1063   4              if(connected == 0)
1064   4              {
1065   5                if(PW02CheckConnection())
1066   5                {
1067   6                  connected = 1;
1068   6                  y = 6;
1069   6                }
1070   5              }
1071   4              if((connected == 1) && PW02GetRxData(bluetooth_data))
1072   4                y += ShowString(0, y, bluetooth_data, main_cache, FONT8X16, NO_INVERSED, 1);
1073   4            }
1074   3            if(Trg != 0)
1075   3            {
1076   4              switch(Trg)
1077   4              {
1078   5                case KEY1:
1079   5                {
1080   6                  ON_CLOSE = 1;
1081   6                  break;
1082   6                }
1083   5                case KEY2:
1084   5                {
1085   6                  ClearCache(main_cache);
1086   6                  y = 0;
1087   6                  y += ShowString(0, y, "Screen cleaned", main_cache, FONT8X16, NO_INVERSED, 1);
1088   6                  break;
1089   6                } 
1090   5              }
1091   4              Trg = 0;
1092   4            }
1093   3            if(ON_CLOSE)
1094   3            {
1095   4              ON_CLOSE = 0;
1096   4              if(connected == 0)
1097   4                while(PW02ExitATMode() == 0);
1098   4              else
1099   4                connected = 0;
1100   4              PW02SetMode(0);
1101   4              func_num = MENU;
1102   4              ON_RETURN = 1;
1103   4            }
1104   3          }
1105   2          else if(func_num == SPIRIT_LEVEL) //水平仪  ok
1106   2          {
1107   3            int x, y;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 19  

1108   3            unsigned char str[16];
1109   3            if(ON_OPEN)
1110   3            {
1111   4              ON_OPEN = 0;
1112   4              ClearCache(sub_cache2);
1113   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1114   4              ShowString(0, 0, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1115   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1116   4              ShowString(0, 1, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1117   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1118   4              ShowString(0, 2, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1119   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, sub_cache2, 0);
1120   4              ScreenPushAnimation(sub_cache2, LEFT);
1121   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
1122   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
1123   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
1124   4            }
1125   3            if(tick_8ms)
1126   3            {
1127   4              tick_8ms = 0;
1128   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
1129   4              IMUupdate(&LSM6DSM);
1130   4            }
1131   3            if(tick_20ms)
1132   3            {
1133   4              tick_20ms = 0;
1134   4              ClearCache(main_cache);
1135   4              LSM6DSM.AngleX -= config.cal_anglex;
1136   4              LSM6DSM.AngleY -= config.cal_angley;
1137   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1138   4              ShowString(0, 0, str, main_cache, FONT6X8, NO_INVERSED, 0);
1139   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1140   4              ShowString(0, 1, str, main_cache, FONT6X8, NO_INVERSED, 0);
1141   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1142   4              ShowString(0, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
1143   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, main_cache, 0);
1144   4              x = 64 + LSM6DSM.AngleX;
1145   4              y = 32 + LSM6DSM.AngleY;
1146   4              if(x > 126)
1147   4                x = 126;
1148   4              else if(x < 1)
1149   4                x = 1;
1150   4              if(y > 62)
1151   4                y = 62;
1152   4              else if(y < 1)
1153   4                y = 1;
1154   4              if(x ==63 && y == 32)
1155   4                ScreenSetInverse(config.screen_inverse == NO_INVERSED?INVERSED:NO_INVERSED);
1156   4              else
1157   4                ScreenSetInverse(config.screen_inverse);
1158   4              DrawDot(x, y);
1159   4              DrawDot(x - 1, y);
1160   4              DrawDot(x + 1, y);
1161   4              DrawDot(x, y + 1);
1162   4              DrawDot(x, y - 1);
1163   4              ScreenRefreshAll(main_cache);
1164   4            }
1165   3            if(Trg != 0)
1166   3            {
1167   4              switch(Trg)
1168   4              {
1169   5                case KEY1:
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 20  

1170   5                {
1171   6                  ON_CLOSE = 1;
1172   6                  break;
1173   6                }
1174   5                case KEY2:
1175   5                {
1176   6                  config.cal_anglex = LSM6DSM.AngleX;
1177   6                  config.cal_angley = LSM6DSM.AngleY;
1178   6                  break;
1179   6                } 
1180   5                case KEY3:
1181   5                {
1182   6                  break;
1183   6                }
1184   5              }
1185   4              Trg = 0;
1186   4            }
1187   3            if(ON_CLOSE)
1188   3            {
1189   4              ON_CLOSE = 0;
1190   4              ScreenSetInverse(config.screen_inverse);
1191   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
1192   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
1193   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
1194   4              EEPROMWriteConfiguration(&config);
1195   4              func_num = MENU;
1196   4              ON_RETURN = 1;
1197   4            }
1198   3          }
1199   2        
1200   2          else if(func_num == FLASH_LIGHT)  //手电筒  ok
1201   2          {
1202   3            static char flash_mode = 0;
1203   3            static char flash_t_cnt = 0;
1204   3            static bit k = 0;
1205   3            if(ON_OPEN)
1206   3            {
1207   4              ON_OPEN = 0;
1208   4              ClearCache(sub_cache2);
1209   4              ShowString(28, 3, "Torch ON", sub_cache2, FONT8X16, NO_INVERSED, 0);
1210   4              ScreenPushAnimation(sub_cache2, LEFT);
1211   4              ScreenSetInverse(INVERSED);
1212   4              ScreenSetBrightness(255);
1213   4              LED(ON);
1214   4            }
1215   3            if(tick_20ms)
1216   3            {
1217   4              tick_20ms = 0;
1218   4              inactive_time = 0;
1219   4              if(flash_mode)
1220   4              {
1221   5                if(flash_t_cnt++ == 5)
1222   5                {
1223   6                  flash_t_cnt = 0;
1224   6                  k = ~k;
1225   6                  LED(k);
1226   6                }
1227   5              }
1228   4            }
1229   3            if(Trg != 0)
1230   3            {
1231   4              switch(Trg)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 21  

1232   4              {
1233   5                case KEY1:
1234   5                {
1235   6                  ON_CLOSE = 1;
1236   6                  break;
1237   6                }
1238   5                case KEY2:
1239   5                {
1240   6                  if(flash_mode == 0)
1241   6                    flash_mode = 1;
1242   6                  else
1243   6                  {
1244   7                    flash_mode = 0;
1245   7                    LED(ON);
1246   7                  }
1247   6                  break;
1248   6                }
1249   5              }
1250   4              Trg = 0;
1251   4            }
1252   3            if(ON_CLOSE)
1253   3            {
1254   4              ON_CLOSE = 0;
1255   4              ScreenSetBrightness(config.screen_brightness);
1256   4              ScreenSetInverse(config.screen_inverse);
1257   4              LED(OFF);
1258   4              flash_mode = 0;
1259   4              flash_t_cnt = 0;
1260   4              func_num = MENU;
1261   4              ON_RETURN = 1;  
1262   4            }
1263   3          }
1264   2          else if(func_num == SETTING)      //设置    ok
1265   2          {
1266   3            static char index = 0;    //菜单的索引(0~MENU_MAX_ROW-1)
1267   3            static char pointer = 0;  //当前所选项在屏幕上的位置(0~3)
1268   3            static char mode = -1;
1269   3            unsigned char str[21];
1270   3            unsigned char *cache;
1271   3            if(mode == -1)  //设置菜单界面
1272   3            {
1273   4              if(ON_OPEN | ON_RETURN)
1274   4              {
1275   5                cache = &sub_cache2;
1276   5              }
1277   4              else
1278   4                cache = &main_cache;
1279   4              if(tick_20ms)
1280   4              {
1281   5                tick_20ms = 0;
1282   5                ClearCache(cache);
1283   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1284   5                ShowString(16, 0, SETTING_MENU[index - pointer], cache, FONT8X16, NO_INVERSED, 0);
1285   5                ShowString(16, 2, SETTING_MENU[index - pointer + 1], cache, FONT8X16, NO_INVERSED, 0);
1286   5                ShowString(16, 4, SETTING_MENU[index - pointer + 2], cache, FONT8X16, NO_INVERSED, 0);
1287   5                ShowString(16, 6, SETTING_MENU[index - pointer + 3], cache, FONT8X16, NO_INVERSED, 1);
1288   5                if(ON_OPEN)
1289   5                {
1290   6                  ScreenPushAnimation(sub_cache2, LEFT);
1291   6                  ON_OPEN = 0;
1292   6                }
1293   5                else if(ON_RETURN)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 22  

1294   5                {
1295   6                  ScreenPushAnimation(sub_cache2, RIGHT);
1296   6                  ON_RETURN = 0;
1297   6                } 
1298   5              }
1299   4              if(Trg != 0)
1300   4              {
1301   5                switch(Trg)
1302   5                {
1303   6                  case KEY1:
1304   6                  {
1305   7                    ON_CLOSE = 1;
1306   7                    break;
1307   7                  }
1308   6                  case KEY2:
1309   6                  {
1310   7                    index--;
1311   7                    if(--pointer < 0)
1312   7                    {
1313   8                      pointer = 0;
1314   8                      if(index != -1)
1315   8                      {
1316   9                        ClearCache(sub_cache2);
1317   9                        ShowString(16, 6, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1318   9                        ScreeRollDown(sub_cache2, 16);
1319   9                      }
1320   8                      else
1321   8                        index = 0;
1322   8                    }
1323   7                    break;
1324   7                  } 
1325   6                  case KEY3:
1326   6                  {
1327   7                    index++;
1328   7                    if(++pointer == 4)
1329   7                    {
1330   8                      pointer = 3;
1331   8                      if(index != MENU_MAX_ROW)
1332   8                      {
1333   9                        ClearCache(sub_cache2);
1334   9                        ShowString(16, 0, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1335   9                        ScreeRollUp(sub_cache2, 16);
1336   9                      }
1337   8                      else
1338   8                        index = MENU_MAX_ROW - 1;
1339   8                    }
1340   7                    break;
1341   7                  }
1342   6                  case DOUBLE_TAP:
1343   6                  {
1344   7                    mode = index;
1345   7                    ON_OPEN = 1;
1346   7                    break;
1347   7                  }
1348   6                }
1349   5                Trg = 0;
1350   5              }
1351   4              if(ON_CLOSE)
1352   4              {
1353   5                ON_CLOSE = 0;
1354   5                func_num = MENU;
1355   5                ON_RETURN = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 23  

1356   5              }
1357   4            }
1358   3            else if(mode == 0)  //设置时间
1359   3            {
1360   4              static char pointer = 0;
1361   4              static char set_index = 0;
1362   4              if(ON_OPEN)
1363   4              {
1364   5                ON_OPEN = 0;
1365   5                PCF8563ReadTime(&RTC);
1366   5                ClearCache(sub_cache2);
1367   5                ShowString(0, 0, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1368   5                sprintf(str, "%2d:%2d:%2d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1369   5                ShowString(16, 0, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1370   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1371   5                ShowString(16, 2, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1372   5                ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], sub_cache2, FONT6X8, NO_INVERSED, 0);
1373   5                ScreenPushAnimation(sub_cache2, LEFT);
1374   5              }
1375   4              if(tick_20ms)
1376   4              {
1377   5                tick_20ms = 0;
1378   5                ClearCache(main_cache);
1379   5                if(set_index == 0)
1380   5                  PCF8563ReadTime(&RTC);
1381   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1382   5                sprintf(str, "%02d:%02d:%02d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1383   5                ShowString(16, 0, str, main_cache, FONT8X16, NO_INVERSED, 0);
1384   5                if(pointer == 0 && set_index != 0)
1385   5                {
1386   6                  if(set_index == 1)
1387   6                  {
1388   7                    sprintf(str, "%02d", (int)RTC.hour);
1389   7                    ShowString(16, 0, str, main_cache, FONT8X16, INVERSED, 0);
1390   7                  }
1391   6                  else if(set_index == 2)
1392   6                  {
1393   7                    sprintf(str, "%02d", (int)RTC.minute);
1394   7                    ShowString(40, 0, str, main_cache, FONT8X16, INVERSED, 0);
1395   7                  }
1396   6                  else if(set_index == 3)
1397   6                  {
1398   7                    sprintf(str, "%02d", (int)RTC.second);
1399   7                    ShowString(64, 0, str, main_cache, FONT8X16, INVERSED, 0);
1400   7                  }
1401   6                }
1402   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1403   5                ShowString(16, 2, str, main_cache, FONT8X16, NO_INVERSED, 0);
1404   5                if(pointer == 1 && set_index != 0)
1405   5                {
1406   6                  if(set_index == 1)
1407   6                  {
1408   7                    sprintf(str, "%4d", (int)RTC.year);
1409   7                    ShowString(16, 2, str, main_cache, FONT8X16, INVERSED, 0);
1410   7                  }
1411   6                  else if(set_index == 2)
1412   6                  {
1413   7                    sprintf(str, "%2d", (int)RTC.month);
1414   7                    ShowString(56, 2, str, main_cache, FONT8X16, INVERSED, 0);
1415   7                  }
1416   6                  else if(set_index == 3)
1417   6                  {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 24  

1418   7                    sprintf(str, "%2d", (int)RTC.day);
1419   7                    ShowString(80, 2, str, main_cache, FONT8X16, INVERSED, 0);
1420   7                  }
1421   6                }
1422   5                if(pointer == 2 && set_index != 0)
1423   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, INVERSED, 1);
1424   5                else
1425   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, NO_INVERSED, 1);
1426   5              }
1427   4              if(Trg != 0)
1428   4              {
1429   5                switch(Trg)
1430   5                {
1431   6                  case KEY1:
1432   6                  {
1433   7                    if(set_index != 0)
1434   7                    {
1435   8                      set_index = 0;
1436   8                      PCF8563WriteTime(RTC.hour, RTC.minute, RTC.second);
1437   8                      PCF8563WriteDate(RTC.year, RTC.month, RTC.day, RTC.weekday);
1438   8                    }
1439   7                    else
1440   7                      ON_CLOSE = 1;
1441   7                    break;
1442   7                  }
1443   6                  case KEY2:
1444   6                  {
1445   7                    if(set_index == 0)
1446   7                    {
1447   8                      if(--pointer < 0)
1448   8                        pointer = 2;
1449   8                    }
1450   7                    else
1451   7                    {
1452   8                      if(pointer == 0)
1453   8                      {
1454   9                        if(set_index == 1)
1455   9                        {
1456  10                          if(++RTC.hour == 24)
1457  10                            RTC.hour = 0;
1458  10                        }
1459   9                        else if(set_index == 2)
1460   9                        {
1461  10                          if(++RTC.minute == 60)
1462  10                            RTC.minute = 0;
1463  10                        }
1464   9                        else if(set_index == 3)
1465   9                        {
1466  10                          if(++RTC.second == 60)
1467  10                            RTC.second = 0;
1468  10                        }
1469   9                      }
1470   8                      else if(pointer == 1)
1471   8                      {
1472   9                        if(set_index == 1)
1473   9                        {
1474  10                          if(++RTC.year == 2100)
1475  10                            RTC.year = 2000;
1476  10                        }
1477   9                        else if(set_index == 2)
1478   9                        {
1479  10                          if(++RTC.month == 13)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 25  

1480  10                            RTC.month = 1;
1481  10                        }
1482   9                        else if(set_index == 3)
1483   9                        {
1484  10                          if(++RTC.day == 32)
1485  10                            RTC.day = 1;
1486  10                        }
1487   9                      }
1488   8                      else if(pointer == 2)
1489   8                      {
1490   9                        if(set_index == 1)
1491   9                          if(++RTC.weekday == 8)
1492   9                            RTC.weekday = 1;
1493   9                      }
1494   8                    }
1495   7                    break;
1496   7                  }
1497   6                  case KEY3:
1498   6                  {
1499   7                    if(set_index == 0)
1500   7                    {
1501   8                      if(++pointer == 3)
1502   8                        pointer = 0;
1503   8                    }
1504   7                    else
1505   7                    {
1506   8                      if(pointer == 0)
1507   8                      {
1508   9                        if(set_index == 1)
1509   9                        {
1510  10                          if(--RTC.hour == 255)
1511  10                            RTC.hour = 23;
1512  10                        }
1513   9                        else if(set_index == 2)
1514   9                        {
1515  10                          if(--RTC.minute == 255)
1516  10                            RTC.minute = 59;
1517  10                        }
1518   9                        else if(set_index == 3)
1519   9                        {
1520  10                          if(--RTC.second == 255)
1521  10                            RTC.second = 59;
1522  10                        }
1523   9                      }
1524   8                      else if(pointer == 1)
1525   8                      {
1526   9                        if(set_index == 1)
1527   9                        {
1528  10                          if(--RTC.year == 1999)
1529  10                            RTC.year = 2099;
1530  10                        }
1531   9                        else if(set_index == 2)
1532   9                        {
1533  10                          if(--RTC.month == 255)
1534  10                            RTC.month = 12;
1535  10                        }
1536   9                        else if(set_index == 3)
1537   9                        {
1538  10                          if(--RTC.day == 255)
1539  10                            RTC.day = 31;
1540  10                        }
1541   9                      }
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 26  

1542   8                      else if(pointer == 2)
1543   8                      {
1544   9                        if(set_index == 1)
1545   9                          if(--RTC.weekday == 0)
1546   9                            RTC.weekday = 7;
1547   9                      }
1548   8                    }
1549   7                    break;
1550   7                  }
1551   6                  case DOUBLE_TAP:
1552   6                  {
1553   7                    if(pointer < 2)
1554   7                    {
1555   8                      if(++set_index == 4)
1556   8                        set_index = 1;
1557   8                    }
1558   7                    else if(pointer == 2)
1559   7                    {
1560   8                      if(++set_index == 2)
1561   8                        set_index = 1;
1562   8                    }
1563   7                    break;
1564   7                  }
1565   6                }
1566   5                Trg = 0;
1567   5              }
1568   4              if(ON_CLOSE)
1569   4              {
1570   5                ON_CLOSE = 0;
1571   5                set_index = 0;
1572   5                pointer = 0;
1573   5                mode = -1;
1574   5                ON_RETURN = 1;
1575   5              }
1576   4            }
1577   3            else if(mode == 1)  //设置闹钟
1578   3            {
1579   4              static unsigned char pointer = 0;
1580   4              static unsigned char set_index = 0;
1581   4              if(ON_OPEN)
1582   4              {
1583   5                ON_OPEN = 0;
1584   5                ClearCache(sub_cache2);
1585   5                ShowString(16, 0, "Alarm:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1586   5                ShowString(0, 1, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1587   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1588   5                ShowString(16, 1, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1589   5                ShowString(16, 3, "Mode:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1590   5                ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], sub_cache2, FONT8X16, NO_INVERSED, 0);
1591   5                ScreenPushAnimation(sub_cache2, LEFT);
1592   5              }
1593   4              if(tick_20ms)
1594   4              {
1595   5                tick_20ms = 0;
1596   5                ClearCache(main_cache);
1597   5                ShowString(0, 1 + pointer * 3, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1598   5                ShowString(16, 0, "Alarm:", main_cache, FONT6X8, NO_INVERSED, 0);
1599   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1600   5                ShowString(16, 1, str, main_cache, FONT8X16, NO_INVERSED, 0);
1601   5                if(pointer == 0 && set_index != 0)
1602   5                {
1603   6                  if(set_index == 1)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 27  

1604   6                  {
1605   7                    sprintf(str, "%02d", (int)config.alarm_hour);
1606   7                    ShowString(16, 1, str, main_cache, FONT8X16, INVERSED, 0);
1607   7                  }
1608   6                  else if(set_index == 2)
1609   6                  {
1610   7                    sprintf(str, "%02d", (int)config.alarm_min);
1611   7                    ShowString(40, 1, str, main_cache, FONT8X16, INVERSED, 0);
1612   7                  }
1613   6                }
1614   5                ShowString(16, 3, "Mode:", main_cache, FONT6X8, NO_INVERSED, 0);
1615   5                if(pointer == 1 && set_index != 0)
1616   5                {
1617   6                  
1618   6                  if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1619   6                  {
1620   7                    sprintf(str, "%02d", (int)config.alarm_day);
1621   7                    ShowString(16, 6, str, main_cache, FONT8X16, set_index==1?NO_INVERSED:INVERSED, 0);
1622   7                  }
1623   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, INVERSED, 1); 
1624   6                }
1625   5                else
1626   5                {
1627   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, NO_INVERSED, 1);            
1628   6                }
1629   5              }
1630   4              if(Trg != 0)
1631   4              {
1632   5                switch(Trg)
1633   5                {
1634   6                  case KEY1:
1635   6                  {
1636   7                    if(set_index != 0)
1637   7                      set_index = 0;
1638   7                    else
1639   7                      ON_CLOSE = 1;
1640   7                    break;
1641   7                  }
1642   6                  case KEY2:
1643   6                  {
1644   7                    if(set_index == 0)
1645   7                    {
1646   8                      if(++pointer == 2)
1647   8                        pointer = 0;
1648   8                    }
1649   7                    else
1650   7                    {
1651   8                      if(pointer == 0)
1652   8                      {
1653   9                        if(set_index == 1)
1654   9                        {
1655  10                          if(++config.alarm_hour == 24)
1656  10                            config.alarm_hour = 0;
1657  10                        }
1658   9                        else if(set_index == 2)
1659   9                        {
1660  10                          if(++config.alarm_min == 60)
1661  10                          config.alarm_min = 0;
1662  10                        }
1663   9                      }
1664   8                      else if(pointer == 1)
1665   8                      {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 28  

1666   9                        if(set_index == 1)
1667   9                        {
1668  10                          if(++config.alarm_mode == ALARM_MODE_NUM)
1669  10                            config.alarm_mode = 0;
1670  10                        }
1671   9                        else if(set_index == 2)
1672   9                        {
1673  10                          if(++config.alarm_day == 32)
1674  10                          {
1675  11                            config.alarm_day = 1;
1676  11                          }
1677  10                        }
1678   9                      }
1679   8                    }
1680   7                    break;
1681   7                  } 
1682   6                  case KEY3:
1683   6                  {
1684   7                    if(set_index == 0)
1685   7                    {
1686   8                      if(--pointer == 255)
1687   8                        pointer = 1;
1688   8                    }
1689   7                    else 
1690   7                    {
1691   8                      if(pointer == 0)
1692   8                      {
1693   9                        if(set_index == 1)
1694   9                        {
1695  10                          if(--config.alarm_hour == 255)
1696  10                            config.alarm_hour = 23;
1697  10                        }
1698   9                        else if(set_index == 2)
1699   9                        {
1700  10                          if(--config.alarm_min == 255)
1701  10                            config.alarm_min = 59;
1702  10                        }
1703   9                      }
1704   8                      else if(pointer == 1)
1705   8                      {
1706   9                        if(set_index == 1)
1707   9                        {
1708  10                          if(--config.alarm_mode == 255)
1709  10                            config.alarm_mode = ALARM_MODE_NUM - 1;
1710  10                        }
1711   9                        else if(set_index == 2)
1712   9                        {
1713  10                          if(--config.alarm_day == 0)
1714  10                          {
1715  11                            config.alarm_day = 31;
1716  11                          }
1717  10                        }
1718   9                      }
1719   8                    }
1720   7                    break;
1721   7                  }
1722   6                  case DOUBLE_TAP:
1723   6                  {
1724   7                    if(set_index == 0)
1725   7                      set_index ++;
1726   7                    else
1727   7                    {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 29  

1728   8                      if(pointer == 0)
1729   8                      {
1730   9                        if(++set_index == 3)
1731   9                          set_index = 1;
1732   9                      }
1733   8                      else if(pointer == 1)
1734   8                      {
1735   9                        if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1736   9                        {
1737  10                          if(++set_index == 3)
1738  10                          set_index = 1;
1739  10                        }
1740   9                      }
1741   8                    }
1742   7                    break;
1743   7                  }
1744   6                }
1745   5                Trg = 0;
1746   5              }
1747   4              if(ON_CLOSE)
1748   4              {
1749   5                ON_CLOSE = 0;
1750   5                set_index = 0;
1751   5                pointer = 0;
1752   5                if(config.alarm_mode != ALARM_DISABLE)
1753   5                {
1754   6                  if(config.alarm_mode == ALARM_WORKDAY)
1755   6                  {
1756   7                    PCF8563ReadTime(&RTC);
1757   7                    if(RTC.weekday > 5)
1758   7                      config.alarm_weekday = 1;
1759   7                    else
1760   7                    {
1761   8                      if((config.alarm_hour > RTC.hour) && (config.alarm_min > RTC.minute))
1762   8                        config.alarm_weekday = RTC.weekday;
1763   8                      else
1764   8                      {
1765   9                        if(RTC.weekday != 5)
1766   9                          config.alarm_weekday = RTC.weekday;
1767   9                        else
1768   9                          config.alarm_weekday = RTC.weekday + 1;
1769   9                      }
1770   8                    }
1771   7                  }
1772   6                  PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.
             -alarm_mode);
1773   6                }
1774   5                else
1775   5                  PCF8563DisableAlarm();
1776   5                EEPROMWriteConfiguration(&config);
1777   5                mode = -1;
1778   5                ON_RETURN = 1;
1779   5              }
1780   4            }
1781   3            else if(mode == 2)  //设置亮度
1782   3            {
1783   4              static char temp;
1784   4              //unsigned char *cache;
1785   4              if(ON_OPEN)
1786   4              {
1787   5                ON_OPEN = 0;
1788   5                temp = config.screen_brightness / 50;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 30  

1789   5                ClearCache(sub_cache2);
1790   5                ShowString(0, 0, "Set the contrast ratio of the screen.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1791   5                sprintf(str, "%d", (int)temp);
1792   5                ShowString(56, 3, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1793   5                ScreenPushAnimation(sub_cache2, LEFT);
1794   5              }
1795   4              if(tick_20ms)
1796   4              {
1797   5                tick_20ms = 0;  
1798   5                ClearCache(main_cache);
1799   5                ShowString(0, 0, "Set the contrast ratio of the screen.", main_cache, FONT6X8, NO_INVERSED, 0);
1800   5                sprintf(str, "%d", (int)temp);
1801   5                ShowString(56, 3, str, main_cache, FONT8X16, NO_INVERSED, 1);
1802   5              }
1803   4              if(Trg != 0)
1804   4              {
1805   5                switch(Trg)
1806   5                {
1807   6                  case 0x01:
1808   6                  {
1809   7                    ON_CLOSE = 1;
1810   7                    break;
1811   7                  }
1812   6                  case 0x02:
1813   6                  {
1814   7                    if(++temp == 6)
1815   7                      temp = 5;
1816   7                    config.screen_brightness = temp * 50 + 1;
1817   7                    ScreenSetBrightness(config.screen_brightness);
1818   7                    break;
1819   7                  } 
1820   6                  case 0x04:
1821   6                  {
1822   7                    if(--temp < 0)
1823   7                      temp = 0;
1824   7                    config.screen_brightness = temp * 50 + 1;
1825   7                    ScreenSetBrightness(config.screen_brightness);
1826   7                    break;
1827   7                  }
1828   6                  case 0x08:
1829   6                    break;
1830   6                }
1831   5                Trg = 0;
1832   5              }
1833   4              if(ON_CLOSE)
1834   4              {
1835   5                ON_CLOSE = 0;
1836   5                EEPROMWriteConfiguration(&config);
1837   5                mode = -1;
1838   5                ON_RETURN = 1;
1839   5              }
1840   4            }
1841   3            else if(mode == 3)  //设置自动息屏时间
1842   3            {
1843   4              static int temp;
1844   4              if(ON_OPEN)
1845   4              {
1846   5                ON_OPEN = 0;
1847   5                temp = config.t_inactive_max;
1848   5                ClearCache(sub_cache2);
1849   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", sub_cache2, FONT6X8, NO_INVERSED, 0);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 31  

1850   5                sprintf(str, "%d", temp);
1851   5                ShowString(56, 5, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1852   5                ShowString(72, 6, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1853   5                ScreenPushAnimation(sub_cache2, LEFT);
1854   5              }
1855   4              if(tick_20ms)
1856   4              {
1857   5                tick_20ms = 0;
1858   5                ClearCache(main_cache);
1859   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", main_cache, FONT6X8, NO_INVERSED, 0);
1860   5                sprintf(str, "%d", temp);
1861   5                ShowString(56, 5, str, main_cache, FONT8X16, NO_INVERSED, 0);
1862   5                ShowString(72, 6, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1863   5              }
1864   4              if(Trg != 0)
1865   4              {
1866   5                switch(Trg)
1867   5                {
1868   6                  case KEY1:
1869   6                  {
1870   7                    ON_CLOSE = 1;
1871   7                    break;
1872   7                  }
1873   6                  case KEY2:
1874   6                  {
1875   7                    if(++temp == 100)
1876   7                      temp = 99;
1877   7                    break;
1878   7                  } 
1879   6                  case KEY3:
1880   6                  {
1881   7                    if(--temp < 0)
1882   7                      temp = 0;
1883   7                    break;
1884   7                  }
1885   6                }
1886   5                Trg = 0;
1887   5              }
1888   4              if(ON_CLOSE)
1889   4              {
1890   5                ON_CLOSE = 0;
1891   5                config.t_inactive_max = temp;
1892   5                EEPROMWriteConfiguration(&config);
1893   5                mode = -1;
1894   5                ON_RETURN = 1;
1895   5              }
1896   4            }
1897   3            else if(mode == 4)  //设置自动关机时间
1898   3            {
1899   4              static int temp;
1900   4              if(ON_OPEN)
1901   4              {
1902   5                ON_OPEN = 0;
1903   5                temp = config.t_sleep_max;
1904   5                ClearCache(sub_cache2);
1905   5                ShowString(0, 0, "The time which mcu stay active for without any operation before power-down,when set
             - to 0,the mcu will never power down.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1906   5                sprintf(str, "%d", temp);
1907   5                ShowString(56, 6, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1908   5                ShowString(72, 7, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1909   5                ScreenPushAnimation(sub_cache2, LEFT);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 32  

1910   5              }
1911   4              if(tick_20ms)
1912   4              {
1913   5                tick_20ms = 0;
1914   5                ClearCache(main_cache);
1915   5                ShowString(0, 0, "The time which mcu stay active for before without any operation power-down,when set
             - to 0,the mcu will never power down.", main_cache, FONT6X8, NO_INVERSED, 0);
1916   5                sprintf(str, "%d", temp);
1917   5                ShowString(56, 6, str, main_cache, FONT8X16, NO_INVERSED, 0);
1918   5                ShowString(72, 7, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1919   5              }
1920   4              if(Trg != 0)
1921   4              {
1922   5                switch(Trg)
1923   5                {
1924   6                  case 0x01:
1925   6                  {
1926   7                    ON_CLOSE = 1;
1927   7                    break;
1928   7                  }
1929   6                  case 0x02:
1930   6                  {
1931   7                    if(++temp == 100)
1932   7                      temp = 99;
1933   7                    break;
1934   7                  } 
1935   6                  case 0x04:
1936   6                  {
1937   7                    if(--temp < 0)
1938   7                      temp = 0;
1939   7                    break;
1940   7                  }
1941   6                }
1942   5                Trg = 0;
1943   5              }
1944   4              if(ON_CLOSE)
1945   4              {
1946   5                ON_CLOSE = 0;
1947   5                config.t_sleep_max = temp;
1948   5                EEPROMWriteConfiguration(&config);
1949   5                mode = -1;
1950   5                ON_RETURN = 1;
1951   5              }
1952   4            }
1953   3            else if(mode == 5)  //设置屏幕反色
1954   3            {
1955   4              if(ON_OPEN)
1956   4              {
1957   5                ON_OPEN = 0;
1958   5                ClearCache(sub_cache2);
1959   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", sub_cache2, FONT8X16, NO_INVERSED, 0)
             -;
1960   5                ScreenPushAnimation(sub_cache2, LEFT);
1961   5              }
1962   4              if(tick_20ms)
1963   4              {
1964   5                tick_20ms = 0;
1965   5                ClearCache(main_cache);
1966   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", main_cache, FONT8X16, NO_INVERSED, 1)
             -;
1967   5              }
1968   4              if(Trg != 0)
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 33  

1969   4              {
1970   5                switch(Trg)
1971   5                {
1972   6                  case KEY1:
1973   6                  {
1974   7                    ON_CLOSE = 1;
1975   7                    break;
1976   7                  }
1977   6                  case DOUBLE_TAP:
1978   6                  {
1979   7                    if(config.screen_inverse == INVERSED)
1980   7                      config.screen_inverse = NO_INVERSED;
1981   7                    else
1982   7                      config.screen_inverse = INVERSED;
1983   7                    ScreenSetInverse(config.screen_inverse);
1984   7                    break;
1985   7                  } 
1986   6                }
1987   5                Trg = 0;
1988   5              }
1989   4              if(ON_CLOSE)
1990   4              {
1991   5                ON_CLOSE = 0;
1992   5                EEPROMWriteConfiguration(&config);
1993   5                mode = -1;
1994   5                ON_RETURN = 1;
1995   5              }
1996   4            }
1997   3            else if(mode == 6)  //设置屏幕方向
1998   3            {
1999   4              if(ON_OPEN)
2000   4              {
2001   5                ON_OPEN = 0;
2002   5                ClearCache(sub_cache2);
2003   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", sub_cache2, FONT8X16, NO
             -_INVERSED, 0);
2004   5                ScreenPushAnimation(sub_cache2, LEFT);
2005   5              }
2006   4              if(tick_20ms)
2007   4              {
2008   5                tick_20ms = 0;
2009   5                ClearCache(main_cache);
2010   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", main_cache, FONT8X16, NO
             -_INVERSED, 1);
2011   5              }
2012   4              if(Trg != 0)
2013   4              {
2014   5                switch(Trg)
2015   5                {
2016   6                  case KEY1:
2017   6                  {
2018   7                    ON_CLOSE = 1;
2019   7                    break;
2020   7                  }
2021   6                  case DOUBLE_TAP:
2022   6                  {
2023   7                    if(config.screen_direction == UPSIDEDOWN)
2024   7                      config.screen_direction = NORMAL;
2025   7                    else
2026   7                      config.screen_direction = UPSIDEDOWN;
2027   7                    ScreenSetDirection(config.screen_direction);
2028   7                    break;
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 34  

2029   7                  } 
2030   6                }
2031   5                Trg = 0;
2032   5              }
2033   4              if(ON_CLOSE)
2034   4              {
2035   5                ON_CLOSE = 0;
2036   5                EEPROMWriteConfiguration(&config);
2037   5                mode = -1;
2038   5                ON_RETURN = 1;
2039   5              }
2040   4            }
2041   3            else if(mode == 7)  //设置按键音
2042   3            {
2043   4              if(ON_OPEN)
2044   4              {
2045   5                ON_OPEN = 0;
2046   5                ClearCache(sub_cache2);
2047   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", sub_cache2, FONT8X16, NO_INVERSED,
             - 0);
2048   5                ScreenPushAnimation(sub_cache2, LEFT);
2049   5              }
2050   4              if(tick_20ms)
2051   4              {
2052   5                tick_20ms = 0;
2053   5                ClearCache(main_cache);
2054   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", main_cache, FONT8X16, NO_INVERSED,
             - 1);
2055   5              }
2056   4              if(Trg != 0)
2057   4              {
2058   5                switch(Trg)
2059   5                {
2060   6                  case KEY1:
2061   6                  {
2062   7                    ON_CLOSE = 1;
2063   7                    break;
2064   7                  }
2065   6                  case DOUBLE_TAP:
2066   6                  {
2067   7                    if(config.key_sound == ON)
2068   7                      config.key_sound = OFF;
2069   7                    else
2070   7                      config.key_sound = ON;
2071   7                    EnableBuzzer(config.key_sound);
2072   7                    break;
2073   7                  }
2074   6                }
2075   5                Trg = 0;
2076   5              }
2077   4              if(ON_CLOSE)
2078   4              {
2079   5                ON_CLOSE = 0;
2080   5                EEPROMWriteConfiguration(&config);
2081   5                mode = -1;
2082   5                ON_RETURN = 1;
2083   5              }
2084   4            }
2085   3            else if(mode == 8)  //单片机复位
2086   3            {
2087   4              MCUSoftReset();
2088   4            }
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 35  

2089   3            else if(mode == 9)  //系统掉电
2090   3            {
2091   4              ON_OPEN = 0;
2092   4              active_flag = 0;
2093   4              action = 0;
2094   4              sleep_flag = 0;
2095   4              powerdown_flag = 0;
2096   4              inactive_time = 0;
2097   4              sleep_time = 0;
2098   4              deep_powerdown_flag = 1;
2099   4              mode = -1;
2100   4              func_num = WATCH;
2101   4            }
2102   3          }
2103   2          else if(func_num == SNAKES)       //贪吃蛇  ok
2104   2          {
2105   3            #define PANEL_WIDTH   92
2106   3            #define PANEL_HEIGHT  64
2107   3            #define MAX_SNAKE_SPEED 50
2108   3            unsigned char i = 0;
2109   3            unsigned char str[6];
2110   3            static unsigned char snake_direction = 0;//means sneak direction
2111   3            static unsigned char snake_speed = 10;
2112   3            static unsigned char past_x[256];
2113   3            static unsigned char past_y[256];
2114   3            static unsigned char snake_head_x = 64, snake_head_y = 32, snake_len = 20;
2115   3            static unsigned char test_now = 0, delicious_x= 80,delicious_y = 40;
2116   3            static unsigned char best_score = 0;
2117   3            static bit game_loop = 0;
2118   3            static bit game_over = 0;
2119   3            static bit game_pause = 0;
2120   3            if(ON_OPEN)
2121   3            {
2122   4              ON_OPEN = 0;
2123   4              ClearCache(sub_cache2);
2124   4              ScreenPushAnimation(sub_cache2, LEFT);//设定该界面左移进入屏幕
2125   4              snake_direction = 0;
2126   4              snake_head_x = 64;
2127   4              snake_head_y = 32;
2128   4              snake_len = 20;
2129   4              game_over = 0;
2130   4              game_pause = 0;
2131   4              for(i = 0; i < snake_len; i++)
2132   4              {
2133   5                past_x[i] = 64;
2134   5                past_y[i] = 32;
2135   5              }
2136   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
2137   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
2138   4            }
2139   3            if(tick_8ms)
2140   3            {
2141   4              tick_8ms = 0;
2142   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
2143   4              IMUupdate(&LSM6DSM);
2144   4            }
2145   3            if(tick_1ms)
2146   3            {
2147   4              static unsigned char t_cnt = 0;
2148   4              tick_1ms = 0;
2149   4              if(++t_cnt == (MAX_SNAKE_SPEED - snake_speed))
2150   4              {
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 36  

2151   5                t_cnt = 0;
2152   5                game_loop = 1;
2153   5              }
2154   4            }
2155   3            if(game_loop)
2156   3            {
2157   4              game_loop = 0;
2158   4              inactive_time = 0;//to not close screen
2159   4              if(game_pause != 1)
2160   4              {
2161   5                ClearCache(main_cache);
2162   5                for(i = 0; i < PANEL_WIDTH; i++)  //画一个框
2163   5                {
2164   6                  DrawDot(i, 0);
2165   6                  DrawDot(i, PANEL_HEIGHT - 1);
2166   6                }
2167   5                for(i = 0; i < PANEL_HEIGHT; i++)
2168   5                {
2169   6                  DrawDot(0, i);
2170   6                  DrawDot(PANEL_WIDTH - 1, i);
2171   6                }
2172   5                ShowString(PANEL_WIDTH, 1, "Score:", main_cache, FONT6X8, NO_INVERSED, 0);
2173   5                sprintf(str, "%3d", (int)snake_len);
2174   5                ShowString(PANEL_WIDTH, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
2175   5                ShowString(PANEL_WIDTH, 5, "Best:", main_cache, FONT6X8, NO_INVERSED, 0);
2176   5                if(snake_len > best_score)
2177   5                  best_score = snake_len;
2178   5                sprintf(str, "%3d", (int)best_score);
2179   5                ShowString(PANEL_WIDTH, 6, str, main_cache, FONT6X8, NO_INVERSED, 0);
2180   5                if(snake_direction == 0)
2181   5                {
2182   6                  if(LSM6DSM.AngleY > 10)
2183   6                    snake_direction = 1;
2184   6                  else if(LSM6DSM.AngleY < -10)
2185   6                    snake_direction = 3;
2186   6                }
2187   5                else if(snake_direction == 1)
2188   5                {
2189   6                  if(LSM6DSM.AngleX > 10)
2190   6                    snake_direction = 0;
2191   6                  else if(LSM6DSM.AngleX < -10)
2192   6                    snake_direction = 2;
2193   6                }
2194   5                else if(snake_direction == 2)
2195   5                {
2196   6                  if(LSM6DSM.AngleY > 10)
2197   6                    snake_direction = 1;
2198   6                  else if(LSM6DSM.AngleY < -10)
2199   6                    snake_direction = 3;
2200   6                }
2201   5                else if(snake_direction == 3)
2202   5                {
2203   6                  if(LSM6DSM.AngleX > 10)
2204   6                    snake_direction = 0;
2205   6                  else if(LSM6DSM.AngleX < -10)
2206   6                    snake_direction = 2;
2207   6                }
2208   5                //这段是按键程序解析后转换为方向以及点位置的程序，
2209   5                //sneak_direction是方向，test_x是头部的x轴值，test_y是头部的y轴值
2210   5                switch(snake_direction)
2211   5                {
2212   6                  case 0:   //右
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 37  

2213   6                    snake_head_x++;
2214   6                    break;
2215   6                  case 1:   //下
2216   6                    snake_head_y++;
2217   6                    break;
2218   6                  case 2:   //左
2219   6                    snake_head_x--;
2220   6                    break;
2221   6                  case 3:   //上
2222   6                    snake_head_y--;
2223   6                    break;
2224   6                }
2225   5                if(snake_head_x >= PANEL_WIDTH)
2226   5                  snake_head_x = 1;
2227   5                else if(snake_head_x <= 0)
2228   5                  snake_head_x = PANEL_WIDTH - 1;
2229   5                if(snake_head_y >= PANEL_HEIGHT)
2230   5                  snake_head_y = 1;
2231   5                else if(snake_head_y <= 0)
2232   5                  snake_head_y = PANEL_HEIGHT - 1;
2233   5                //检查是否碰到自己的身体
2234   5                for(i = 0; i < snake_len; i++)
2235   5                {
2236   6                  if((snake_head_x == past_x[i]) && (snake_head_y == past_y[i]))
2237   6                  {
2238   7                    game_over = 1;
2239   7                    game_pause = 1;
2240   7                    break;
2241   7                  }
2242   6                }
2243   5                //这段是可以让贪吃蛇有可变长度尾巴的测试程序，test_num就是尾巴的数量，最大50，
2244   5                //程序原理是把每次过去的坐标都记录在数组里面。显示的时候就把过去的点也都显示出来
2245   5                test_now++;
2246   5                test_now = test_now % snake_len;
2247   5                past_x[test_now] = snake_head_x;
2248   5                past_y[test_now] = snake_head_y;
2249   5                for(i = 0; i < snake_len; i++)
2250   5                {
2251   6                  DrawDot(past_x[i], past_y[i]);
2252   6                }
2253   5                //这段程序放被吃掉的小东西，设计delicious_x,delicious_y为食物的坐标
2254   5                //吃掉食物以后会放一个新的食物，并且test_num也就是尾巴的数量会大1
2255   5                if((snake_head_x <= delicious_x+1) && (snake_head_y <= delicious_y+1) && (snake_head_x >= delicious_x
             --1) && (snake_head_y>=delicious_y-1))
2256   5                {
2257   6                  snake_len++;
2258   6                  past_x[snake_len - 1] = past_x[snake_len - 2];//解决小白点的问题
2259   6                  past_y[snake_len - 1] = past_y[snake_len - 2];
2260   6                  Bee();
2261   6                  delicious_x = rand() % 92;
2262   6                  if(delicious_x > PANEL_WIDTH - 2)
2263   6                    delicious_x = PANEL_WIDTH - 2;
2264   6                  else if(delicious_x < 2)
2265   6                    delicious_x  = 2;
2266   6                  delicious_y = rand() % 64;
2267   6                  if(delicious_y > PANEL_HEIGHT - 2)
2268   6                    delicious_y = PANEL_HEIGHT - 2;
2269   6                  else if(delicious_y < 2)
2270   6                    delicious_y  = 2;
2271   6                }
2272   5                DrawDot(delicious_x,delicious_y);
2273   5                DrawDot(delicious_x+1,delicious_y);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 38  

2274   5                DrawDot(delicious_x-1,delicious_y);
2275   5                DrawDot(delicious_x,delicious_y+1);
2276   5                DrawDot(delicious_x+1,delicious_y+1);
2277   5                DrawDot(delicious_x-1,delicious_y+1);
2278   5                DrawDot(delicious_x,delicious_y-1);
2279   5                DrawDot(delicious_x+1,delicious_y-1);
2280   5                DrawDot(delicious_x-1,delicious_y-1);
2281   5                if(snake_len < 30)
2282   5                  snake_speed = 10;
2283   5                else if(snake_len < 40)
2284   5                  snake_speed = 20;
2285   5                else if(snake_len < 60)
2286   5                  snake_speed = 30;
2287   5                else if(snake_len < 90)
2288   5                  snake_speed = 35;
2289   5                else if(snake_len < 130)
2290   5                  snake_speed = 40;
2291   5                else
2292   5                  snake_speed = 45;
2293   5              }
2294   4              if(game_over)
2295   4              {
2296   5                ShowString(30, 2, "GAME", main_cache, FONT8X16, NO_INVERSED, 0);
2297   5                ShowString(30, 4, "OVER", main_cache, FONT8X16, NO_INVERSED, 0);
2298   5              }
2299   4              ScreenRefreshAll(main_cache);
2300   4            }
2301   3            if(Trg != 0)
2302   3            {
2303   4              switch(Trg)
2304   4              {
2305   5                case KEY1:
2306   5                {
2307   6                  ON_CLOSE = 1;
2308   6                  break;
2309   6                }
2310   5                case KEY2:
2311   5                {
2312   6                  if(game_over != 1)
2313   6                  {
2314   7                    if(game_pause)
2315   7                      game_pause = 0;
2316   7                    else
2317   7                      game_pause = 1;
2318   7                  }
2319   6                  break;
2320   6                }
2321   5                case KEY3:
2322   5                {
2323   6                  ON_OPEN = 1;
2324   6                  break;
2325   6                }
2326   5              }
2327   4              Trg = 0;
2328   4            }
2329   3            if(ON_CLOSE)
2330   3            {
2331   4              ON_CLOSE = 0;
2332   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
2333   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
2334   4              func_num = MENU;
2335   4              ON_RETURN = 1;  
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 39  

2336   4            }
2337   3          }
2338   2          if(action)          //系统在不同状态下对动作的处理
2339   2          {
2340   3            action = 0;
2341   3            if(active_flag)
2342   3              inactive_time = 0;
2343   3            else if(sleep_flag)
2344   3            {
2345   4              sleep_flag = 0;
2346   4              sleep_time = 0;
2347   4              active_flag = 1;
2348   4              ScreenOnOff(ON);
2349   4              screen_on_flag = 1;
2350   4            }
2351   3            else if(powerdown_flag)
2352   3            {
2353   4              powerdown_flag = 0;
2354   4              active_flag = 1;
2355   4              SystemPowerOn();
2356   4              ScreenOnOff(ON);
2357   4              screen_on_flag = 1;
2358   4              ON_OPEN = 1;
2359   4            }
2360   3            else if(deep_powerdown_flag)
2361   3            {
2362   4              deep_powerdown_flag = 0;
2363   4              active_flag = 1;
2364   4              SystemPowerOn();
2365   4              DisplayInit(&config);
2366   4              screen_on_flag = 1;
2367   4              SensorInit();
2368   4              PW02SetMode(0);
2369   4              PCF8563EnableTimer(TIMERCLK_1_60_HZ, 1);  //自动唤醒频率1min一次
2370   4              ON_OPEN = 1;
2371   4            }
2372   3            autowake_cnt = 0;
2373   3          }
2374   2          if(sleep_flag)
2375   2          {
2376   3            if(screen_on_flag)
2377   3            {
2378   4              ScreenOnOff(OFF);
2379   4              screen_on_flag = 0;
2380   4            }
2381   3          }   
2382   2          if(powerdown_flag)    
2383   2          {
2384   3            if(ON_CLOSE == 0)
2385   3            {
2386   4              SystemPowerDown();
2387   4            }
2388   3          }
2389   2          if(deep_powerdown_flag)
2390   2          {
2391   3            if(ON_CLOSE == 0)
2392   3            {
2393   4              SystemDeepPowerDown();
*** WARNING C206 IN LINE 2393 OF ..\User\main.c: 'SystemDeepPowerDown': missing function-prototype
2394   4            }
2395   3            Enable3V3Output(1);
2396   3            Delay1ms(10);
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 40  

2397   3          }
2398   2          if(alarm_flag)
2399   2          {
2400   3            sleep_time = 0;     //闹铃被关掉前不会待机
2401   3          }
2402   2          if(timer_on_flag)
2403   2          {
2404   3            sleep_time = 0;     //计时器在工作时不会待机
2405   3          }
2406   2          if(PCF8563_int_flag)  //PCF8563产生了中断信号
2407   2          {
2408   3            unsigned char pcf8563_int_src;
2409   3            PCF8563_int_flag = 0;
2410   3            pcf8563_int_src = PCF8563ReadIntSrc();  //读PCF8563状态寄存器
2411   3            PCF8563ReadTime(&RTC);
2412   3            if(pcf8563_int_src & ALARM_INT)       //如果是闹钟中断
2413   3            {
2414   4              PCF8563ClearAlarmFlag();  //清除闹钟中断标志位
2415   4              action = 1;       //产生动作
2416   4              alarm_flag = 1;   //置位闹钟标志位
2417   4              Beebeebee();      //响铃
2418   4              Delay1ms(5);
2419   4              if(config.alarm_mode == ALARM_WORKDAY) 
2420   4              {
2421   5                if(RTC.weekday + 1 > 5)
2422   5                  config.alarm_weekday = 1;
2423   5                else
2424   5                  config.alarm_weekday = RTC.weekday + 1;
2425   5                PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.a
             -larm_mode);
2426   5              }
2427   4              else if(config.alarm_mode != ALARM_EVERYDAY)  //如果闹钟模式不是每天都响
2428   4              {
2429   5                config.alarm_mode = ALARM_DISABLE;  //关闭闹钟
2430   5                PCF8563DisableAlarm();              //关闭闹钟
2431   5              }
2432   4              EEPROMWriteConfiguration(&config);
2433   4            }
2434   3            if(pcf8563_int_src & TIMER_INT)       //如果是定时器中断
2435   3            {
2436   4              PCF8563ClearTimerFlag();  //清除定时器中断标志位
2437   4              //PCF8563以固定的时间间隔唤醒MCU
2438   4              //唤醒之后执行以下内容  
2439   4              battery_life = GetBatteryLife();
2440   4              if(active_flag || sleep_flag || powerdown_flag)      
2441   4              {
2442   5                if((RTC.hour == 22) && (RTC.minute == 4))   //22:04,记录当天的步数数据
2443   5                {
2444   6                  char i, j;
2445   6                  for(i = 6; i > 0; i--)
2446   6                  {
2447   7                    for(j = 0; j < 10; j++)
2448   7                    {
2449   8                      config.history_step[i][j] = config.history_step[i - 1][j];
2450   8                    }
2451   7                  }
2452   6                  sprintf(config.history_step[0], "%d/%d %d", (int)RTC.month, (int)RTC.day, (int)LSM6DSMGetCurrentStep
             -());
2453   6                  EEPROMWriteConfiguration(&config);
2454   6                  LSM6DSMResetStepCounter();
2455   6                }
2456   5              }
C51 COMPILER V9.52.0.0   MAIN                                                              07/11/2021 16:30:41 PAGE 41  

2457   4              if(powerdown_flag)
2458   4              {
2459   5                if(++autowake_cnt >= 1440)    //1440分钟 = 1天
2460   5                {
2461   6                  autowake_cnt = 0;
2462   6                  powerdown_flag = 0;
2463   6                  PCF8563EnableTimer(TIMERCLK_1_60_HZ, 10); //自动唤醒频率改为10min一次，本来1min一次
2464   6                  deep_powerdown_flag = 1;
2465   6                }
2466   5              }
2467   4            }    
2468   3          }
2469   2          //*****/      
2470   2        }           
2471   1        
2472   1      }
2473          
2474          
2475            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  18200    ----
   CONSTANT SIZE    =   9022    ----
   XDATA SIZE       =    862     132
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
