C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Objects\main.obj
COMPILER INVOKED BY: E:\install_files\keil\C51\BIN\C51.EXE ..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\
                    -oled;..\User\rtc;..\User\System;..\User;..\User\bluetooth;..\User\radio;..\User\sensor) DEBUG OBJECTEXTEND PRINT(..\List
                    -ings\main.lst) TABS(2) OBJECT(..\Objects\main.obj)

line level    source

   1          #include "Sys.h"
   2          #include "bmp.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "stdlib.h"
   6          #include "string.h"
   7          #include "math.h"
   8          #include "Delay.h"
   9          #include "PowerManage.h"
  10          #include "Buzzer.h"
  11          #include "Display.h"
  12          #include "PW02.h"
  13          #include "PCF8563.h"
  14          #include "BME280.h"                  
  15          #include "HMC5883L.h"                 
  16          #include "RDA5807M.h"
  17          #include "LSM6DSM.h"
  18          #include "Ellipsoid fitting.h"
  19          #include "stc8a.h"
  20          
  21          
  22          
  23          
  24          /***********************状态机相关变量*********************/
  25          enum function func_num = WATCH;    //功能号
  26          char func_index;               //功能索引
  27          bit ON_OPEN = 0;
  28          bit ON_CLOSE = 0;
  29          bit ON_RETURN = 0;
  30          /********************************************************/
  31          /************************时基信号************************/
  32          bit tick_1ms = 0;             //1000Hz
  33          bit tick_8ms = 0;             //125hz
  34          bit tick_20ms = 0;            //50hz
  35          
  36          /*************************工作状态相关变量*******************************/
  37          bit action = 0;             //动态标志位
  38          bit active_flag =1;       //活动标志位
  39          bit sleep_flag = 0;         //睡眠标志位
  40          bit powerdown_flag = 0;     //掉电标志位
  41          bit deep_powerdown_flag = 0;    //深度掉电标志位
  42          unsigned int inactive_time =0;  //自动息屏的时间
  43          unsigned int sleep_time = 0;    //自动待机时间
  44          unsigned int autowake_cnt = 0;  //自动唤醒的次数
  45          bit screen_on_flag = 1;     //屏幕状态标志位
  46          bit PCF8563_int_flag = 0;   //pcf8563中断产生标志位
  47          bit alarm_flag = 0;         //闹铃标志位
  48          bit radio_on_flag = 0;      //收音机工作标志位
  49          bit timer_on_flag = 0;      //计时器工作标志位
  50          /*************************按键相关变量*********************/
  51          unsigned char Trg = 0;      //按键触发值
  52          unsigned char Cont = 0;     //按键持续值
  53          /*************************显示缓存*******************************/
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 2   

  54          extern unsigned char xdata main_cache[];
  55          extern unsigned char xdata sub_cache1[];
  56          extern unsigned char xdata sub_cache2[];          
  57          
  58          struct sys_config config;   //设置信息结构体
  59          struct pcf8563_time RTC;    //时间信息结构体
  60          struct bme280_data BME280;  //bme280数据结构体
  61          struct lsm6dsm_data LSM6DSM;//LSM6DSM 数据结构体
  62          struct cal_data magnet_cal_data;  //磁力计校准数据结构体
  63          float battery_life;         //电池电量
  64          unsigned int  timer_cnt = 0;//定时器0溢出次数
  65          
  66          //****
  67          void  LED1_ON()
  68          {
  69   1        P35 = 1;
  70   1      }  
  71          void  LED1_OFF()
  72          {
  73   1        P35 = 0;
  74   1      }
  75          
  76          void BreathingLamp(void)
  77          {
  78   1        unsigned int  i=0,  j=0,num=500;
  79   1        for(i=0;i<num;i++)
  80   1          {
  81   2            for(j=0;j<num;j++)
  82   2             {
  83   3                if(i>j)
  84   3              {
  85   4                LED1_ON();
  86   4                Delay1us(1);
  87   4              }
  88   3              else
  89   3              {
  90   4                LED1_OFF();
  91   4                Delay1us(1);
  92   4              } 
  93   3            }
  94   2          }
  95   1          FeedWatchDog();   
  96   1          Delay1us(1);
  97   1          for(i=0;i<num;i++)
  98   1          {
  99   2            for(j=0;j<num;j++)
 100   2            {
 101   3              if(i>j)
 102   3              {
 103   4                LED1_OFF();
 104   4                Delay1us(1);
 105   4              }
 106   3              else
 107   3              {
 108   4                LED1_ON();
 109   4                Delay1us(1);
 110   4                
 111   4              } 
 112   3            }
 113   2          }
 114   1      }
 115          //********/
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 3   

 116          
 117          
 118          
 119          void KeyScan(void)
 120          {
 121   1        unsigned char dat = 0x00;
 122   1        if(K1 == 0)              //m按键被按下
 123   1          dat |= KEY1;          //被按下的键的键码是0x01
 124   1        if(K2 == 0)             //按键up被按下
 125   1          dat |= KEY2;          //被按下的键码是0x02
 126   1        if(K3 ==0)              //按键down被按下
 127   1          dat |= KEY3;          //被按下的键码是0x04
 128   1        Trg = dat&(dat^Cont);   //按键触发值等于被按下的键码值  与上按键持续值          0x01 & 0x01 =0x01,说明按键
             -的触发次数为1
 129   1        Cont = dat;             //按下键码赋值给按键持续值
 130   1      }
 131          
 132          void TM3_Ist()  interrupt 19 using 1    //  mcu TIM3 定时器定时1ms中断
 133          {
 134   1        
 135   1        static unsigned int t_count = 0;
 136   1        static unsigned int t_key_press =0;   
 137   1        AUXINTIF &= ~T3IF;                    //清除中断标志位
 138   1        //
 139   1        if((K1 == 0) && (K2 == 0) && (K3 == 0))
 140   1        {
 141   2          while ((K1 == 0) ||(K2 == 0) ||(K3 == 0) ); //三个按键均抬起
 142   2          MCUSoftReset();                         //软复位MCU
 143   2        }
 144   1          if(t_count % 50 == 0)
 145   1        {
 146   2          KeyScan();
 147   2          if(Trg)
 148   2          {
 149   3            Bee();          
 150   3            action = 1;
 151   3            LED1_OFF(); 
 152   3      //      if(sleep_flag || powerdown_flag || alarm_flag)
 153   3      //      {
 154   3      //        Trg = 0;        
 155   3      //        if(alarm_flag)
 156   3      //        {
 157   3      //          alarm_flag = 0;
 158   3      //          LED(OFF);
 159   3      //        }
 160   3          } 
 161   2        }
 162   1      //    if(Cont)
 163   1      //    {
 164   1      //      if(++t_key_press > 10)  //判断是否长按
 165   1      //        Trg = Cont;           //重复触发
 166   1      //    }
 167   1      //    else
 168   1      //      t_key_press = 0;
 169   1      //  }
 170   1      //  tick_1ms = 1;
 171   1      //  if(t_count % 8 == 0)
 172   1      //    tick_8ms = 1;
 173   1      //  if(t_count % 20 == 0)
 174   1          tick_20ms = 1;
 175   1      //      
 176   1      //  if(++t_count == 1000)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 4   

 177   1      //  {
 178   1      //    t_count = 0;
 179   1      //    if(active_flag)
 180   1      //    {
 181   1      //      if(++inactive_time == config.t_inactive_max)
 182   1      //      {
 183   1      //        active_flag = 0;
 184   1      //        inactive_time = 0;
 185   1      //        sleep_flag = 1;
 186   1      //      }
 187   1      //    }
 188   1      //    if(sleep_flag)
 189   1      //    {
 190   1      //      if(++sleep_time == config.t_sleep_max)
 191   1      //      {
 192   1      //        sleep_flag = 0;
 193   1      //        sleep_time = 0;
 194   1      //        powerdown_flag = 1;
 195   1      //        ON_CLOSE = 1;
 196   1      //      }
 197   1      //    }
 198   1      //  }
 199   1      }
*** WARNING C280 IN LINE 136 OF ..\User\main.c: 't_key_press': unreferenced local variable
 200          
 201          void INT0_Isr() interrupt 0           //PCF8563中断
 202          {
 203   1        PCF8563_int_flag = 1;
 204   1      }
 205          void TM0_Isr() interrupt 1 using 1    //计数器0溢出中断
 206          {
 207   1        timer_cnt++;
 208   1      }
 209          void INT1_Isr() interrupt 2 using 1   //双击中断   是基于LSM6DSM                          
 210          {
 211   1      //  action = 1;
 212   1      //  alarm_flag = 0;
 213   1      //  Bee();
 214   1      //  if(sleep_flag || powerdown_flag || alarm_flag)
 215   1      //    Trg = 0;
 216   1      //  else
 217   1      //    Trg = DOUBLE_TAP;
 218   1      //  if(active_flag && func_num == WATCH)
 219   1      //  {
 220   1      //    action = 0;
 221   1      //    active_flag = 0;
 222   1      //    inactive_time = 0;
 223   1      //    ScreenOnOff(OFF);
 224   1      //    sleep_flag = 1;
 225   1      //                      
 226   1      //  }
 227   1      }
 228          void INT2_Isr() interrupt 10 using 1  //抬腕唤醒中断
 229          {
 230   1      //  action = 1;
 231   1      //  if(sleep_flag || powerdown_flag)
 232   1      //  {Trg = 0;}
 233   1      //  else 
 234   1      //  {Trg = AWT;}
 235   1      }
 236          void INT3_Isr() interrupt 11          //按键2中断
 237          {
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 5   

 238   1        action = 1;
 239   1      }
 240          void SensorInit(void)
 241          {
 242   1        unsigned char y = 0;
 243   1        unsigned int time_out = 700;
 244   1        unsigned char error_count = 0;
 245   1        if(BME280Init() == 0)
 246   1        {
 247   2          y += ShowString(0, y, "BME280 ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 248   2          error_count++;
 249   2        }
 250   1        if(HMC5883L_Init() == 0)
 251   1        {
 252   2          y += ShowString(0, y, "HMC5883L ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 253   2          error_count++;
 254   2        }
 255   1        if(LSM6DSMInit() == 0)
 256   1        {
 257   2          y += ShowString(0, y, "LSM6DSM ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 258   2          error_count++;       
 259   2        } 
 260   1        if(RDA5807MInit() == 0)
 261   1        {
 262   2          y += ShowString(0, y, "RDA5807M ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 263   2          error_count++;
 264   2        }
 265   1        if(error_count != 0)
 266   1        {
 267   2          while(Trg == 0)
 268   2          {
 269   3            Delay1ms(1);
 270   3            if(--time_out == 0)
 271   3              break;
 272   3          }
 273   2        }
 274   1      }
 275          
 276          
 277          
 278          
 279          void main()
 280          { 
 281   1        
 282   1        
 283   1        SysInit();            //系统初始化
 284   1        DisplayInit(&config); //显示初始化     
 285   1        PCF8563Init();        //实时时钟初始化        
 286   1        SensorInit();         //传感器初始化
 287   1        ClearCache(main_cache); //清空主显存
 288   1        
 289   1        
 290   1        while(1)
 291   1        
 292   1        {
 293   2          FeedWatchDog();     //喂看门狗
 294   2          //BreathingLamp();
 295   2          
 296   2          
 297   2      //*****
 298   2       
 299   2          //if(func_num == WATCH)           //显示表盘
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 6   

 300   2            if(1)
 301   2          {
 302   3            unsigned char x, n, m;
 303   3            unsigned char str[16];
 304   3          /******
 305   3            if(ON_OPEN)     //进入该功能时执行的内容
 306   3            {
 307   3              ON_OPEN = 0;
 308   3              if(func_index == FIRST_FUNC)
 309   3                ScreenPushAnimation(sub_cache1, DOWN);
 310   3              else if(func_index == LAST_FUNC)
 311   3                ScreenPushAnimation(sub_cache1, UP);
 312   3              func_index = WATCH;
 313   3            }
 314   3            
 315   3            if(ON_RETURN)   //返回该功能时执行的内容
 316   3            {
 317   3              ON_RETURN = 0;
 318   3              
 319   3            }
 320   3            ******/
 321   3            
 322   3            if(tick_20ms)   //在功能里时，每20ms执行一次功能内容
 323   3            {
 324   4              tick_20ms = 0;
 325   4              
 326   4              //显示时间
 327   4              PCF8563ReadTime(&RTC);
 328   4              //printf("%d:%d:%d\n", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
 329   4              DisplayTime(RTC.hour, RTC.minute, RTC.second);
 330   4              
 331   4              Delay1ms(1000);
 332   4              
 333   4              //显示小图标
 334   4      //        ClearCacheArea(0, 0, 35, 8, main_cache);
 335   4      //        x = 0;
 336   4      //        BMPToCache(x, 0, 8, 8, BLUETOOTH_SMALL_ICON, main_cache, 0);
 337   4      //        x += 9;
 338   4      //        if(timer_on_flag)
 339   4      //        {
 340   4      //          BMPToCache(x, 0, 8, 8, TIMER_SMALL_ICON, main_cache, 0);
 341   4      //          x += 9;
 342   4      //        }
 343   4      //        if(config.alarm_mode != ALARM_DISABLE)
 344   4      //        {
 345   4      //          BMPToCache(x, 0, 8, 8, CLOCK_SMALL_ICON, main_cache, 0);
 346   4      //          x += 9;
 347   4      //        }
 348   4      //        if(radio_on_flag)
 349   4      //          BMPToCache(x, 0, 8, 8, RADIO_SMALL_ICON, main_cache, 0);
 350   4              
 351   4      //        //显示日期，星期
 352   4      //        ClearCacheArea(0, 7, 128, 8, main_cache);
 353   4              sprintf(str, "%d/%d/%d ", (int)RTC.year, (int)RTC.month, (int)RTC.day);
 354   4              strcat(str, WEEKDAY_IN_STR[RTC.weekday - 1]);
 355   4              ShowString(0, 7, str, main_cache, FONT6X8, NO_INVERSED, 1);
 356   4              //显示电量
 357   4      //        battery_life = GetBatteryLife();
 358   4      //        for(n = 0; n < 24; n++)
 359   4      //          str[n] = BATTERY_LIFE_ICON[n];          
 360   4      //        m = 18 * battery_life;
 361   4      //        for(n = 2; n < 2 + m; n++)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 7   

 362   4      //          str[n] |= 0x3c;
 363   4      //        BMPToCache(104, 0, 24, 8, str, main_cache, 0);
 364   4      //        sprintf(str, "%3d%%", (int)(battery_life * 100));
 365   4      //        ShowString(78, 0, str, main_cache, FONT6X8, NO_INVERSED, 1);
 366   4            }
 367   3          } 
 368   2          
 369   2            if(Trg != 0)    //在该功能下对按键事件的处理
 370   2            {
 371   3              
 372   3              switch(Trg)
 373   3              {
 374   4                
 375   4                case KEY1:
 376   4                {
 377   5                  func_num = SUB_MENU;
 378   5                  ON_CLOSE = 1;
 379   5                  break;
 380   5                }
 381   4                case KEY2:
 382   4                {
 383   5                  func_index = FIRST_FUNC;
 384   5                  func_num = MENU;
 385   5                  ON_CLOSE = 1;
 386   5                  break;
 387   5                } 
 388   4                case KEY3:
 389   4                {
 390   5                  func_index = LAST_FUNC;
 391   5                  func_num = MENU;
 392   5                  ON_CLOSE = 1;
 393   5                  break;
 394   5                }
 395   4                case KEY13:
 396   4                {
 397   5                  active_flag = 0;
 398   5                  sleep_flag = 0;
 399   5                  powerdown_flag = 0;
 400   5                  inactive_time = 0;
 401   5                  sleep_time = 0;
 402   5                  deep_powerdown_flag = 1;
 403   5                  ON_CLOSE = 1;
 404   5                  break;
 405   5                }
 406   4              }
 407   3              Trg = 0;
 408   3              
 409   3            }
 410   2          
 411   2            if(ON_CLOSE)    //关闭该功能时执行的内容
 412   2            {
 413   3              
 414   3              ON_CLOSE = 0;
 415   3              SaveScreen();
 416   3              ON_OPEN = 1;
 417   3            }
 418   2          else if(func_num == MENU)       //主菜单    ok
 419   2          {   
 420   3            if(ON_OPEN)
 421   3            {
 422   4              ClearCache(sub_cache2);
 423   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 8   

 424   4              if(func_index == FIRST_FUNC)
 425   4                ScreenPushAnimation(sub_cache2, UP);
 426   4              else
 427   4                ScreenPushAnimation(sub_cache2, DOWN);
 428   4              ON_OPEN = 0;
 429   4            }
 430   3            if(ON_RETURN)
 431   3            {
 432   4              ON_RETURN = 0;
 433   4              ClearCache(sub_cache2);
 434   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 435   4              ScreenPushAnimation(sub_cache2, RIGHT);
 436   4            }
 437   3            
 438   3            if(Trg != 0)
 439   3            {
 440   4              switch(Trg)
 441   4              {
 442   5                case KEY1:
 443   5                {
 444   6                  goto case_AWT;
 445   6                  break;
 446   6                }
 447   5                case KEY2:
 448   5                {
 449   6                  if(++func_index > FUNC_NUM_MAX - 1)
 450   6                  {
 451   7                    func_index = LAST_FUNC;
 452   7                    func_num = WATCH;
 453   7                    ON_CLOSE = 1;
 454   7                  }
 455   6                  else
 456   6                  {
 457   7                    ClearCache(sub_cache2);
 458   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 459   7                    ScreenPushAnimation(sub_cache2, UP);
 460   7                  }
 461   6                  break;
 462   6                }
 463   5                case KEY3:
 464   5                {
 465   6                  if(--func_index < 0)
 466   6                  {
 467   7                    func_index = FIRST_FUNC;
 468   7                    func_num = WATCH;
 469   7                    ON_CLOSE = 1;
 470   7                  }
 471   6                  else
 472   6                  {
 473   7                    ClearCache(sub_cache2);
 474   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 475   7                    ScreenPushAnimation(sub_cache2, DOWN);
 476   7                  }
 477   6                  break;
 478   6                }
 479   5                case DOUBLE_TAP:
 480   5                {
 481   6                  func_num = func_index;
 482   6                  ON_CLOSE= 1;
 483   6                  break;
 484   6                }
 485   5                case AWT:
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 9   

 486   5                {
 487   6                  case_AWT:
 488   6                  if(func_index <= (FUNC_NUM_MAX - func_index))
 489   6                  {
 490   7                    while(func_index > 0)
 491   7                    {
 492   8                      func_index --;
 493   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 494   8                      ScreenPushAnimation(sub_cache2, DOWN);
 495   8                    }
 496   7                  }
 497   6                  else
 498   6                  {
 499   7                    while(func_index < FUNC_NUM_MAX - 1)
 500   7                    {
 501   8                      func_index ++;
 502   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 503   8                      ScreenPushAnimation(sub_cache2, UP);
 504   8                    }
 505   7                  }
 506   6                  func_num = WATCH;
 507   6                  ON_CLOSE = 1;
 508   6                  break;
 509   6                }
 510   5              }
 511   4              Trg = 0;
 512   4            }
 513   3            if(ON_CLOSE)
 514   3            {
 515   4              ON_CLOSE = 0;
 516   4              ON_OPEN = 1;
 517   4            }
 518   3          }
 519   2        
 520   2          else if(func_num == SUB_MENU)   //次菜单    ok
 521   2          {
 522   3            char x, y;    
 523   3            if(ON_OPEN)
 524   3            {
 525   4              ON_OPEN = 0;
 526   4              ClearCache(sub_cache2);
 527   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, sub_cache2, COVER);
 528   4              ScreenPushAnimation(sub_cache2, LEFT);
 529   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 530   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 531   4              LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 532   4            }
 533   3            if(tick_8ms)        //姿态解算频率：125hz
 534   3            {
 535   4              tick_8ms = 0;
 536   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
 537   4              IMUupdate(&LSM6DSM);
 538   4            }
 539   3            if(tick_20ms)
 540   3            {
 541   4              tick_20ms = 0;
 542   4              LSM6DSM.AngleX -= config.cal_anglex;  //倾角减去偏移
 543   4              LSM6DSM.AngleY -= config.cal_angley;  //倾角减去偏移
 544   4              LSM6DSM.AngleY -= 30;
 545   4              LSM6DSM.AngleX *= 3;      //调整一下横向灵敏度
 546   4              LSM6DSM.AngleY *= 2;      //调整一下纵向灵敏度
 547   4              if(LSM6DSM.AngleX > 63)   //对计算结果进行限幅
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 10  

 548   4                LSM6DSM.AngleX = 63;
 549   4              else if(LSM6DSM.AngleX < -64)
 550   4                LSM6DSM.AngleX = -64;
 551   4              if(LSM6DSM.AngleY > 31)
 552   4                LSM6DSM.AngleY = 31;
 553   4              else if(LSM6DSM.AngleY < -31)
 554   4                LSM6DSM.AngleY = -31;
 555   4              x = 64 + LSM6DSM.AngleX;
 556   4              y = 32 + LSM6DSM.AngleY;
 557   4              if(x > 96)
 558   4                x = 96;
 559   4              if(y > 32)
 560   4                y = 32;
 561   4              ClearCache(main_cache);       //清空主缓存
 562   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, main_cache, COVER); //画菜单背景到主显存上
 563   4              DrawSelectionFrame(x, y);     //根据xy坐标画选择框到主显存上
 564   4              ScreenRefreshAll(main_cache); //将主显存刷新到OLED屏幕上
 565   4            }
 566   3            if(Cont == 0)
 567   3            {
 568   4              func_index = (enum function)((x + 16) / 32 + ((y + 16) / 32) * 4);
 569   4              func_num = func_index;
 570   4              ON_CLOSE = 1;
 571   4            }
 572   3            if(ON_CLOSE)
 573   3            {
 574   4              ON_CLOSE = 0;
 575   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
 576   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 577   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 578   4              ON_OPEN = 1;
 579   4            }
 580   3          }
 581   2      
 582   2          else if(func_num == STOPWATCH)  //计时器    ok
 583   2          { 
 584   3            unsigned char t = 0, t_x = 0, t_y = 2;
 585   3            static int ms = 0, sec = 0, min = 0;
 586   3            static unsigned char n = 0, x = 0, y = 2;
 587   3            static unsigned char str1[10][11];
 588   3            unsigned char str2[10];
 589   3            if(ON_OPEN)
 590   3            {
 591   4              ON_OPEN = 0;
 592   4              ClearCache(sub_cache2);
 593   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 594   4              sec = ms / 100 % 60;
 595   4              min = sec / 60;
 596   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 597   4              ShowString(32, 0, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 598   4              if(n != 0)
 599   4              {
 600   5                for(t = 0; t < n; t++)
 601   5                {
 602   6                  if(t == 6)
 603   6                  {
 604   7                    t_x = 64;
 605   7                    t_y = 2;
 606   7                  }
 607   6                  ShowString(t_x, t_y++, str1[t], sub_cache2, FONT6X8, NO_INVERSED, 0);
 608   6                }
 609   5              }
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 11  

 610   4              ScreenPushAnimation(sub_cache2, LEFT);
 611   4              ClearCache(sub_cache2);
 612   4            }
 613   3            if(tick_1ms)
 614   3            {
 615   4              tick_1ms = 0;
 616   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 617   4              sec = ms / 100;
 618   4              min = sec / 60;
 619   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 620   4              ShowString(32, 0, str2, main_cache, FONT8X16, NO_INVERSED, 1);
 621   4              sleep_time = 0;
 622   4            }
 623   3            if(Trg != 0)
 624   3            {
 625   4              switch(Trg)
 626   4              {
 627   5                case KEY1:
 628   5                {
 629   6                  ON_CLOSE = 1;
 630   6                  break;
 631   6                }
 632   5                case KEY2:
 633   5                {
 634   6                  if(TR0)
 635   6                  {
 636   7                    TR0 = 0;
 637   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, DISABLE_CLKOUT);
 638   7                    timer_on_flag = 0;
 639   7                  }
 640   6                  else
 641   6                  {
 642   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, ENABLE_CLKOUT);
 643   7                    TR0 = 1;
 644   7                    timer_on_flag = 1;
 645   7                  }
 646   6                  break;
 647   6                }
 648   5                case KEY3:
 649   5                {
 650   6                  timer_cnt = 0;
 651   6                  TH0 = 0;
 652   6                  TL0 = 0;
 653   6                  ms = 0;
 654   6                  sec = 0;
 655   6                  min = 0;
 656   6                  n = 0;
 657   6                  x = 0;
 658   6                  y = 2;
 659   6                  ClearCache(main_cache);
 660   6                  break;
 661   6                }
 662   5                case DOUBLE_TAP:
 663   5                {
 664   6                  if(n < 9 && timer_on_flag == 1)
 665   6                  {
 666   7                    if(n == 6)
 667   7                    {
 668   8                      x = 64;
 669   8                      y = 2;
 670   8                    }
 671   7                    sprintf(str1[n], "%d.%02d:%02d:%02d\0", (int)(n + 1), min, sec % 60, ms % 100);
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 12  

 672   7                    ShowString(x + 0, y++, str1[n++], main_cache, FONT6X8, NO_INVERSED, 1);
 673   7                  }
 674   6                  break;
 675   6                }
 676   5              }
 677   4              Trg = 0;
 678   4            }
 679   3            if(ON_CLOSE)
 680   3            {
 681   4              ON_CLOSE = 0;
 682   4              func_num = MENU;
 683   4              ON_RETURN = 1;
 684   4            }
 685   3          }
 686   2          else if(func_num == PEDOMETER)  //计步器    ok
 687   2          {
 688   3            unsigned char n;
 689   3            unsigned int step;
 690   3            unsigned char buf[8];
 691   3            if(ON_OPEN)
 692   3            {
 693   4              ON_OPEN = 0;
 694   4              PCF8563ReadTime(&RTC);
 695   4              ClearCache(sub_cache2);
 696   4              ShowString(0, 0, "Today:    History:", sub_cache2, FONT6X8, NO_INVERSED, 0);
 697   4              step = LSM6DSMGetCurrentStep();
 698   4              sprintf(buf, "%d ", step);
 699   4              ShowString(0, 1, buf, sub_cache2, FONT8X16, NO_INVERSED, 0);    
 700   4              ScreenPushAnimation(sub_cache2, LEFT);
 701   4            }
 702   3            if(tick_20ms)
 703   3            {
 704   4              tick_20ms = 0;
 705   4              step = LSM6DSMGetCurrentStep();
 706   4              sprintf(buf, "%d ", step);
 707   4              ShowString(0, 1, buf, main_cache, FONT8X16, NO_INVERSED, 0);
 708   4              for(n = 0; n < 7; n++)
 709   4              {
 710   5                ShowString(64, n + 1, config.history_step[n], main_cache, FONT6X8, NO_INVERSED, 1);
 711   5              }
 712   4            }
 713   3            if(Trg != 0)
 714   3            {
 715   4              switch(Trg)
 716   4              {
 717   5                case KEY1:
 718   5                {
 719   6                  ON_CLOSE = 1;
 720   6                  break;
 721   6                }
 722   5                case KEY2:
 723   5                {
 724   6                  //LSM6DSMResetStepCounter();
 725   6                  break;
 726   6                } 
 727   5              }
 728   4              Trg = 0;
 729   4            }
 730   3            if(ON_CLOSE)
 731   3            {
 732   4              ON_CLOSE = 0;
 733   4              func_num = MENU;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 13  

 734   4              ON_RETURN = 1;
 735   4            }
 736   3          }
 737   2          else if(func_num == THPMETER)   //温湿度计  ok
 738   2          {   
 739   3            float altitude;
 740   3            unsigned char str1[10] = {0};
 741   3            if(ON_OPEN)
 742   3            {
 743   4              ON_OPEN = 0;
 744   4              ClearCache(sub_cache2);
 745   4              BMPToCache(0, 0, 48, 64, T_H_P_A, sub_cache2, 0);
 746   4              sprintf(str1, "%.1f", BME280.temperature);
 747   4              ShowString(48, 0, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 748   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, sub_cache2, 0);
 749   4              sprintf(str1, "%.1f%%", BME280.humidity);
 750   4              ShowString(48, 2, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 751   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 752   4              ShowString(48, 4, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 753   4              ScreenPushAnimation(sub_cache2, LEFT);
 754   4              BME280ContinuousMeasurement(MS_125);    //连续测量模式，测量间隔125ms
 755   4            }
 756   3            if(tick_20ms)
 757   3            {
 758   4              tick_20ms = 0;
 759   4              BME280GetSensorData(&BME280);         //读BME280测量数据并显示
 760   4              altitude = 44330.77 * (1 - pow((BME280.pressure / 101500), 0.190263));
 761   4              ClearCache(main_cache);
 762   4              BMPToCache(0, 0, 48, 64, T_H_P_A, main_cache, 0);
 763   4              sprintf(str1, "%.1f", BME280.temperature);
 764   4              ShowString(48, 0, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 765   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, main_cache, 0);
 766   4              sprintf(str1, "%.1f %%", BME280.humidity);
 767   4              ShowString(48, 2, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 768   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 769   4              ShowString(48, 4, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 770   4              sprintf(str1, "%d m", (int)altitude);
 771   4              ShowString(48, 6, str1, main_cache, FONT8X16, NO_INVERSED, 1);
 772   4            }
 773   3            if(Trg == KEY1)
 774   3            {
 775   4              Trg = 0;
 776   4              ON_CLOSE = 1;
 777   4            }
 778   3            if(ON_CLOSE)
 779   3            {
 780   4              ON_CLOSE = 0;
 781   4              BME280SetMode(SLEEP_MODE);
 782   4              func_num = MENU;
 783   4              ON_RETURN = 1;
 784   4            }
 785   3          }
 786   2          else if(func_num == RADIO)      //收音机    ok
 787   2          {
 788   3            static unsigned char index = 0;
 789   3            static bit searching_flag = 0;
 790   3            static unsigned char search_direction;
 791   3            float temp;
 792   3            unsigned char str2[16];
 793   3            if(ON_OPEN)
 794   3            {
 795   4              ON_OPEN = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 14  

 796   4              ClearCache(sub_cache2);
 797   4              ShowString(80, 0, "volume", sub_cache2, FONT8X16, NO_INVERSED, 0);
 798   4              sprintf(str2,"%.1fMHz",config.radio_channel);
 799   4              ShowString(40, 3, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 800   4              ShowString(0, 6, "tune", sub_cache2, FONT8X16, NO_INVERSED, 0);
 801   4              ShowString(80, 6, "search", sub_cache2, FONT8X16, NO_INVERSED, 0);
 802   4              ShowString(0, 0, "close", main_cache, FONT8X16, NO_INVERSED, 0);
 803   4              ScreenPushAnimation(sub_cache2, LEFT);
 804   4              if(radio_on_flag != 1)
 805   4              {
 806   5                RDA5807MPowerUp();
 807   5                RDA5807MSetFq(config.radio_channel);
 808   5                if(config.radio_volume > 0x0f)
 809   5                  config.radio_volume = 0;
 810   5                RDA5807MSetVOLUME(config.radio_volume);
 811   5                radio_on_flag = 1;
 812   5              }
 813   4            }
 814   3            if(tick_20ms)
 815   3            {
 816   4              tick_20ms = 0;
 817   4              ClearCache(main_cache);
 818   4              ShowString(80, 0, "volume", main_cache, FONT8X16, index == 0?INVERSED:NO_INVERSED, 0);
 819   4              sprintf(str2,"%.1fMHz", config.radio_channel);
 820   4              ShowString(40, 3, str2, main_cache, FONT8X16, NO_INVERSED, 0);
 821   4              if(searching_flag)
 822   4              {
 823   5                temp = RDA5807MSEEK(search_direction);
 824   5                if(temp == 0)
 825   5                  ShowString(28, 5, "searching...", main_cache, FONT6X8, NO_INVERSED, 0);
 826   5                else
 827   5                {
 828   6                  config.radio_channel = temp;
 829   6                  searching_flag = 0;
 830   6                }
 831   5              }
 832   4              ShowString(80, 6, "search", main_cache, FONT8X16, index == 1?INVERSED:NO_INVERSED, 0);
 833   4              ShowString(0, 6, "tune", main_cache, FONT8X16, index == 2?INVERSED:NO_INVERSED, 0);
 834   4              ShowString(0, 0, "close", main_cache, FONT8X16, index == 3?INVERSED:NO_INVERSED, 1);
 835   4            }
 836   3            if(Trg != 0)
 837   3            {
 838   4              switch(Trg)
 839   4              {
 840   5                case KEY1:
 841   5                {
 842   6                  ON_CLOSE = 1;
 843   6                  break;
 844   6                }
 845   5                case KEY2:
 846   5                {
 847   6                  if(index == 0)
 848   6                  {
 849   7                    if(++config.radio_volume > 0x0f)
 850   7                      config.radio_volume = 0x0f;
 851   7                    RDA5807MSetVOLUME(config.radio_volume);
 852   7                  }
 853   6                  else if(index == 1)
 854   6                  {
 855   7                    search_direction = UPWARD;
 856   7                    searching_flag = 1;
 857   7                  }
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 15  

 858   6                  else if(index == 2)
 859   6                  {
 860   7                    config.radio_channel += 0.1;
 861   7                    if(config.radio_channel > 108)
 862   7                      config.radio_channel = 87;
 863   7                    RDA5807MSetFq(config.radio_channel);
 864   7                  }
 865   6                  break;
 866   6                } 
 867   5                case KEY3:
 868   5                {
 869   6                  if(index == 0)
 870   6                  {
 871   7                    if(--config.radio_volume == 255)
 872   7                      config.radio_volume = 0;
 873   7                    RDA5807MSetVOLUME(config.radio_volume);
 874   7                  }
 875   6                  else if(index == 1)
 876   6                  {
 877   7                    search_direction = DOWNWARD;
 878   7                    searching_flag = 1;
 879   7                  }
 880   6                  else if(index == 2)
 881   6                  {
 882   7                    config.radio_channel -= 0.1;
 883   7                    if(config.radio_channel < 87)
 884   7                      config.radio_channel = 108;
 885   7                    RDA5807MSetFq(config.radio_channel);
 886   7                  }
 887   6                  break;
 888   6                }
 889   5                case DOUBLE_TAP:
 890   5                {
 891   6                  if(++index == 4)
 892   6                    index = 0;
 893   6                  break;
 894   6                }
 895   5              }
 896   4              Trg = 0;
 897   4            }
 898   3            if(ON_CLOSE)
 899   3            {
 900   4              ON_CLOSE = 0;
 901   4              if(powerdown_flag == 0 && index == 3)
 902   4              {
 903   5                RDA5807MPowerDown();
 904   5                radio_on_flag = 0;
 905   5                index = 0;  
 906   5                EEPROMWriteConfiguration(&config);
 907   5              }
 908   4              func_num = MENU;
 909   4              ON_RETURN = 1;
 910   4            }
 911   3          }
 912   2          else if(func_num == COMPASS)    //磁力计    ok
 913   2          {
 914   3            //显示角度和指针
 915   3            static char mode = 0;
 916   3            int magnet_data[3] = {0};
 917   3            unsigned char str3[16];
 918   3            if(mode == 0)     
 919   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 16  

 920   4              unsigned char n;
 921   4              int angle_from_north;
 922   4              if(ON_OPEN)
 923   4              {
 924   5                ON_OPEN = 0;
 925   5                ClearCache(sub_cache2);
 926   5                sprintf(str3, "%d  ", angle_from_north);
 927   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 928   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 929   5                ScreenPushAnimation(sub_cache2, LEFT);
 930   5                //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 931   5                LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 932   5                LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 933   5                HMC5883L_Set_Mode(0);                   //设置连续测量模式
 934   5                HMC5883L_Set_Calibration_Value(config.cal_magnet_x0, config.cal_magnet_y0, config.cal_magnet_z0, 
 935   5                                              config.cal_magnet_ab, config.cal_magnet_ac);  //设置校准参数
 936   5              }
 937   4              if(ON_RETURN)
 938   4              {
 939   5                ON_RETURN = 0;
 940   5                ClearCache(sub_cache2);
 941   5                BMPToCache(16, 2, 32, 16, NESW[n], sub_cache2, COVER);
 942   5                sprintf(str3, "%d  ", angle_from_north);
 943   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, COVER);
 944   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 945   5                ScreenPushAnimation(sub_cache2, RIGHT);
 946   5              }
 947   4              if(tick_8ms)
 948   4              {
 949   5                tick_8ms = 0; 
 950   5                LSM6DSMReadGYRAndACC(&LSM6DSM);
 951   5                IMUupdate(&LSM6DSM);
 952   5              }
 953   4              if(tick_20ms)
 954   4              {
 955   5                tick_20ms = 0;
 956   5                Read_HMC5883L(magnet_data);
 957   5                angle_from_north = (int)HMC5883L_Get_AngleXY(magnet_data, (int)LSM6DSM.AngleX, (int)LSM6DSM.AngleY);
 958   5                angle_from_north += 90;
 959   5                if(angle_from_north >= 360)
 960   5                  angle_from_north -= 360;
 961   5                n = (angle_from_north + 22.5) / 45;
 962   5                if(n == 8)
 963   5                  n = 0;
 964   5                BMPToCache(16, 2, 32, 16, NESW[n], main_cache, 0);
 965   5                sprintf(str3, "%d  ", angle_from_north);
 966   5                ShowString(24, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 967   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, main_cache, 0);
 968   5                angle_from_north -= 90;
 969   5                if(angle_from_north < 0)
 970   5                  angle_from_north += 360;
 971   5                DrawArm(95, 31, 18, angle_from_north);
 972   5                ScreenRefreshAll(main_cache);
 973   5              }
 974   4              if(Trg != 0)
 975   4              {
 976   5                switch(Trg)
 977   5                {
 978   6                  case KEY1:
 979   6                  {
 980   7                    ON_CLOSE = 1;
 981   7                    break;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 17  

 982   7                  }
 983   6                  case KEY2:
 984   6                  {
 985   7                    mode = 1;
 986   7                    ON_OPEN = 1;
 987   7                    break;
 988   7                  } 
 989   6                }
 990   5                Trg = 0;
 991   5              }
 992   4              if(ON_CLOSE)
 993   4              {
 994   5                ON_CLOSE = 0;
 995   5                HMC5883L_Set_Mode(2);  //设置睡眠模式
 996   5                LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 997   5                LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 998   5                func_num = MENU;
 999   5                ON_RETURN = 1;
1000   5              }
1001   4            }
1002   3            else if(mode == 1)  //磁力计椭球校准
1003   3            {
1004   4              static int data_cnt = 0;
1005   4              if(ON_OPEN)
1006   4              {
1007   5                ON_OPEN = 0;
1008   5                ClearCache(sub_cache2);
1009   5                sprintf(str3, "x:%d", magnet_data[0]);
1010   5                ShowString(0, 0, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
1011   5                sprintf(str3, "y:%d", magnet_data[1]);
1012   5                ShowString(0, 2, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
1013   5                sprintf(str3, "z:%d", magnet_data[2]);
1014   5                ShowString(0, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
1015   5                ScreenPushAnimation(sub_cache2, LEFT);
1016   5                ResetMatrix();
1017   5                HMC5883L_Set_Calibration_Value(0, 0, 0, 1, 1);  //清除校准参数
1018   5              }
1019   4              if(tick_20ms)
1020   4              {
1021   5                tick_20ms = 0;
1022   5                Read_HMC5883L(magnet_data);
1023   5                CalcData_Input(magnet_data[0], magnet_data[1], magnet_data[2]);
1024   5                sprintf(str3, "x:%d", magnet_data[0]);
1025   5                ShowString(0, 0, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1026   5                sprintf(str3, "y:%d", magnet_data[1]);
1027   5                ShowString(0, 2, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1028   5                sprintf(str3, "z:%d", magnet_data[2]);
1029   5                ShowString(0, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1030   5                sprintf(str3, "data_cnt:%d", data_cnt);
1031   5                ShowString(0, 6, str3, main_cache, FONT8X16, NO_INVERSED, 1);
1032   5                if(++data_cnt == 5000)
1033   5                {
1034   6                  ON_CLOSE = 1;
1035   6                  Bee();
1036   6                }
1037   5              }
1038   4              if(Trg == KEY1)
1039   4              {
1040   5                Trg = 0;
1041   5                ON_CLOSE = 1;
1042   5              }
1043   4              if(ON_CLOSE)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 18  

1044   4              {
1045   5                ON_CLOSE = 0;
1046   5                Ellipsoid_fitting_Process(&magnet_cal_data);    //椭球校准算法
1047   5                HMC5883L_Set_Calibration_Value(magnet_cal_data.X0, magnet_cal_data.Y0, magnet_cal_data.Z0, 
1048   5                                              magnet_cal_data.A / magnet_cal_data.B, 
1049   5                                              magnet_cal_data.A / magnet_cal_data.C);//设置校准参数
1050   5                config.cal_magnet_x0 = magnet_cal_data.X0;
1051   5                config.cal_magnet_y0 = magnet_cal_data.Y0;
1052   5                config.cal_magnet_z0 = magnet_cal_data.Z0;
1053   5                config.cal_magnet_ab = magnet_cal_data.A / magnet_cal_data.B;
1054   5                config.cal_magnet_ac = magnet_cal_data.A / magnet_cal_data.C;
1055   5                EEPROMWriteConfiguration(&config);
1056   5                data_cnt = 0;
1057   5                mode = 0;
1058   5                ON_RETURN = 1;
1059   5              }
1060   4            }
1061   3          }
1062   2          
1063   2          else if(func_num == BLUETOOTH)  //蓝牙    ok
1064   2          {
1065   3            unsigned char bluetooth_data[128] = "\0";
1066   3            static bit bluetooth_init = 0;
1067   3            static unsigned char y = 0;
1068   3            static unsigned char connected = 0;
1069   3            if(ON_OPEN)
1070   3            {
1071   4              ON_OPEN = 0;
1072   4              ClearCache(sub_cache2);
1073   4              ScreenPushAnimation(sub_cache2, LEFT);
1074   4              if(bluetooth_init == 0)
1075   4              {
1076   5                while(PW02Init() == 0);       //蓝牙初始化
1077   5                bluetooth_init = 1;
1078   5              }
1079   4              PW02SetMode(1);
1080   4              y = 0;
1081   4            }
1082   3            if(tick_20ms)
1083   3            {
1084   4              tick_20ms = 0;
1085   4              if(connected == 0)
1086   4              {
1087   5                if(PW02CheckConnection())
1088   5                {
1089   6                  connected = 1;
1090   6                  y = 6;
1091   6                }
1092   5              }
1093   4              if((connected == 1) && PW02GetRxData(bluetooth_data))
1094   4                y += ShowString(0, y, bluetooth_data, main_cache, FONT8X16, NO_INVERSED, 1);
1095   4            }
1096   3            if(Trg != 0)
1097   3            {
1098   4              switch(Trg)
1099   4              {
1100   5                case KEY1:
1101   5                {
1102   6                  ON_CLOSE = 1;
1103   6                  break;
1104   6                }
1105   5                case KEY2:
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 19  

1106   5                {
1107   6                  ClearCache(main_cache);
1108   6                  y = 0;
1109   6                  y += ShowString(0, y, "Screen cleaned", main_cache, FONT8X16, NO_INVERSED, 1);
1110   6                  break;
1111   6                } 
1112   5              }
1113   4              Trg = 0;
1114   4            }
1115   3            if(ON_CLOSE)
1116   3            {
1117   4              ON_CLOSE = 0;
1118   4              if(connected == 0)
1119   4                while(PW02ExitATMode() == 0);
1120   4              else
1121   4                connected = 0;
1122   4              PW02SetMode(0);
1123   4              func_num = MENU;
1124   4              ON_RETURN = 1;
1125   4            }
1126   3          }
1127   2          else if(func_num == SPIRIT_LEVEL) //水平仪  ok
1128   2          {
1129   3            int x, y;
1130   3            unsigned char str[16];
1131   3            if(ON_OPEN)
1132   3            {
1133   4              ON_OPEN = 0;
1134   4              ClearCache(sub_cache2);
1135   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1136   4              ShowString(0, 0, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1137   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1138   4              ShowString(0, 1, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1139   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1140   4              ShowString(0, 2, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1141   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, sub_cache2, 0);
1142   4              ScreenPushAnimation(sub_cache2, LEFT);
1143   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
1144   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
1145   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
1146   4            }
1147   3            if(tick_8ms)
1148   3            {
1149   4              tick_8ms = 0;
1150   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
1151   4              IMUupdate(&LSM6DSM);
1152   4            }
1153   3            if(tick_20ms)
1154   3            {
1155   4              tick_20ms = 0;
1156   4              ClearCache(main_cache);
1157   4              LSM6DSM.AngleX -= config.cal_anglex;
1158   4              LSM6DSM.AngleY -= config.cal_angley;
1159   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1160   4              ShowString(0, 0, str, main_cache, FONT6X8, NO_INVERSED, 0);
1161   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1162   4              ShowString(0, 1, str, main_cache, FONT6X8, NO_INVERSED, 0);
1163   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1164   4              ShowString(0, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
1165   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, main_cache, 0);
1166   4              x = 64 + LSM6DSM.AngleX;
1167   4              y = 32 + LSM6DSM.AngleY;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 20  

1168   4              if(x > 126)
1169   4                x = 126;
1170   4              else if(x < 1)
1171   4                x = 1;
1172   4              if(y > 62)
1173   4                y = 62;
1174   4              else if(y < 1)
1175   4                y = 1;
1176   4              if(x ==63 && y == 32)
1177   4                ScreenSetInverse(config.screen_inverse == NO_INVERSED?INVERSED:NO_INVERSED);
1178   4              else
1179   4                ScreenSetInverse(config.screen_inverse);
1180   4              DrawDot(x, y);
1181   4              DrawDot(x - 1, y);
1182   4              DrawDot(x + 1, y);
1183   4              DrawDot(x, y + 1);
1184   4              DrawDot(x, y - 1);
1185   4              ScreenRefreshAll(main_cache);
1186   4            }
1187   3            if(Trg != 0)
1188   3            {
1189   4              switch(Trg)
1190   4              {
1191   5                case KEY1:
1192   5                {
1193   6                  ON_CLOSE = 1;
1194   6                  break;
1195   6                }
1196   5                case KEY2:
1197   5                {
1198   6                  config.cal_anglex = LSM6DSM.AngleX;
1199   6                  config.cal_angley = LSM6DSM.AngleY;
1200   6                  break;
1201   6                } 
1202   5                case KEY3:
1203   5                {
1204   6                  break;
1205   6                }
1206   5              }
1207   4              Trg = 0;
1208   4            }
1209   3            if(ON_CLOSE)
1210   3            {
1211   4              ON_CLOSE = 0;
1212   4              ScreenSetInverse(config.screen_inverse);
1213   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
1214   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
1215   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
1216   4              EEPROMWriteConfiguration(&config);
1217   4              func_num = MENU;
1218   4              ON_RETURN = 1;
1219   4            }
1220   3          }
1221   2        
1222   2          else if(func_num == FLASH_LIGHT)  //手电筒  ok
1223   2          {
1224   3            static char flash_mode = 0;
1225   3            static char flash_t_cnt = 0;
1226   3            static bit k = 0;
1227   3            if(ON_OPEN)
1228   3            {
1229   4              ON_OPEN = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 21  

1230   4              ClearCache(sub_cache2);
1231   4              ShowString(28, 3, "Torch ON", sub_cache2, FONT8X16, NO_INVERSED, 0);
1232   4              ScreenPushAnimation(sub_cache2, LEFT);
1233   4              ScreenSetInverse(INVERSED);
1234   4              ScreenSetBrightness(255);
1235   4              LED(ON);
1236   4            }
1237   3            if(tick_20ms)
1238   3            {
1239   4              tick_20ms = 0;
1240   4              inactive_time = 0;
1241   4              if(flash_mode)
1242   4              {
1243   5                if(flash_t_cnt++ == 5)
1244   5                {
1245   6                  flash_t_cnt = 0;
1246   6                  k = ~k;
1247   6                  LED(k);
1248   6                }
1249   5              }
1250   4            }
1251   3            if(Trg != 0)
1252   3            {
1253   4              switch(Trg)
1254   4              {
1255   5                case KEY1:
1256   5                {
1257   6                  ON_CLOSE = 1;
1258   6                  break;
1259   6                }
1260   5                case KEY2:
1261   5                {
1262   6                  if(flash_mode == 0)
1263   6                    flash_mode = 1;
1264   6                  else
1265   6                  {
1266   7                    flash_mode = 0;
1267   7                    LED(ON);
1268   7                  }
1269   6                  break;
1270   6                }
1271   5              }
1272   4              Trg = 0;
1273   4            }
1274   3            if(ON_CLOSE)
1275   3            {
1276   4              ON_CLOSE = 0;
1277   4              ScreenSetBrightness(config.screen_brightness);
1278   4              ScreenSetInverse(config.screen_inverse);
1279   4              LED(OFF);
1280   4              flash_mode = 0;
1281   4              flash_t_cnt = 0;
1282   4              func_num = MENU;
1283   4              ON_RETURN = 1;  
1284   4            }
1285   3          }
1286   2          
1287   2          else if(func_num == SETTING)      //设置    ok
1288   2          {
1289   3            
1290   3            static char index = 0;    //菜单的索引(0~MENU_MAX_ROW-1)
1291   3            static char pointer = 0;  //当前所选项在屏幕上的位置(0~3)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 22  

1292   3            static char mode = -1;
1293   3            unsigned char str[21];
1294   3            unsigned char *cache;
1295   3            
1296   3            if(mode == -1)  //设置菜单界面
1297   3            {
1298   4              if(ON_OPEN | ON_RETURN)
1299   4              {
1300   5                cache = &sub_cache2;
1301   5              }
1302   4              else
1303   4                cache = &main_cache;
1304   4              if(tick_20ms)
1305   4              {
1306   5                tick_20ms = 0;
1307   5                ClearCache(cache);
1308   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1309   5                ShowString(16, 0, SETTING_MENU[index - pointer], cache, FONT8X16, NO_INVERSED, 0);
1310   5                ShowString(16, 2, SETTING_MENU[index - pointer + 1], cache, FONT8X16, NO_INVERSED, 0);
1311   5                ShowString(16, 4, SETTING_MENU[index - pointer + 2], cache, FONT8X16, NO_INVERSED, 0);
1312   5                ShowString(16, 6, SETTING_MENU[index - pointer + 3], cache, FONT8X16, NO_INVERSED, 1);
1313   5                if(ON_OPEN)
1314   5                {
1315   6                  ScreenPushAnimation(sub_cache2, LEFT);
1316   6                  ON_OPEN = 0;
1317   6                }
1318   5                else if(ON_RETURN)
1319   5                {
1320   6                  ScreenPushAnimation(sub_cache2, RIGHT);
1321   6                  ON_RETURN = 0;
1322   6                } 
1323   5              }
1324   4              if(Trg != 0)
1325   4              {
1326   5                switch(Trg)
1327   5                {
1328   6                  case KEY1:
1329   6                  {
1330   7                    ON_CLOSE = 1;
1331   7                    break;
1332   7                  }
1333   6                  case KEY2:
1334   6                  {
1335   7                    index--;
1336   7                    if(--pointer < 0)
1337   7                    {
1338   8                      pointer = 0;
1339   8                      if(index != -1)
1340   8                      {
1341   9                        ClearCache(sub_cache2);
1342   9                        ShowString(16, 6, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1343   9                        ScreeRollDown(sub_cache2, 16);
1344   9                      }
1345   8                      else
1346   8                        index = 0;
1347   8                    }
1348   7                    break;
1349   7                  } 
1350   6                  case KEY3:
1351   6                  {
1352   7                    index++;
1353   7                    if(++pointer == 4)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 23  

1354   7                    {
1355   8                      pointer = 3;
1356   8                      if(index != MENU_MAX_ROW)
1357   8                      {
1358   9                        ClearCache(sub_cache2);
1359   9                        ShowString(16, 0, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1360   9                        ScreeRollUp(sub_cache2, 16);
1361   9                      }
1362   8                      else
1363   8                        index = MENU_MAX_ROW - 1;
1364   8                    }
1365   7                    break;
1366   7                  }
1367   6                  case DOUBLE_TAP:
1368   6                  {
1369   7                    mode = index;
1370   7                    ON_OPEN = 1;
1371   7                    break;
1372   7                  }
1373   6                }
1374   5                Trg = 0;
1375   5              }
1376   4              if(ON_CLOSE)
1377   4              {
1378   5                ON_CLOSE = 0;
1379   5                func_num = MENU;
1380   5                ON_RETURN = 1;
1381   5              }
1382   4            }
1383   3            else if(mode == 0)  //设置时间  
1384   3            {
1385   4              static char pointer = 0;
1386   4              static char set_index = 0;
1387   4              if(ON_OPEN)
1388   4              {
1389   5                ON_OPEN = 0;
1390   5                PCF8563ReadTime(&RTC);
1391   5                ClearCache(sub_cache2);
1392   5                ShowString(0, 0, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1393   5                sprintf(str, "%2d:%2d:%2d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1394   5                ShowString(16, 0, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1395   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1396   5                ShowString(16, 2, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1397   5                ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], sub_cache2, FONT6X8, NO_INVERSED, 0);
1398   5                ScreenPushAnimation(sub_cache2, LEFT);
1399   5              }
1400   4              if(tick_20ms)
1401   4              {
1402   5                tick_20ms = 0;
1403   5                ClearCache(main_cache);
1404   5                if(set_index == 0)
1405   5                  PCF8563ReadTime(&RTC);
1406   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1407   5                sprintf(str, "%02d:%02d:%02d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1408   5                ShowString(16, 0, str, main_cache, FONT8X16, NO_INVERSED, 0);
1409   5                if(pointer == 0 && set_index != 0)
1410   5                {
1411   6                  if(set_index == 1)
1412   6                  {
1413   7                    sprintf(str, "%02d", (int)RTC.hour);
1414   7                    ShowString(16, 0, str, main_cache, FONT8X16, INVERSED, 0);
1415   7                  }
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 24  

1416   6                  else if(set_index == 2)
1417   6                  {
1418   7                    sprintf(str, "%02d", (int)RTC.minute);
1419   7                    ShowString(40, 0, str, main_cache, FONT8X16, INVERSED, 0);
1420   7                  }
1421   6                  else if(set_index == 3)
1422   6                  {
1423   7                    sprintf(str, "%02d", (int)RTC.second);
1424   7                    ShowString(64, 0, str, main_cache, FONT8X16, INVERSED, 0);
1425   7                  }
1426   6                }
1427   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1428   5                ShowString(16, 2, str, main_cache, FONT8X16, NO_INVERSED, 0);
1429   5                if(pointer == 1 && set_index != 0)
1430   5                {
1431   6                  if(set_index == 1)
1432   6                  {
1433   7                    sprintf(str, "%4d", (int)RTC.year);
1434   7                    ShowString(16, 2, str, main_cache, FONT8X16, INVERSED, 0);
1435   7                  }
1436   6                  else if(set_index == 2)
1437   6                  {
1438   7                    sprintf(str, "%2d", (int)RTC.month);
1439   7                    ShowString(56, 2, str, main_cache, FONT8X16, INVERSED, 0);
1440   7                  }
1441   6                  else if(set_index == 3)
1442   6                  {
1443   7                    sprintf(str, "%2d", (int)RTC.day);
1444   7                    ShowString(80, 2, str, main_cache, FONT8X16, INVERSED, 0);
1445   7                  }
1446   6                }
1447   5                if(pointer == 2 && set_index != 0)
1448   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, INVERSED, 1);
1449   5                else
1450   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, NO_INVERSED, 1);
1451   5              }
1452   4              if(Trg != 0)
1453   4              {
1454   5                switch(Trg)
1455   5                {
1456   6                  case KEY1:
1457   6                  {
1458   7                    if(set_index != 0)
1459   7                    {
1460   8                      set_index = 0;
1461   8                      PCF8563WriteTime(RTC.hour, RTC.minute, RTC.second);
1462   8                      PCF8563WriteDate(RTC.year, RTC.month, RTC.day, RTC.weekday);
1463   8                    }
1464   7                    else
1465   7                      ON_CLOSE = 1;
1466   7                    break;
1467   7                  }
1468   6                  case KEY2:
1469   6                  {
1470   7                    if(set_index == 0)
1471   7                    {
1472   8                      if(--pointer < 0)
1473   8                        pointer = 2;
1474   8                    }
1475   7                    else
1476   7                    {
1477   8                      if(pointer == 0)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 25  

1478   8                      {
1479   9                        if(set_index == 1)
1480   9                        {
1481  10                          if(++RTC.hour == 24)
1482  10                            RTC.hour = 0;
1483  10                        }
1484   9                        else if(set_index == 2)
1485   9                        {
1486  10                          if(++RTC.minute == 60)
1487  10                            RTC.minute = 0;
1488  10                        }
1489   9                        else if(set_index == 3)
1490   9                        {
1491  10                          if(++RTC.second == 60)
1492  10                            RTC.second = 0;
1493  10                        }
1494   9                      }
1495   8                      else if(pointer == 1)
1496   8                      {
1497   9                        if(set_index == 1)
1498   9                        {
1499  10                          if(++RTC.year == 2100)
1500  10                            RTC.year = 2000;
1501  10                        }
1502   9                        else if(set_index == 2)
1503   9                        {
1504  10                          if(++RTC.month == 13)
1505  10                            RTC.month = 1;
1506  10                        }
1507   9                        else if(set_index == 3)
1508   9                        {
1509  10                          if(++RTC.day == 32)
1510  10                            RTC.day = 1;
1511  10                        }
1512   9                      }
1513   8                      else if(pointer == 2)
1514   8                      {
1515   9                        if(set_index == 1)
1516   9                          if(++RTC.weekday == 8)
1517   9                            RTC.weekday = 1;
1518   9                      }
1519   8                    }
1520   7                    break;
1521   7                  }
1522   6                  case KEY3:
1523   6                  {
1524   7                    if(set_index == 0)
1525   7                    {
1526   8                      if(++pointer == 3)
1527   8                        pointer = 0;
1528   8                    }
1529   7                    else
1530   7                    {
1531   8                      if(pointer == 0)
1532   8                      {
1533   9                        if(set_index == 1)
1534   9                        {
1535  10                          if(--RTC.hour == 255)
1536  10                            RTC.hour = 23;
1537  10                        }
1538   9                        else if(set_index == 2)
1539   9                        {
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 26  

1540  10                          if(--RTC.minute == 255)
1541  10                            RTC.minute = 59;
1542  10                        }
1543   9                        else if(set_index == 3)
1544   9                        {
1545  10                          if(--RTC.second == 255)
1546  10                            RTC.second = 59;
1547  10                        }
1548   9                      }
1549   8                      else if(pointer == 1)
1550   8                      {
1551   9                        if(set_index == 1)
1552   9                        {
1553  10                          if(--RTC.year == 1999)
1554  10                            RTC.year = 2099;
1555  10                        }
1556   9                        else if(set_index == 2)
1557   9                        {
1558  10                          if(--RTC.month == 255)
1559  10                            RTC.month = 12;
1560  10                        }
1561   9                        else if(set_index == 3)
1562   9                        {
1563  10                          if(--RTC.day == 255)
1564  10                            RTC.day = 31;
1565  10                        }
1566   9                      }
1567   8                      else if(pointer == 2)
1568   8                      {
1569   9                        if(set_index == 1)
1570   9                          if(--RTC.weekday == 0)
1571   9                            RTC.weekday = 7;
1572   9                      }
1573   8                    }
1574   7                    break;
1575   7                  }
1576   6                  case DOUBLE_TAP:
1577   6                  {
1578   7                    if(pointer < 2)
1579   7                    {
1580   8                      if(++set_index == 4)
1581   8                        set_index = 1;
1582   8                    }
1583   7                    else if(pointer == 2)
1584   7                    {
1585   8                      if(++set_index == 2)
1586   8                        set_index = 1;
1587   8                    }
1588   7                    break;
1589   7                  }
1590   6                }
1591   5                Trg = 0;
1592   5              }
1593   4              if(ON_CLOSE)
1594   4              {
1595   5                ON_CLOSE = 0;
1596   5                set_index = 0;
1597   5                pointer = 0;
1598   5                mode = -1;
1599   5                ON_RETURN = 1;
1600   5              }
1601   4            }
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 27  

1602   3            else if(mode == 1)  //设置闹钟
1603   3            {
1604   4              static unsigned char pointer = 0;
1605   4              static unsigned char set_index = 0;
1606   4              if(ON_OPEN)
1607   4              {
1608   5                ON_OPEN = 0;
1609   5                ClearCache(sub_cache2);
1610   5                ShowString(16, 0, "Alarm:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1611   5                ShowString(0, 1, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1612   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1613   5                ShowString(16, 1, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1614   5                ShowString(16, 3, "Mode:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1615   5                ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], sub_cache2, FONT8X16, NO_INVERSED, 0);
1616   5                ScreenPushAnimation(sub_cache2, LEFT);
1617   5              }
1618   4              if(tick_20ms)
1619   4              {
1620   5                tick_20ms = 0;
1621   5                ClearCache(main_cache);
1622   5                ShowString(0, 1 + pointer * 3, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1623   5                ShowString(16, 0, "Alarm:", main_cache, FONT6X8, NO_INVERSED, 0);
1624   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1625   5                ShowString(16, 1, str, main_cache, FONT8X16, NO_INVERSED, 0);
1626   5                if(pointer == 0 && set_index != 0)
1627   5                {
1628   6                  if(set_index == 1)
1629   6                  {
1630   7                    sprintf(str, "%02d", (int)config.alarm_hour);
1631   7                    ShowString(16, 1, str, main_cache, FONT8X16, INVERSED, 0);
1632   7                  }
1633   6                  else if(set_index == 2)
1634   6                  {
1635   7                    sprintf(str, "%02d", (int)config.alarm_min);
1636   7                    ShowString(40, 1, str, main_cache, FONT8X16, INVERSED, 0);
1637   7                  }
1638   6                }
1639   5                ShowString(16, 3, "Mode:", main_cache, FONT6X8, NO_INVERSED, 0);
1640   5                if(pointer == 1 && set_index != 0)
1641   5                {
1642   6                  
1643   6                  if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1644   6                  {
1645   7                    sprintf(str, "%02d", (int)config.alarm_day);
1646   7                    ShowString(16, 6, str, main_cache, FONT8X16, set_index==1?NO_INVERSED:INVERSED, 0);
1647   7                  }
1648   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, INVERSED, 1); 
1649   6                }
1650   5                else
1651   5                {
1652   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, NO_INVERSED, 1);            
1653   6                }
1654   5              }
1655   4              if(Trg != 0)
1656   4              {
1657   5                switch(Trg)
1658   5                {
1659   6                  case KEY1:
1660   6                  {
1661   7                    if(set_index != 0)
1662   7                      set_index = 0;
1663   7                    else
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 28  

1664   7                      ON_CLOSE = 1;
1665   7                    break;
1666   7                  }
1667   6                  case KEY2:
1668   6                  {
1669   7                    if(set_index == 0)
1670   7                    {
1671   8                      if(++pointer == 2)
1672   8                        pointer = 0;
1673   8                    }
1674   7                    else
1675   7                    {
1676   8                      if(pointer == 0)
1677   8                      {
1678   9                        if(set_index == 1)
1679   9                        {
1680  10                          if(++config.alarm_hour == 24)
1681  10                            config.alarm_hour = 0;
1682  10                        }
1683   9                        else if(set_index == 2)
1684   9                        {
1685  10                          if(++config.alarm_min == 60)
1686  10                          config.alarm_min = 0;
1687  10                        }
1688   9                      }
1689   8                      else if(pointer == 1)
1690   8                      {
1691   9                        if(set_index == 1)
1692   9                        {
1693  10                          if(++config.alarm_mode == ALARM_MODE_NUM)
1694  10                            config.alarm_mode = 0;
1695  10                        }
1696   9                        else if(set_index == 2)
1697   9                        {
1698  10                          if(++config.alarm_day == 32)
1699  10                          {
1700  11                            config.alarm_day = 1;
1701  11                          }
1702  10                        }
1703   9                      }
1704   8                    }
1705   7                    break;
1706   7                  } 
1707   6                  case KEY3:
1708   6                  {
1709   7                    if(set_index == 0)
1710   7                    {
1711   8                      if(--pointer == 255)
1712   8                        pointer = 1;
1713   8                    }
1714   7                    else 
1715   7                    {
1716   8                      if(pointer == 0)
1717   8                      {
1718   9                        if(set_index == 1)
1719   9                        {
1720  10                          if(--config.alarm_hour == 255)
1721  10                            config.alarm_hour = 23;
1722  10                        }
1723   9                        else if(set_index == 2)
1724   9                        {
1725  10                          if(--config.alarm_min == 255)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 29  

1726  10                            config.alarm_min = 59;
1727  10                        }
1728   9                      }
1729   8                      else if(pointer == 1)
1730   8                      {
1731   9                        if(set_index == 1)
1732   9                        {
1733  10                          if(--config.alarm_mode == 255)
1734  10                            config.alarm_mode = ALARM_MODE_NUM - 1;
1735  10                        }
1736   9                        else if(set_index == 2)
1737   9                        {
1738  10                          if(--config.alarm_day == 0)
1739  10                          {
1740  11                            config.alarm_day = 31;
1741  11                          }
1742  10                        }
1743   9                      }
1744   8                    }
1745   7                    break;
1746   7                  }
1747   6                  case DOUBLE_TAP:
1748   6                  {
1749   7                    if(set_index == 0)
1750   7                      set_index ++;
1751   7                    else
1752   7                    {
1753   8                      if(pointer == 0)
1754   8                      {
1755   9                        if(++set_index == 3)
1756   9                          set_index = 1;
1757   9                      }
1758   8                      else if(pointer == 1)
1759   8                      {
1760   9                        if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1761   9                        {
1762  10                          if(++set_index == 3)
1763  10                          set_index = 1;
1764  10                        }
1765   9                      }
1766   8                    }
1767   7                    break;
1768   7                  }
1769   6                }
1770   5                Trg = 0;
1771   5              }
1772   4              if(ON_CLOSE)
1773   4              {
1774   5                ON_CLOSE = 0;
1775   5                set_index = 0;
1776   5                pointer = 0;
1777   5                if(config.alarm_mode != ALARM_DISABLE)
1778   5                {
1779   6                  if(config.alarm_mode == ALARM_WORKDAY)
1780   6                  {
1781   7                    PCF8563ReadTime(&RTC);
1782   7                    if(RTC.weekday > 5)
1783   7                      config.alarm_weekday = 1;
1784   7                    else
1785   7                    {
1786   8                      if((config.alarm_hour > RTC.hour) && (config.alarm_min > RTC.minute))
1787   8                        config.alarm_weekday = RTC.weekday;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 30  

1788   8                      else
1789   8                      {
1790   9                        if(RTC.weekday != 5)
1791   9                          config.alarm_weekday = RTC.weekday;
1792   9                        else
1793   9                          config.alarm_weekday = RTC.weekday + 1;
1794   9                      }
1795   8                    }
1796   7                  }
1797   6                  PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.
             -alarm_mode);
1798   6                }
1799   5                else
1800   5                  PCF8563DisableAlarm();
1801   5                EEPROMWriteConfiguration(&config);
1802   5                mode = -1;
1803   5                ON_RETURN = 1;
1804   5              }
1805   4            }
1806   3            else if(mode == 2)  //设置亮度
1807   3            {
1808   4              static char temp;
1809   4              //unsigned char *cache;
1810   4              if(ON_OPEN)
1811   4              {
1812   5                ON_OPEN = 0;
1813   5                temp = config.screen_brightness / 50;
1814   5                ClearCache(sub_cache2);
1815   5                ShowString(0, 0, "Set the contrast ratio of the screen.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1816   5                sprintf(str, "%d", (int)temp);
1817   5                ShowString(56, 3, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1818   5                ScreenPushAnimation(sub_cache2, LEFT);
1819   5              }
1820   4              if(tick_20ms)
1821   4              {
1822   5                tick_20ms = 0;  
1823   5                ClearCache(main_cache);
1824   5                ShowString(0, 0, "Set the contrast ratio of the screen.", main_cache, FONT6X8, NO_INVERSED, 0);
1825   5                sprintf(str, "%d", (int)temp);
1826   5                ShowString(56, 3, str, main_cache, FONT8X16, NO_INVERSED, 1);
1827   5              }
1828   4              if(Trg != 0)
1829   4              {
1830   5                switch(Trg)
1831   5                {
1832   6                  case 0x01:
1833   6                  {
1834   7                    ON_CLOSE = 1;
1835   7                    break;
1836   7                  }
1837   6                  case 0x02:
1838   6                  {
1839   7                    if(++temp == 6)
1840   7                      temp = 5;
1841   7                    config.screen_brightness = temp * 50 + 1;
1842   7                    ScreenSetBrightness(config.screen_brightness);
1843   7                    break;
1844   7                  } 
1845   6                  case 0x04:
1846   6                  {
1847   7                    if(--temp < 0)
1848   7                      temp = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 31  

1849   7                    config.screen_brightness = temp * 50 + 1;
1850   7                    ScreenSetBrightness(config.screen_brightness);
1851   7                    break;
1852   7                  }
1853   6                  case 0x08:
1854   6                    break;
1855   6                }
1856   5                Trg = 0;
1857   5              }
1858   4              if(ON_CLOSE)
1859   4              {
1860   5                ON_CLOSE = 0;
1861   5                EEPROMWriteConfiguration(&config);
1862   5                mode = -1;
1863   5                ON_RETURN = 1;
1864   5              }
1865   4            }
1866   3            else if(mode == 3)  //设置自动息屏时间
1867   3            {
1868   4              static int temp;
1869   4              if(ON_OPEN)
1870   4              {
1871   5                ON_OPEN = 0;
1872   5                temp = config.t_inactive_max;
1873   5                ClearCache(sub_cache2);
1874   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1875   5                sprintf(str, "%d", temp);
1876   5                ShowString(56, 5, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1877   5                ShowString(72, 6, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1878   5                ScreenPushAnimation(sub_cache2, LEFT);
1879   5              }
1880   4              if(tick_20ms)
1881   4              {
1882   5                tick_20ms = 0;
1883   5                ClearCache(main_cache);
1884   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", main_cache, FONT6X8, NO_INVERSED, 0);
1885   5                sprintf(str, "%d", temp);
1886   5                ShowString(56, 5, str, main_cache, FONT8X16, NO_INVERSED, 0);
1887   5                ShowString(72, 6, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1888   5              }
1889   4              if(Trg != 0)
1890   4              {
1891   5                switch(Trg)
1892   5                {
1893   6                  case KEY1:
1894   6                  {
1895   7                    ON_CLOSE = 1;
1896   7                    break;
1897   7                  }
1898   6                  case KEY2:
1899   6                  {
1900   7                    if(++temp == 100)
1901   7                      temp = 99;
1902   7                    break;
1903   7                  } 
1904   6                  case KEY3:
1905   6                  {
1906   7                    if(--temp < 0)
1907   7                      temp = 0;
1908   7                    break;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 32  

1909   7                  }
1910   6                }
1911   5                Trg = 0;
1912   5              }
1913   4              if(ON_CLOSE)
1914   4              {
1915   5                ON_CLOSE = 0;
1916   5                config.t_inactive_max = temp;
1917   5                EEPROMWriteConfiguration(&config);
1918   5                mode = -1;
1919   5                ON_RETURN = 1;
1920   5              }
1921   4            }
1922   3            else if(mode == 4)  //设置自动关机时间
1923   3            {
1924   4              static int temp;
1925   4              if(ON_OPEN)
1926   4              {
1927   5                ON_OPEN = 0;
1928   5                temp = config.t_sleep_max;
1929   5                ClearCache(sub_cache2);
1930   5                ShowString(0, 0, "The time which mcu stay active for without any operation before power-down,when set
             - to 0,the mcu will never power down.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1931   5                sprintf(str, "%d", temp);
1932   5                ShowString(56, 6, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1933   5                ShowString(72, 7, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1934   5                ScreenPushAnimation(sub_cache2, LEFT);
1935   5              }
1936   4              if(tick_20ms)
1937   4              {
1938   5                tick_20ms = 0;
1939   5                ClearCache(main_cache);
1940   5                ShowString(0, 0, "The time which mcu stay active for before without any operation power-down,when set
             - to 0,the mcu will never power down.", main_cache, FONT6X8, NO_INVERSED, 0);
1941   5                sprintf(str, "%d", temp);
1942   5                ShowString(56, 6, str, main_cache, FONT8X16, NO_INVERSED, 0);
1943   5                ShowString(72, 7, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1944   5              }
1945   4              if(Trg != 0)
1946   4              {
1947   5                switch(Trg)
1948   5                {
1949   6                  case 0x01:
1950   6                  {
1951   7                    ON_CLOSE = 1;
1952   7                    break;
1953   7                  }
1954   6                  case 0x02:
1955   6                  {
1956   7                    if(++temp == 100)
1957   7                      temp = 99;
1958   7                    break;
1959   7                  } 
1960   6                  case 0x04:
1961   6                  {
1962   7                    if(--temp < 0)
1963   7                      temp = 0;
1964   7                    break;
1965   7                  }
1966   6                }
1967   5                Trg = 0;
1968   5              }
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 33  

1969   4              if(ON_CLOSE)
1970   4              {
1971   5                ON_CLOSE = 0;
1972   5                config.t_sleep_max = temp;
1973   5                EEPROMWriteConfiguration(&config);
1974   5                mode = -1;
1975   5                ON_RETURN = 1;
1976   5              }
1977   4            }
1978   3            else if(mode == 5)  //设置屏幕反色
1979   3            {
1980   4              if(ON_OPEN)
1981   4              {
1982   5                ON_OPEN = 0;
1983   5                ClearCache(sub_cache2);
1984   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", sub_cache2, FONT8X16, NO_INVERSED, 0)
             -;
1985   5                ScreenPushAnimation(sub_cache2, LEFT);
1986   5              }
1987   4              if(tick_20ms)
1988   4              {
1989   5                tick_20ms = 0;
1990   5                ClearCache(main_cache);
1991   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", main_cache, FONT8X16, NO_INVERSED, 1)
             -;
1992   5              }
1993   4              if(Trg != 0)
1994   4              {
1995   5                switch(Trg)
1996   5                {
1997   6                  case KEY1:
1998   6                  {
1999   7                    ON_CLOSE = 1;
2000   7                    break;
2001   7                  }
2002   6                  case DOUBLE_TAP:
2003   6                  {
2004   7                    if(config.screen_inverse == INVERSED)
2005   7                      config.screen_inverse = NO_INVERSED;
2006   7                    else
2007   7                      config.screen_inverse = INVERSED;
2008   7                    ScreenSetInverse(config.screen_inverse);
2009   7                    break;
2010   7                  } 
2011   6                }
2012   5                Trg = 0;
2013   5              }
2014   4              if(ON_CLOSE)
2015   4              {
2016   5                ON_CLOSE = 0;
2017   5                EEPROMWriteConfiguration(&config);
2018   5                mode = -1;
2019   5                ON_RETURN = 1;
2020   5              }
2021   4            }
2022   3            else if(mode == 6)  //设置屏幕方向
2023   3            {
2024   4              if(ON_OPEN)
2025   4              {
2026   5                ON_OPEN = 0;
2027   5                ClearCache(sub_cache2);
2028   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", sub_cache2, FONT8X16, NO
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 34  

             -_INVERSED, 0);
2029   5                ScreenPushAnimation(sub_cache2, LEFT);
2030   5              }
2031   4              if(tick_20ms)
2032   4              {
2033   5                tick_20ms = 0;
2034   5                ClearCache(main_cache);
2035   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", main_cache, FONT8X16, NO
             -_INVERSED, 1);
2036   5              }
2037   4              if(Trg != 0)
2038   4              {
2039   5                switch(Trg)
2040   5                {
2041   6                  case KEY1:
2042   6                  {
2043   7                    ON_CLOSE = 1;
2044   7                    break;
2045   7                  }
2046   6                  case DOUBLE_TAP:
2047   6                  {
2048   7                    if(config.screen_direction == UPSIDEDOWN)
2049   7                      config.screen_direction = NORMAL;
2050   7                    else
2051   7                      config.screen_direction = UPSIDEDOWN;
2052   7                    ScreenSetDirection(config.screen_direction);
2053   7                    break;
2054   7                  } 
2055   6                }
2056   5                Trg = 0;
2057   5              }
2058   4              if(ON_CLOSE)
2059   4              {
2060   5                ON_CLOSE = 0;
2061   5                EEPROMWriteConfiguration(&config);
2062   5                mode = -1;
2063   5                ON_RETURN = 1;
2064   5              }
2065   4            }
2066   3            else if(mode == 7)  //设置按键音
2067   3            {
2068   4              if(ON_OPEN)
2069   4              {
2070   5                ON_OPEN = 0;
2071   5                ClearCache(sub_cache2);
2072   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", sub_cache2, FONT8X16, NO_INVERSED,
             - 0);
2073   5                ScreenPushAnimation(sub_cache2, LEFT);
2074   5              }
2075   4              if(tick_20ms)
2076   4              {
2077   5                tick_20ms = 0;
2078   5                ClearCache(main_cache);
2079   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", main_cache, FONT8X16, NO_INVERSED,
             - 1);
2080   5              }
2081   4              if(Trg != 0)
2082   4              {
2083   5                switch(Trg)
2084   5                {
2085   6                  case KEY1:
2086   6                  {
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 35  

2087   7                    ON_CLOSE = 1;
2088   7                    break;
2089   7                  }
2090   6                  case DOUBLE_TAP:
2091   6                  {
2092   7                    if(config.key_sound == ON)
2093   7                      config.key_sound = OFF;
2094   7                    else
2095   7                      config.key_sound = ON;
2096   7                    EnableBuzzer(config.key_sound);
2097   7                    break;
2098   7                  }
2099   6                }
2100   5                Trg = 0;
2101   5              }
2102   4              if(ON_CLOSE)
2103   4              {
2104   5                ON_CLOSE = 0;
2105   5                EEPROMWriteConfiguration(&config);
2106   5                mode = -1;
2107   5                ON_RETURN = 1;
2108   5              }
2109   4            }
2110   3            else if(mode == 8)  //单片机复位
2111   3            {
2112   4              MCUSoftReset();
2113   4            }
2114   3            else if(mode == 9)  //系统掉电
2115   3            {
2116   4              ON_OPEN = 0;
2117   4              active_flag = 0;
2118   4              action = 0;
2119   4              sleep_flag = 0;
2120   4              powerdown_flag = 0;
2121   4              inactive_time = 0;
2122   4              sleep_time = 0;
2123   4              deep_powerdown_flag = 1;
2124   4              mode = -1;
2125   4              func_num = WATCH;
2126   4            }
2127   3          }
2128   2          
2129   2          else if(func_num == SNAKES)       //贪吃蛇  ok
2130   2          {
2131   3            #define PANEL_WIDTH   92
2132   3            #define PANEL_HEIGHT  64
2133   3            #define MAX_SNAKE_SPEED 50
2134   3                
2135   3            unsigned char i = 0;
2136   3            unsigned char str[6];
2137   3            static unsigned char snake_direction = 0;//means sneak direction
2138   3            static unsigned char snake_speed = 10;
2139   3            static unsigned char past_x[256];
2140   3            static unsigned char past_y[256];
2141   3            static unsigned char snake_head_x = 64, snake_head_y = 32, snake_len = 20;
2142   3            static unsigned char test_now = 0, delicious_x= 80,delicious_y = 40;
2143   3            static unsigned char best_score = 0;
2144   3            static bit game_loop = 0;
2145   3            static bit game_over = 0;
2146   3            static bit game_pause = 0;
2147   3          
2148   3            if(ON_OPEN)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 36  

2149   3            {
2150   4              ON_OPEN = 0;
2151   4              ClearCache(sub_cache2);
2152   4              ScreenPushAnimation(sub_cache2, LEFT);//设定该界面左移进入屏幕
2153   4              snake_direction = 0;
2154   4              snake_head_x = 64;
2155   4              snake_head_y = 32;
2156   4              snake_len = 20;
2157   4              game_over = 0;
2158   4              game_pause = 0;
2159   4              for(i = 0; i < snake_len; i++)
2160   4              {
2161   5                past_x[i] = 64;
2162   5                past_y[i] = 32;
2163   5              }
2164   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
2165   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
2166   4            }
2167   3            if(tick_8ms)
2168   3            {
2169   4              tick_8ms = 0;
2170   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
2171   4              IMUupdate(&LSM6DSM);
2172   4            }
2173   3            if(tick_1ms)
2174   3            {
2175   4              static unsigned char t_cnt = 0;
2176   4              tick_1ms = 0;
2177   4              if(++t_cnt == (MAX_SNAKE_SPEED - snake_speed))
2178   4              {
2179   5                t_cnt = 0;
2180   5                game_loop = 1;
2181   5              }
2182   4            }
2183   3            if(game_loop)
2184   3            {
2185   4              game_loop = 0;
2186   4              inactive_time = 0;//to not close screen
2187   4              if(game_pause != 1)
2188   4              {
2189   5                ClearCache(main_cache);
2190   5                for(i = 0; i < PANEL_WIDTH; i++)  //画一个框
2191   5                {
2192   6                  DrawDot(i, 0);
2193   6                  DrawDot(i, PANEL_HEIGHT - 1);
2194   6                }
2195   5                for(i = 0; i < PANEL_HEIGHT; i++)
2196   5                {
2197   6                  DrawDot(0, i);
2198   6                  DrawDot(PANEL_WIDTH - 1, i);
2199   6                }
2200   5                ShowString(PANEL_WIDTH, 1, "Score:", main_cache, FONT6X8, NO_INVERSED, 0);
2201   5                sprintf(str, "%3d", (int)snake_len);
2202   5                ShowString(PANEL_WIDTH, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
2203   5                ShowString(PANEL_WIDTH, 5, "Best:", main_cache, FONT6X8, NO_INVERSED, 0);
2204   5                if(snake_len > best_score)
2205   5                  best_score = snake_len;
2206   5                sprintf(str, "%3d", (int)best_score);
2207   5                ShowString(PANEL_WIDTH, 6, str, main_cache, FONT6X8, NO_INVERSED, 0);
2208   5                if(snake_direction == 0)
2209   5                {
2210   6                  if(LSM6DSM.AngleY > 10)
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 37  

2211   6                    snake_direction = 1;
2212   6                  else if(LSM6DSM.AngleY < -10)
2213   6                    snake_direction = 3;
2214   6                }
2215   5                else if(snake_direction == 1)
2216   5                {
2217   6                  if(LSM6DSM.AngleX > 10)
2218   6                    snake_direction = 0;
2219   6                  else if(LSM6DSM.AngleX < -10)
2220   6                    snake_direction = 2;
2221   6                }
2222   5                else if(snake_direction == 2)
2223   5                {
2224   6                  if(LSM6DSM.AngleY > 10)
2225   6                    snake_direction = 1;
2226   6                  else if(LSM6DSM.AngleY < -10)
2227   6                    snake_direction = 3;
2228   6                }
2229   5                else if(snake_direction == 3)
2230   5                {
2231   6                  if(LSM6DSM.AngleX > 10)
2232   6                    snake_direction = 0;
2233   6                  else if(LSM6DSM.AngleX < -10)
2234   6                    snake_direction = 2;
2235   6                }
2236   5                //这段是按键程序解析后转换为方向以及点位置的程序，
2237   5                //sneak_direction是方向，test_x是头部的x轴值，test_y是头部的y轴值
2238   5                switch(snake_direction)
2239   5                {
2240   6                  case 0:   //右
2241   6                    snake_head_x++;
2242   6                    break;
2243   6                  case 1:   //下
2244   6                    snake_head_y++;
2245   6                    break;
2246   6                  case 2:   //左
2247   6                    snake_head_x--;
2248   6                    break;
2249   6                  case 3:   //上
2250   6                    snake_head_y--;
2251   6                    break;
2252   6                }
2253   5                if(snake_head_x >= PANEL_WIDTH)
2254   5                  snake_head_x = 1;
2255   5                else if(snake_head_x <= 0)
2256   5                  snake_head_x = PANEL_WIDTH - 1;
2257   5                if(snake_head_y >= PANEL_HEIGHT)
2258   5                  snake_head_y = 1;
2259   5                else if(snake_head_y <= 0)
2260   5                  snake_head_y = PANEL_HEIGHT - 1;
2261   5                //检查是否碰到自己的身体
2262   5                for(i = 0; i < snake_len; i++)
2263   5                {
2264   6                  if((snake_head_x == past_x[i]) && (snake_head_y == past_y[i]))
2265   6                  {
2266   7                    game_over = 1;
2267   7                    game_pause = 1;
2268   7                    break;
2269   7                  }
2270   6                }
2271   5                //这段是可以让贪吃蛇有可变长度尾巴的测试程序，test_num就是尾巴的数量，最大50，
2272   5                //程序原理是把每次过去的坐标都记录在数组里面。显示的时候就把过去的点也都显示出来
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 38  

2273   5                test_now++;
2274   5                test_now = test_now % snake_len;
2275   5                past_x[test_now] = snake_head_x;
2276   5                past_y[test_now] = snake_head_y;
2277   5                for(i = 0; i < snake_len; i++)
2278   5                {
2279   6                  DrawDot(past_x[i], past_y[i]);
2280   6                }
2281   5                //这段程序放被吃掉的小东西，设计delicious_x,delicious_y为食物的坐标
2282   5                //吃掉食物以后会放一个新的食物，并且test_num也就是尾巴的数量会大1
2283   5                if((snake_head_x <= delicious_x+1) && (snake_head_y <= delicious_y+1) && (snake_head_x >= delicious_x
             --1) && (snake_head_y>=delicious_y-1))
2284   5                {
2285   6                  snake_len++;
2286   6                  past_x[snake_len - 1] = past_x[snake_len - 2];//解决小白点的问题
2287   6                  past_y[snake_len - 1] = past_y[snake_len - 2];
2288   6                  Bee();
2289   6                  delicious_x = rand() % 92;
2290   6                  if(delicious_x > PANEL_WIDTH - 2)
2291   6                    delicious_x = PANEL_WIDTH - 2;
2292   6                  else if(delicious_x < 2)
2293   6                    delicious_x  = 2;
2294   6                  delicious_y = rand() % 64;
2295   6                  if(delicious_y > PANEL_HEIGHT - 2)
2296   6                    delicious_y = PANEL_HEIGHT - 2;
2297   6                  else if(delicious_y < 2)
2298   6                    delicious_y  = 2;
2299   6                }
2300   5                DrawDot(delicious_x,delicious_y);
2301   5                DrawDot(delicious_x+1,delicious_y);
2302   5                DrawDot(delicious_x-1,delicious_y);
2303   5                DrawDot(delicious_x,delicious_y+1);
2304   5                DrawDot(delicious_x+1,delicious_y+1);
2305   5                DrawDot(delicious_x-1,delicious_y+1);
2306   5                DrawDot(delicious_x,delicious_y-1);
2307   5                DrawDot(delicious_x+1,delicious_y-1);
2308   5                DrawDot(delicious_x-1,delicious_y-1);
2309   5                if(snake_len < 30)
2310   5                  snake_speed = 10;
2311   5                else if(snake_len < 40)
2312   5                  snake_speed = 20;
2313   5                else if(snake_len < 60)
2314   5                  snake_speed = 30;
2315   5                else if(snake_len < 90)
2316   5                  snake_speed = 35;
2317   5                else if(snake_len < 130)
2318   5                  snake_speed = 40;
2319   5                else
2320   5                  snake_speed = 45;
2321   5              }
2322   4              if(game_over)
2323   4              {
2324   5                ShowString(30, 2, "GAME", main_cache, FONT8X16, NO_INVERSED, 0);
2325   5                ShowString(30, 4, "OVER", main_cache, FONT8X16, NO_INVERSED, 0);
2326   5              }
2327   4              ScreenRefreshAll(main_cache);
2328   4            }
2329   3            if(Trg != 0)
2330   3            {
2331   4              switch(Trg)
2332   4              {
2333   5                case KEY1:
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 39  

2334   5                {
2335   6                  ON_CLOSE = 1;
2336   6                  break;
2337   6                }
2338   5                case KEY2:
2339   5                {
2340   6                  if(game_over != 1)
2341   6                  {
2342   7                    if(game_pause)
2343   7                      game_pause = 0;
2344   7                    else
2345   7                      game_pause = 1;
2346   7                  }
2347   6                  break;
2348   6                }
2349   5                case KEY3:
2350   5                {
2351   6                  ON_OPEN = 1;
2352   6                  break;
2353   6                }
2354   5              }
2355   4              Trg = 0;
2356   4            }
2357   3            if(ON_CLOSE)
2358   3            {
2359   4              ON_CLOSE = 0;
2360   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
2361   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
2362   4              func_num = MENU;
2363   4              ON_RETURN = 1;  
2364   4            }
2365   3          }
2366   2          
2367   2          if(action)          //系统在不同状态下对动作的处理
2368   2          {
2369   3            action = 0;
2370   3            if(active_flag)
2371   3              LED1_ON();
2372   3              inactive_time = 0;
2373   3      //      else if(sleep_flag)
2374   3      //      {
2375   3      //        sleep_flag = 0;
2376   3      //        sleep_time = 0;
2377   3      //        active_flag = 1;
2378   3      //        ScreenOnOff(ON);
2379   3      //        screen_on_flag = 1;
2380   3      //      }
2381   3      //      else if(powerdown_flag)
2382   3      //      {
2383   3      //        powerdown_flag = 0;
2384   3      //        active_flag = 1;
2385   3      //        SystemPowerOn();
2386   3      //        ScreenOnOff(ON);
2387   3      //        screen_on_flag = 1;
2388   3      //        ON_OPEN = 1;
2389   3      //      }
2390   3      //      else if(deep_powerdown_flag)
2391   3      //      {
2392   3      //        deep_powerdown_flag = 0;
2393   3      //        active_flag = 1;
2394   3      //        SystemPowerOn();
2395   3      //        DisplayInit(&config);
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 40  

2396   3      //        screen_on_flag = 1;
2397   3      //        SensorInit();
2398   3      //        PW02SetMode(0);
2399   3      //        PCF8563EnableTimer(TIMERCLK_1_60_HZ, 1);  //自动唤醒频率1min一次
2400   3      //        ON_OPEN = 1;
2401   3      //      }
2402   3      //      autowake_cnt = 0;
2403   3          }
2404   2          if(sleep_flag)
2405   2          {
2406   3          
2407   3            if(screen_on_flag)
2408   3            {
2409   4              ScreenOnOff(ON);
2410   4              screen_on_flag = 0;
2411   4            }
2412   3          }   
2413   2      //    if(powerdown_flag)    
2414   2      //    {
2415   2      //      if(ON_CLOSE == 0)
2416   2      //      {
2417   2      //        SystemPowerDown();
2418   2      //      }
2419   2      //    }
2420   2      //    if(deep_powerdown_flag)
2421   2      //    {
2422   2      //      if(ON_CLOSE == 0)
2423   2      //      {
2424   2      //        SystemDeepPowerDown();
2425   2      //      }
2426   2      //      Enable3V3Output(1);
2427   2      //      Delay1ms(10);
2428   2          
2429   2      //    if(alarm_flag)
2430   2      //    {
2431   2      //      sleep_time = 0;     //闹铃被关掉前不会待机
2432   2      //    }
2433   2      //    if(timer_on_flag)
2434   2      //    {
2435   2      //      sleep_time = 0;     //计时器在工作时不会待机
2436   2      //    }
2437   2          if(PCF8563_int_flag)  //PCF8563产生了中断信号
2438   2          {
2439   3            unsigned char pcf8563_int_src;
2440   3            PCF8563_int_flag = 0;
2441   3            pcf8563_int_src = PCF8563ReadIntSrc();  //读PCF8563状态寄存器
2442   3            PCF8563ReadTime(&RTC);
2443   3            
2444   3            if(pcf8563_int_src & ALARM_INT)       //如果是闹钟中断
2445   3            {
2446   4                     
2447   4              PCF8563ClearAlarmFlag();  //清除闹钟中断标志位
2448   4              action = 1;       //产生动作
2449   4              alarm_flag = 1;   //置位闹钟标志位
2450   4              Beebeebee();      //响铃
2451   4              Delay1ms(5);
2452   4              if(config.alarm_mode == ALARM_WORKDAY) 
2453   4              {
2454   5                if(RTC.weekday + 1 > 5)
2455   5                  config.alarm_weekday = 1;
2456   5                else
2457   5                  config.alarm_weekday = RTC.weekday + 1;
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 41  

2458   5                PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.a
             -larm_mode);
2459   5              }
2460   4              else if(config.alarm_mode != ALARM_EVERYDAY)  //如果闹钟模式不是每天都响
2461   4              {
2462   5                config.alarm_mode = ALARM_DISABLE;  //关闭闹钟
2463   5                PCF8563DisableAlarm();              //关闭闹钟
2464   5              }
2465   4              EEPROMWriteConfiguration(&config);
2466   4            }
2467   3            if(pcf8563_int_src & TIMER_INT)       //如果是定时器中断
2468   3            {
2469   4              PCF8563ClearTimerFlag();  //清除定时器中断标志位
2470   4              //PCF8563以固定的时间间隔唤醒MCU
2471   4              //唤醒之后执行以下内容  
2472   4              battery_life = GetBatteryLife();
2473   4              if(active_flag || sleep_flag || powerdown_flag)      
2474   4              {
2475   5                if((RTC.hour == 22) && (RTC.minute == 4))   //22:04,记录当天的步数数据
2476   5                {
2477   6                  char i, j;
2478   6                  for(i = 6; i > 0; i--)
2479   6                  {
2480   7                    for(j = 0; j < 10; j++)
2481   7                    {
2482   8                      config.history_step[i][j] = config.history_step[i - 1][j];
2483   8                    }
2484   7                  }
2485   6                  sprintf(config.history_step[0], "%d/%d %d", (int)RTC.month, (int)RTC.day, (int)LSM6DSMGetCurrentStep
             -());
2486   6                  EEPROMWriteConfiguration(&config);
2487   6                  LSM6DSMResetStepCounter();
2488   6                }
2489   5              }
2490   4              if(powerdown_flag)
2491   4              {
2492   5                if(++autowake_cnt >= 1440)    //1440分钟 = 1天
2493   5                {
2494   6                  autowake_cnt = 0;
2495   6                  powerdown_flag = 0;
2496   6                  PCF8563EnableTimer(TIMERCLK_1_60_HZ, 10); //自动唤醒频率改为10min一次，本来1min一次
2497   6                  deep_powerdown_flag = 1;
2498   6                }
2499   5              }
2500   4            } 
2501   3          
2502   3          }
2503   2            
2504   2        }          
2505   1        
2506   1          
2507   1      
2508   1      } 
*** WARNING C280 IN LINE 302 OF ..\User\main.c: 'x': unreferenced local variable
*** WARNING C280 IN LINE 302 OF ..\User\main.c: 'n': unreferenced local variable
*** WARNING C280 IN LINE 302 OF ..\User\main.c: 'm': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  17460    ----
   CONSTANT SIZE    =   9016    ----
   XDATA SIZE       =    862     138
C51 COMPILER V9.52.0.0   MAIN                                                              08/02/2021 23:49:13 PAGE 42  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
