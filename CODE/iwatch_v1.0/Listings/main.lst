C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Objects\main.obj
COMPILER INVOKED BY: E:\install_files\keil\C51\BIN\C51.EXE ..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\
                    -System;..\User\Sensor;..\User\Rtc;..\User\Radio;..\User\Oled;..\User\Bluetooth;..\User) DEBUG OBJECTEXTEND PRINT(..\List
                    -ings\main.lst) TABS(2) OBJECT(..\Objects\main.obj)

line level    source

   1          #include "Sys.h"
   2          #include "bmp.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "stdlib.h"
   6          #include "string.h"
   7          #include "math.h"
   8          #include "Delay.h"
   9          #include "PowerManage.h"
  10          #include "Buzzer.h"
  11          #include "Display.h"
  12          #include "PW02.h"
*** WARNING C318 IN LINE 12 OF ..\User\main.c: can't open file 'PW02.h'
  13          #include "PCF8563.h"
*** WARNING C318 IN LINE 13 OF ..\User\main.c: can't open file 'PCF8563.h'
  14          #include "BME280.h"                  
*** WARNING C318 IN LINE 14 OF ..\User\main.c: can't open file 'BME280.h'
  15          #include "HMC5883L.h"                 
*** WARNING C318 IN LINE 15 OF ..\User\main.c: can't open file 'HMC5883L.h'
  16          #include "RDA5807M.h"
*** WARNING C318 IN LINE 16 OF ..\User\main.c: can't open file 'RDA5807M.h'
  17          #include "LSM6DSM.h"
*** WARNING C318 IN LINE 17 OF ..\User\main.c: can't open file 'LSM6DSM.h'
  18          #include "Ellipsoid fitting.h"
*** WARNING C318 IN LINE 18 OF ..\User\main.c: can't open file 'Ellipsoid fitting.h'
  19          
  20          
  21          
  22          
  23          /***********************状态机相关变量*********************/
  24          enum function func_num = WATCH;    //功能号
  25          char func_index;               //功能索引
  26          bit ON_OPEN = 0;
  27          bit ON_CLOSE = 0;
  28          bit ON_RETURN = 0;
  29          /********************************************************/
  30          /************************时基信号************************/
  31          bit tick_1ms = 0;             //1000Hz
  32          bit tick_8ms = 0;             //125hz
  33          bit tick_20ms = 0;            //50hz
  34          
  35          /*************************工作状态相关变量*******************************/
  36          bit action = 0;             //动态标志位
  37          bit active_flag =1;       //活动标志位
  38          bit sleep_flag = 0;         //睡眠标志位
  39          bit powerdown_flag = 0;     //掉电标志位
  40          bit deep_powerdown_flag = 0;    //深度掉电标志位
  41          unsigned int inactive_time =0;  //自动息屏的时间
  42          unsigned int sleep_time = 0;    //自动待机时间
  43          unsigned int autowake_cnt = 0;  //自动唤醒的次数
  44          bit screen_on_flag = 1;     //屏幕状态标志位
  45          bit PCF8563_int_flag = 0;   //pcf8563中断产生标志位
  46          bit alarm_flag = 0;         //闹铃标志位
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 2   

  47          bit radio_on_flag = 0;      //收音机工作标志位
  48          bit timer_on_flag = 0;      //计时器工作标志位
  49          /*************************按键相关变量*********************/
  50          unsigned char Trg = 0;      //按键触发值
  51          unsigned char Cont = 0;     //按键持续值
  52          /*************************显示缓存*******************************/
  53          extern unsigned char xdata main_cache[];
  54          extern unsigned char xdata sub_cache1[];
  55          extern unsigned char xdata sub_cache2[];          
  56          
  57          struct sys_config config;   //设置信息结构体
  58          struct pcf8563_time RTC;    //时间信息结构体
  59          struct bme280_data BME280;  //bme280数据结构体
  60          struct lsm6dsm_data LSM6DSM;//LSM6DSM 数据结构体
  61          struct cal_data magnet_cal_data;  //磁力计叫做数据结构体
  62          float battery_life;         //电池电量
  63          unsigned int  timer_cnt = 0;//定时器0溢出次数
  64          
  65          
  66          void KeyScan(void)
  67          {
  68   1        unsigned char dat = 0x00;
  69   1        if(K1 == 0)
  70   1          dat |= KEY1;
  71   1        if(K2 == 0)
  72   1          dat |= KEY2;
  73   1        if(K3 ==0)
  74   1          dat |= KEY3;
  75   1        Trg = dat&(dat^Cont);
  76   1        Cont = dat;
  77   1      }
  78          
  79          void TM3_Ist()  interrupt 19 using 1    //  mcu定时器中断
  80          {
  81   1        static unsigned int t_count = 0;
  82   1        static unsigned int t_key_press =0; 
  83   1        AUXINTIF &= ~T3IF;                    //清除中断标志位
  84   1        if((K1 == 0) && (K2 == 0) && (K3 == 0))
  85   1        {
  86   2          while ((K1 == 0) ||(K2 == 0) ||(K3 == 0) ); //三个按键均抬起
  87   2            MCUSoftReset();                         //软复位MCU
  88   2        }
  89   1          if(t_count % 50 == 0)
  90   1        {
  91   2          KeyScan();
  92   2          if(Trg)
  93   2          {
  94   3            Bee();
  95   3            action = 1;
  96   3            if(sleep_flag || powerdown_flag || alarm_flag)
  97   3            {
  98   4              Trg = 0;
  99   4              if(alarm_flag)
 100   4              {
 101   5                alarm_flag = 0;
 102   5                LED(OFF);
 103   5              }
 104   4            }
 105   3          }
 106   2          if(Cont)
 107   2          {
 108   3            if(++t_key_press > 10)  //判断是否长按
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 3   

 109   3              Trg = Cont;           //重复触发
 110   3          }
 111   2          else
 112   2            t_key_press = 0;
 113   2        }
 114   1        tick_1ms = 1;
 115   1        if(t_count % 8 == 0)
 116   1          tick_8ms = 1;
 117   1        if(t_count % 20 == 0)
 118   1          tick_20ms = 1;
 119   1        if(++t_count == 1000)
 120   1        {
 121   2          t_count = 0;
 122   2          if(active_flag)
 123   2          {
 124   3            if(++inactive_time == config.t_inactive_max)
 125   3            {
 126   4              active_flag = 0;
 127   4              inactive_time = 0;
 128   4              sleep_flag = 1;
 129   4            }
 130   3          }
 131   2          if(sleep_flag)
 132   2          {
 133   3            if(++sleep_time == config.t_sleep_max)
 134   3            {
 135   4              sleep_flag = 0;
 136   4              sleep_time = 0;
 137   4              powerdown_flag = 1;
 138   4              ON_CLOSE = 1;
 139   4            }
 140   3          }
 141   2        }
 142   1      }
 143          
 144          //void INT0_Isr() interrupt 0           //PCF8563中断
 145          //{
 146          //  PCF8563_int_flag = 1;
 147          //}
 148          void TM0_Isr() interrupt 1 using 1    //计数器0溢出中断
 149          {
 150   1        timer_cnt++;
 151   1      }
 152          void INT1_Isr() interrupt 2 using 1   //双击中断
 153          {
 154   1        action = 1;
 155   1        alarm_flag = 0;
 156   1        Bee();
 157   1        if(sleep_flag || powerdown_flag || alarm_flag)
 158   1          Trg = 0;
 159   1        else
 160   1          Trg = DOUBLE_TAP;
 161   1        if(active_flag && func_num == WATCH)
 162   1        {
 163   2          action = 0;
 164   2          active_flag = 0;
 165   2          inactive_time = 0;
 166   2          ScreenOnOff(OFF);
 167   2          sleep_flag = 1;
 168   2        }
 169   1      }
 170          void INT2_Isr() interrupt 10 using 1  //抬腕唤醒中断
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 4   

 171          {
 172   1        action = 1;
 173   1        if(sleep_flag || powerdown_flag)
 174   1        {Trg = 0;}
 175   1        else 
 176   1        {Trg = AWT;}
 177   1      }
 178          void INT3_Isr() interrupt 11          //按键2中断
 179          {
 180   1        action = 1;
 181   1      }
 182          void SensorInit(void)
 183          {
 184   1        unsigned char y = 0;
 185   1        unsigned int time_out = 700;
 186   1        unsigned char error_count = 0;
 187   1        if(BME280Init() == 0)
*** WARNING C206 IN LINE 187 OF ..\User\main.c: 'BME280Init': missing function-prototype
 188   1        {
 189   2          y += ShowString(0, y, "BME280 ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 190   2          error_count++;
 191   2        }
 192   1        if(HMC5883L_Init() == 0)
*** WARNING C206 IN LINE 192 OF ..\User\main.c: 'HMC5883L_Init': missing function-prototype
 193   1        {
 194   2          y += ShowString(0, y, "HMC5883L ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 195   2          error_count++;
 196   2        }
 197   1        if(LSM6DSMInit() == 0)
*** WARNING C206 IN LINE 197 OF ..\User\main.c: 'LSM6DSMInit': missing function-prototype
 198   1        {
 199   2          y += ShowString(0, y, "LSM6DSM ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 200   2          error_count++;
 201   2        }
 202   1        if(RDA5807MInit() == 0)
*** WARNING C206 IN LINE 202 OF ..\User\main.c: 'RDA5807MInit': missing function-prototype
 203   1        {
 204   2          y += ShowString(0, y, "RDA5807M ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 205   2          error_count++;
 206   2        }
 207   1        if(error_count != 0)
 208   1        {
 209   2          while(Trg == 0)
 210   2          {
 211   3            Delay1ms(1);
 212   3            if(--time_out == 0)
 213   3              break;
 214   3          }
 215   2        }
 216   1      }
 217          
 218          
 219          void main()
 220          { 
 221   1        //LED(ON);
 222   1        SysInit();            //系统初始化
 223   1        DisplayInit(&config); //显示初始化     
 224   1      //  PCF8563Init();        //实时时钟初始化        
 225   1      //  SensorInit();         //传感器初始化
 226   1        ClearCache(main_cache); //清空主显存
 227   1        while(1)
 228   1        
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 5   

 229   1        {
 230   2          FeedWatchDog();     //喂看门狗
 231   2          
 232   2        
 233   2        /********
 234   2          if(func_num == WATCH)           //显示表盘
 235   2          {
 236   2            unsigned char x, n, m;
 237   2            unsigned char str[16];
 238   2            if(ON_OPEN)     //进入该功能时执行的内容
 239   2            {
 240   2              ON_OPEN = 0;
 241   2              if(func_index == FIRST_FUNC)
 242   2                ScreenPushAnimation(sub_cache1, DOWN);
 243   2              else if(func_index == LAST_FUNC)
 244   2                ScreenPushAnimation(sub_cache1, UP);
 245   2              func_index = WATCH;
 246   2            }
 247   2            if(ON_RETURN)   //返回该功能时执行的内容
 248   2            {
 249   2              ON_RETURN = 0;
 250   2            }
 251   2            
 252   2            if(tick_20ms)   //在功能里时，每20ms执行一次功能内容
 253   2            {
 254   2              tick_20ms = 0;
 255   2              //显示时间
 256   2              PCF8563ReadTime(&RTC);
 257   2              //printf("%d:%d:%d\n", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
 258   2              DisplayTime(RTC.hour, RTC.minute, RTC.second);
 259   2              //显示小图标
 260   2              ClearCacheArea(0, 0, 35, 8, main_cache);
 261   2              x = 0;
 262   2              BMPToCache(x, 0, 8, 8, BLUETOOTH_SMALL_ICON, main_cache, 0);
 263   2              x += 9;
 264   2              if(timer_on_flag)
 265   2              {
 266   2                BMPToCache(x, 0, 8, 8, TIMER_SMALL_ICON, main_cache, 0);
 267   2                x += 9;
 268   2              }
 269   2              if(config.alarm_mode != ALARM_DISABLE)
 270   2              {
 271   2                BMPToCache(x, 0, 8, 8, CLOCK_SMALL_ICON, main_cache, 0);
 272   2                x += 9;
 273   2              }
 274   2              if(radio_on_flag)
 275   2                BMPToCache(x, 0, 8, 8, RADIO_SMALL_ICON, main_cache, 0);
 276   2              //显示日期，星期
 277   2              ClearCacheArea(0, 7, 128, 8, main_cache);
 278   2              sprintf(str, "%d/%d/%d ", (int)RTC.year, (int)RTC.month, (int)RTC.day);
 279   2              strcat(str, WEEKDAY_IN_STR[RTC.weekday - 1]);
 280   2              ShowString(0, 7, str, main_cache, FONT6X8, NO_INVERSED, 0);
 281   2              //显示电量
 282   2              battery_life = GetBatteryLife();
 283   2              for(n = 0; n < 24; n++)
 284   2                str[n] = BATTERY_LIFE_ICON[n];
 285   2              m = 18 * battery_life;
 286   2              for(n = 2; n < 2 + m; n++)
 287   2                str[n] |= 0x3c;
 288   2              BMPToCache(104, 0, 24, 8, str, main_cache, 0);
 289   2              sprintf(str, "%3d%%", (int)(battery_life * 100));
 290   2              ShowString(78, 0, str, main_cache, FONT6X8, NO_INVERSED, 1);
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 6   

 291   2            }
 292   2            
 293   2            if(Trg != 0)    //在该功能下对按键事件的处理
 294   2            {
 295   2              switch(Trg)
 296   2              {
 297   2                case KEY1:
 298   2                {
 299   2                  func_num = SUB_MENU;
 300   2                  ON_CLOSE = 1;
 301   2                  break;
 302   2                }
 303   2                case KEY2:
 304   2                {
 305   2                  func_index = FIRST_FUNC;
 306   2                  func_num = MENU;
 307   2                  ON_CLOSE = 1;
 308   2                  break;
 309   2                } 
 310   2                case KEY3:
 311   2                {
 312   2                  func_index = LAST_FUNC;
 313   2                  func_num = MENU;
 314   2                  ON_CLOSE = 1;
 315   2                  break;
 316   2                }
 317   2                case KEY13:
 318   2                {
 319   2                  active_flag = 0;
 320   2                  sleep_flag = 0;
 321   2                  powerdown_flag = 0;
 322   2                  inactive_time = 0;
 323   2                  sleep_time = 0;
 324   2                  deep_powerdown_flag = 1;
 325   2                  ON_CLOSE = 1;
 326   2                  break;
 327   2                }
 328   2              }
 329   2              Trg = 0;
 330   2            }
 331   2            if(ON_CLOSE)    //关闭该功能时执行的内容
 332   2            {
 333   2              ON_CLOSE = 0;
 334   2              SaveScreen();
 335   2              ON_OPEN = 1;
 336   2            }
 337   2          }
 338   2          else if(func_num == MENU)       //主菜单    ok
 339   2              {
 340   2            if(ON_OPEN)
 341   2            {
 342   2              ClearCache(sub_cache2);
 343   2              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 344   2              if(func_index == FIRST_FUNC)
 345   2                ScreenPushAnimation(sub_cache2, UP);
 346   2              else
 347   2                ScreenPushAnimation(sub_cache2, DOWN);
 348   2              ON_OPEN = 0;
 349   2            }
 350   2            if(ON_RETURN)
 351   2            {
 352   2              ON_RETURN = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 7   

 353   2              ClearCache(sub_cache2);
 354   2              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 355   2              ScreenPushAnimation(sub_cache2, RIGHT);
 356   2            }
 357   2            if(Trg != 0)
 358   2            {
 359   2              switch(Trg)
 360   2              {
 361   2                case KEY1:
 362   2                {
 363   2                  goto case_AWT;
 364   2                  break;
 365   2                }
 366   2                case KEY2:
 367   2                {
 368   2                  if(++func_index > FUNC_NUM_MAX - 1)
 369   2                  {
 370   2                    func_index = LAST_FUNC;
 371   2                    func_num = WATCH;
 372   2                    ON_CLOSE = 1;
 373   2                  }
 374   2                  else
 375   2                  {
 376   2                    ClearCache(sub_cache2);
 377   2                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 378   2                    ScreenPushAnimation(sub_cache2, UP);
 379   2                  }
 380   2                  break;
 381   2                }
 382   2                case KEY3:
 383   2                {
 384   2                  if(--func_index < 0)
 385   2                  {
 386   2                    func_index = FIRST_FUNC;
 387   2                    func_num = WATCH;
 388   2                    ON_CLOSE = 1;
 389   2                  }
 390   2                  else
 391   2                  {
 392   2                    ClearCache(sub_cache2);
 393   2                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 394   2                    ScreenPushAnimation(sub_cache2, DOWN);
 395   2                  }
 396   2                  break;
 397   2                }
 398   2                case DOUBLE_TAP:
 399   2                {
 400   2                  func_num = func_index;
 401   2                  ON_CLOSE= 1;
 402   2                  break;
 403   2                }
 404   2                case AWT:
 405   2                {
 406   2                  case_AWT:
 407   2                  if(func_index <= (FUNC_NUM_MAX - func_index))
 408   2                  {
 409   2                    while(func_index > 0)
 410   2                    {
 411   2                      func_index --;
 412   2                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 413   2                      ScreenPushAnimation(sub_cache2, DOWN);
 414   2                    }
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 8   

 415   2                  }
 416   2                  else
 417   2                  {
 418   2                    while(func_index < FUNC_NUM_MAX - 1)
 419   2                    {
 420   2                      func_index ++;
 421   2                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 422   2                      ScreenPushAnimation(sub_cache2, UP);
 423   2                    }
 424   2                  }
 425   2                  func_num = WATCH;
 426   2                  ON_CLOSE = 1;
 427   2                  break;
 428   2                }
 429   2              }
 430   2              Trg = 0;
 431   2            }
 432   2            if(ON_CLOSE)
 433   2            {
 434   2              ON_CLOSE = 0;
 435   2              ON_OPEN = 1;
 436   2            }
 437   2          }
 438   2          else if(func_num == SUB_MENU)   //次菜单    ok
 439   2          {
 440   2            
 441   2            char x, y;
 442   2            if(ON_OPEN)
 443   2            {
 444   2              ON_OPEN = 0;
 445   2              ClearCache(sub_cache2);
 446   2              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, sub_cache2, COVER);
 447   2              ScreenPushAnimation(sub_cache2, LEFT);
 448   2              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 449   2              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 450   2              LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 451   2            }
 452   2            if(tick_8ms)        //姿态解算频率：125hz
 453   2            {
 454   2              tick_8ms = 0;
 455   2              LSM6DSMReadGYRAndACC(&LSM6DSM);
 456   2              IMUupdate(&LSM6DSM);
 457   2            }
 458   2            if(tick_20ms)
 459   2            {
 460   2              tick_20ms = 0;
 461   2              LSM6DSM.AngleX -= config.cal_anglex;  //倾角减去偏移
 462   2              LSM6DSM.AngleY -= config.cal_angley;  //倾角减去偏移
 463   2              LSM6DSM.AngleY -= 30;
 464   2              LSM6DSM.AngleX *= 3;      //调整一下横向灵敏度
 465   2              LSM6DSM.AngleY *= 2;      //调整一下纵向灵敏度
 466   2              if(LSM6DSM.AngleX > 63)   //对计算结果进行限幅
 467   2                LSM6DSM.AngleX = 63;
 468   2              else if(LSM6DSM.AngleX < -64)
 469   2                LSM6DSM.AngleX = -64;
 470   2              if(LSM6DSM.AngleY > 31)
 471   2                LSM6DSM.AngleY = 31;
 472   2              else if(LSM6DSM.AngleY < -31)
 473   2                LSM6DSM.AngleY = -31;
 474   2              x = 64 + LSM6DSM.AngleX;
 475   2              y = 32 + LSM6DSM.AngleY;
 476   2              if(x > 96)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 9   

 477   2                x = 96;
 478   2              if(y > 32)
 479   2                y = 32;
 480   2              ClearCache(main_cache);       //清空主缓存
 481   2              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, main_cache, COVER); //画菜单背景到主显存上
 482   2              DrawSelectionFrame(x, y);     //根据xy坐标画选择框到主显存上
 483   2              ScreenRefreshAll(main_cache); //将主显存刷新到OLED屏幕上
 484   2            }
 485   2            if(Cont == 0)
 486   2            {
 487   2              func_index = (enum function)((x + 16) / 32 + ((y + 16) / 32) * 4);
 488   2              func_num = func_index;
 489   2              ON_CLOSE = 1;
 490   2            }
 491   2            if(ON_CLOSE)
 492   2            {
 493   2              ON_CLOSE = 0;
 494   2              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
 495   2              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 496   2              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 497   2              ON_OPEN = 1;
 498   2            }
 499   2          }
 500   2          else if(func_num == STOPWATCH)  //计时器    ok
 501   2          { 
 502   2            unsigned char t = 0, t_x = 0, t_y = 2;
 503   2            static int ms = 0, sec = 0, min = 0;
 504   2            static unsigned char n = 0, x = 0, y = 2;
 505   2            static unsigned char str1[10][11];
 506   2            unsigned char str2[10];
 507   2            if(ON_OPEN)
 508   2            {
 509   2              ON_OPEN = 0;
 510   2              ClearCache(sub_cache2);
 511   2              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 512   2              sec = ms / 100 % 60;
 513   2              min = sec / 60;
 514   2              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 515   2              ShowString(32, 0, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 516   2              if(n != 0)
 517   2              {
 518   2                for(t = 0; t < n; t++)
 519   2                {
 520   2                  if(t == 6)
 521   2                  {
 522   2                    t_x = 64;
 523   2                    t_y = 2;
 524   2                  }
 525   2                  ShowString(t_x, t_y++, str1[t], sub_cache2, FONT6X8, NO_INVERSED, 0);
 526   2                }
 527   2              }
 528   2              ScreenPushAnimation(sub_cache2, LEFT);
 529   2              ClearCache(sub_cache2);
 530   2            }
 531   2            if(tick_1ms)
 532   2            {
 533   2              tick_1ms = 0;
 534   2              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 535   2              sec = ms / 100;
 536   2              min = sec / 60;
 537   2              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 538   2              ShowString(32, 0, str2, main_cache, FONT8X16, NO_INVERSED, 1);
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 10  

 539   2              sleep_time = 0;
 540   2            }
 541   2            if(Trg != 0)
 542   2            {
 543   2              switch(Trg)
 544   2              {
 545   2                case KEY1:
 546   2                {
 547   2                  ON_CLOSE = 1;
 548   2                  break;
 549   2                }
 550   2                case KEY2:
 551   2                {
 552   2                  if(TR0)
 553   2                  {
 554   2                    TR0 = 0;
 555   2                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, DISABLE_CLKOUT);
 556   2                    timer_on_flag = 0;
 557   2                  }
 558   2                  else
 559   2                  {
 560   2                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, ENABLE_CLKOUT);
 561   2                    TR0 = 1;
 562   2                    timer_on_flag = 1;
 563   2                  }
 564   2                  break;
 565   2                }
 566   2                case KEY3:
 567   2                {
 568   2                  timer_cnt = 0;
 569   2                  TH0 = 0;
 570   2                  TL0 = 0;
 571   2                  ms = 0;
 572   2                  sec = 0;
 573   2                  min = 0;
 574   2                  n = 0;
 575   2                  x = 0;
 576   2                  y = 2;
 577   2                  ClearCache(main_cache);
 578   2                  break;
 579   2                }
 580   2                case DOUBLE_TAP:
 581   2                {
 582   2                  if(n < 9 && timer_on_flag == 1)
 583   2                  {
 584   2                    if(n == 6)
 585   2                    {
 586   2                      x = 64;
 587   2                      y = 2;
 588   2                    }
 589   2                    sprintf(str1[n], "%d.%02d:%02d:%02d\0", (int)(n + 1), min, sec % 60, ms % 100);
 590   2                    ShowString(x + 0, y++, str1[n++], main_cache, FONT6X8, NO_INVERSED, 1);
 591   2                  }
 592   2                  break;
 593   2                }
 594   2              }
 595   2              Trg = 0;
 596   2            }
 597   2            if(ON_CLOSE)
 598   2            {
 599   2              ON_CLOSE = 0;
 600   2              func_num = MENU;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 11  

 601   2              ON_RETURN = 1;
 602   2            }
 603   2          }
 604   2          else if(func_num == PEDOMETER)  //计步器    ok
 605   2          {
 606   2            unsigned char n;
 607   2            unsigned int step;
 608   2            unsigned char buf[8];
 609   2            if(ON_OPEN)
 610   2            {
 611   2              ON_OPEN = 0;
 612   2      //        PCF8563ReadTime(&RTC);
 613   2              ClearCache(sub_cache2);
 614   2              ShowString(0, 0, "Today:    History:", sub_cache2, FONT6X8, NO_INVERSED, 0);
 615   2              step = LSM6DSMGetCurrentStep();
 616   2              sprintf(buf, "%d ", step);
 617   2              ShowString(0, 1, buf, sub_cache2, FONT8X16, NO_INVERSED, 0);    
 618   2              ScreenPushAnimation(sub_cache2, LEFT);
 619   2            }
 620   2            if(tick_20ms)
 621   2            {
 622   2              tick_20ms = 0;
 623   2              step = LSM6DSMGetCurrentStep();
 624   2              sprintf(buf, "%d ", step);
 625   2              ShowString(0, 1, buf, main_cache, FONT8X16, NO_INVERSED, 0);
 626   2              for(n = 0; n < 7; n++)
 627   2              {
 628   2                ShowString(64, n + 1, config.history_step[n], main_cache, FONT6X8, NO_INVERSED, 1);
 629   2              }
 630   2            }
 631   2            if(Trg != 0)
 632   2            {
 633   2              switch(Trg)
 634   2              {
 635   2                case KEY1:
 636   2                {
 637   2                  ON_CLOSE = 1;
 638   2                  break;
 639   2                }
 640   2                case KEY2:
 641   2                {
 642   2                  //LSM6DSMResetStepCounter();
 643   2                  break;
 644   2                } 
 645   2              }
 646   2              Trg = 0;
 647   2            }
 648   2            if(ON_CLOSE)
 649   2            {
 650   2              ON_CLOSE = 0;
 651   2              func_num = MENU;
 652   2              ON_RETURN = 1;
 653   2            }
 654   2          }
 655   2          else if(func_num == THPMETER)   //温湿度计  ok
 656   2          {   
 657   2            float altitude;
 658   2            unsigned char str1[10] = {0};
 659   2            if(ON_OPEN)
 660   2            {
 661   2              ON_OPEN = 0;
 662   2              ClearCache(sub_cache2);
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 12  

 663   2              BMPToCache(0, 0, 48, 64, T_H_P_A, sub_cache2, 0);
 664   2              sprintf(str1, "%.1f", BME280.temperature);
 665   2              ShowString(48, 0, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 666   2              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, sub_cache2, 0);
 667   2              sprintf(str1, "%.1f%%", BME280.humidity);
 668   2              ShowString(48, 2, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 669   2              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 670   2              ShowString(48, 4, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 671   2              ScreenPushAnimation(sub_cache2, LEFT);
 672   2              BME280ContinuousMeasurement(MS_125);    //连续测量模式，测量间隔125ms
 673   2            }
 674   2            if(tick_20ms)
 675   2            {
 676   2              tick_20ms = 0;
 677   2              BME280GetSensorData(&BME280);         //读BME280测量数据并显示
 678   2              altitude = 44330.77 * (1 - pow((BME280.pressure / 101500), 0.190263));
 679   2              ClearCache(main_cache);
 680   2              BMPToCache(0, 0, 48, 64, T_H_P_A, main_cache, 0);
 681   2              sprintf(str1, "%.1f", BME280.temperature);
 682   2              ShowString(48, 0, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 683   2              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, main_cache, 0);
 684   2              sprintf(str1, "%.1f %%", BME280.humidity);
 685   2              ShowString(48, 2, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 686   2              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 687   2              ShowString(48, 4, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 688   2              sprintf(str1, "%d m", (int)altitude);
 689   2              ShowString(48, 6, str1, main_cache, FONT8X16, NO_INVERSED, 1);
 690   2            }
 691   2            if(Trg == KEY1)
 692   2            {
 693   2              Trg = 0;
 694   2              ON_CLOSE = 1;
 695   2            }
 696   2            if(ON_CLOSE)
 697   2            {
 698   2              ON_CLOSE = 0;
 699   2              BME280SetMode(SLEEP_MODE);
 700   2              func_num = MENU;
 701   2              ON_RETURN = 1;
 702   2            }
 703   2          }
 704   2          else if(func_num == RADIO)      //收音机    ok
 705   2          {
 706   2            static unsigned char index = 0;
 707   2            static bit searching_flag = 0;
 708   2            static unsigned char search_direction;
 709   2            float temp;
 710   2            unsigned char str2[16];
 711   2            if(ON_OPEN)
 712   2            {
 713   2              ON_OPEN = 0;
 714   2              ClearCache(sub_cache2);
 715   2              ShowString(80, 0, "volume", sub_cache2, FONT8X16, NO_INVERSED, 0);
 716   2              sprintf(str2,"%.1fMHz",config.radio_channel);
 717   2              ShowString(40, 3, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 718   2              ShowString(0, 6, "tune", sub_cache2, FONT8X16, NO_INVERSED, 0);
 719   2              ShowString(80, 6, "search", sub_cache2, FONT8X16, NO_INVERSED, 0);
 720   2              ShowString(0, 0, "close", main_cache, FONT8X16, NO_INVERSED, 0);
 721   2              ScreenPushAnimation(sub_cache2, LEFT);
 722   2              if(radio_on_flag != 1)
 723   2              {
 724   2                RDA5807MPowerUp();
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 13  

 725   2                RDA5807MSetFq(config.radio_channel);
 726   2                if(config.radio_volume > 0x0f)
 727   2                  config.radio_volume = 0;
 728   2                RDA5807MSetVOLUME(config.radio_volume);
 729   2                radio_on_flag = 1;
 730   2              }
 731   2            }
 732   2            if(tick_20ms)
 733   2            {
 734   2              tick_20ms = 0;
 735   2              ClearCache(main_cache);
 736   2              ShowString(80, 0, "volume", main_cache, FONT8X16, index == 0?INVERSED:NO_INVERSED, 0);
 737   2              sprintf(str2,"%.1fMHz", config.radio_channel);
 738   2              ShowString(40, 3, str2, main_cache, FONT8X16, NO_INVERSED, 0);
 739   2              if(searching_flag)
 740   2              {
 741   2                temp = RDA5807MSEEK(search_direction);
 742   2                if(temp == 0)
 743   2                  ShowString(28, 5, "searching...", main_cache, FONT6X8, NO_INVERSED, 0);
 744   2                else
 745   2                {
 746   2                  config.radio_channel = temp;
 747   2                  searching_flag = 0;
 748   2                }
 749   2              }
 750   2              ShowString(80, 6, "search", main_cache, FONT8X16, index == 1?INVERSED:NO_INVERSED, 0);
 751   2              ShowString(0, 6, "tune", main_cache, FONT8X16, index == 2?INVERSED:NO_INVERSED, 0);
 752   2              ShowString(0, 0, "close", main_cache, FONT8X16, index == 3?INVERSED:NO_INVERSED, 1);
 753   2            }
 754   2            if(Trg != 0)
 755   2            {
 756   2              switch(Trg)
 757   2              {
 758   2                case KEY1:
 759   2                {
 760   2                  ON_CLOSE = 1;
 761   2                  break;
 762   2                }
 763   2                case KEY2:
 764   2                {
 765   2                  if(index == 0)
 766   2                  {
 767   2                    if(++config.radio_volume > 0x0f)
 768   2                      config.radio_volume = 0x0f;
 769   2                    RDA5807MSetVOLUME(config.radio_volume);
 770   2                  }
 771   2                  else if(index == 1)
 772   2                  {
 773   2                    search_direction = UPWARD;
 774   2                    searching_flag = 1;
 775   2                  }
 776   2                  else if(index == 2)
 777   2                  {
 778   2                    config.radio_channel += 0.1;
 779   2                    if(config.radio_channel > 108)
 780   2                      config.radio_channel = 87;
 781   2                    RDA5807MSetFq(config.radio_channel);
 782   2                  }
 783   2                  break;
 784   2                } 
 785   2                case KEY3:
 786   2                {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 14  

 787   2                  if(index == 0)
 788   2                  {
 789   2                    if(--config.radio_volume == 255)
 790   2                      config.radio_volume = 0;
 791   2                    RDA5807MSetVOLUME(config.radio_volume);
 792   2                  }
 793   2                  else if(index == 1)
 794   2                  {
 795   2                    search_direction = DOWNWARD;
 796   2                    searching_flag = 1;
 797   2                  }
 798   2                  else if(index == 2)
 799   2                  {
 800   2                    config.radio_channel -= 0.1;
 801   2                    if(config.radio_channel < 87)
 802   2                      config.radio_channel = 108;
 803   2                    RDA5807MSetFq(config.radio_channel);
 804   2                  }
 805   2                  break;
 806   2                }
 807   2                case DOUBLE_TAP:
 808   2                {
 809   2                  if(++index == 4)
 810   2                    index = 0;
 811   2                  break;
 812   2                }
 813   2              }
 814   2              Trg = 0;
 815   2            }
 816   2            if(ON_CLOSE)
 817   2            {
 818   2              ON_CLOSE = 0;
 819   2              if(powerdown_flag == 0 && index == 3)
 820   2              {
 821   2                RDA5807MPowerDown();
 822   2                radio_on_flag = 0;
 823   2                index = 0;  
 824   2                EEPROMWriteConfiguration(&config);
 825   2              }
 826   2              func_num = MENU;
 827   2              ON_RETURN = 1;
 828   2            }
 829   2          }
 830   2          else if(func_num == COMPASS)    //磁力计    ok
 831   2          {
 832   2            //显示角度和指针
 833   2            static char mode = 0;
 834   2            int magnet_data[3] = {0};
 835   2            unsigned char str3[16];
 836   2            if(mode == 0)     
 837   2            {
 838   2              unsigned char n;
 839   2              int angle_from_north;
 840   2              if(ON_OPEN)
 841   2              {
 842   2                ON_OPEN = 0;
 843   2                ClearCache(sub_cache2);
 844   2                sprintf(str3, "%d  ", angle_from_north);
 845   2                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 846   2                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 847   2                ScreenPushAnimation(sub_cache2, LEFT);
 848   2                //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 15  

 849   2                LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 850   2                LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 851   2                HMC5883L_Set_Mode(0);                   //设置连续测量模式
 852   2                HMC5883L_Set_Calibration_Value(config.cal_magnet_x0, config.cal_magnet_y0, config.cal_magnet_z0, 
 853   2                                              config.cal_magnet_ab, config.cal_magnet_ac);  //设置校准参数
 854   2              }
 855   2              if(ON_RETURN)
 856   2              {
 857   2                ON_RETURN = 0;
 858   2                ClearCache(sub_cache2);
 859   2                BMPToCache(16, 2, 32, 16, NESW[n], sub_cache2, COVER);
 860   2                sprintf(str3, "%d  ", angle_from_north);
 861   2                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, COVER);
 862   2                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 863   2                ScreenPushAnimation(sub_cache2, RIGHT);
 864   2              }
 865   2              if(tick_8ms)
 866   2              {
 867   2                tick_8ms = 0; 
 868   2                LSM6DSMReadGYRAndACC(&LSM6DSM);
 869   2                IMUupdate(&LSM6DSM);
 870   2              }
 871   2              if(tick_20ms)
 872   2              {
 873   2                tick_20ms = 0;
 874   2                Read_HMC5883L(magnet_data);
 875   2                angle_from_north = (int)HMC5883L_Get_AngleXY(magnet_data, (int)LSM6DSM.AngleX, (int)LSM6DSM.AngleY);
 876   2                angle_from_north += 90;
 877   2                if(angle_from_north >= 360)
 878   2                  angle_from_north -= 360;
 879   2                n = (angle_from_north + 22.5) / 45;
 880   2                if(n == 8)
 881   2                  n = 0;
 882   2                BMPToCache(16, 2, 32, 16, NESW[n], main_cache, 0);
 883   2                sprintf(str3, "%d  ", angle_from_north);
 884   2                ShowString(24, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 885   2                BMPToCache(64, 0, 64, 64, COMPASS_ICON, main_cache, 0);
 886   2                angle_from_north -= 90;
 887   2                if(angle_from_north < 0)
 888   2                  angle_from_north += 360;
 889   2                DrawArm(95, 31, 18, angle_from_north);
 890   2                ScreenRefreshAll(main_cache);
 891   2              }
 892   2              if(Trg != 0)
 893   2              {
 894   2                switch(Trg)
 895   2                {
 896   2                  case KEY1:
 897   2                  {
 898   2                    ON_CLOSE = 1;
 899   2                    break;
 900   2                  }
 901   2                  case KEY2:
 902   2                  {
 903   2                    mode = 1;
 904   2                    ON_OPEN = 1;
 905   2                    break;
 906   2                  } 
 907   2                }
 908   2                Trg = 0;
 909   2              }
 910   2              if(ON_CLOSE)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 16  

 911   2              {
 912   2                ON_CLOSE = 0;
 913   2                HMC5883L_Set_Mode(2);  //设置睡眠模式
 914   2                LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 915   2                LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 916   2                func_num = MENU;
 917   2                ON_RETURN = 1;
 918   2              }
 919   2            }
 920   2            else if(mode == 1)  //磁力计椭球校准
 921   2            {
 922   2              static int data_cnt = 0;
 923   2              if(ON_OPEN)
 924   2              {
 925   2                ON_OPEN = 0;
 926   2                ClearCache(sub_cache2);
 927   2                sprintf(str3, "x:%d", magnet_data[0]);
 928   2                ShowString(0, 0, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 929   2                sprintf(str3, "y:%d", magnet_data[1]);
 930   2                ShowString(0, 2, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 931   2                sprintf(str3, "z:%d", magnet_data[2]);
 932   2                ShowString(0, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 933   2                ScreenPushAnimation(sub_cache2, LEFT);
 934   2                ResetMatrix();
 935   2                HMC5883L_Set_Calibration_Value(0, 0, 0, 1, 1);  //清除校准参数
 936   2              }
 937   2              if(tick_20ms)
 938   2              {
 939   2                tick_20ms = 0;
 940   2                Read_HMC5883L(magnet_data);
 941   2                CalcData_Input(magnet_data[0], magnet_data[1], magnet_data[2]);
 942   2                sprintf(str3, "x:%d", magnet_data[0]);
 943   2                ShowString(0, 0, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 944   2                sprintf(str3, "y:%d", magnet_data[1]);
 945   2                ShowString(0, 2, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 946   2                sprintf(str3, "z:%d", magnet_data[2]);
 947   2                ShowString(0, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 948   2                sprintf(str3, "data_cnt:%d", data_cnt);
 949   2                ShowString(0, 6, str3, main_cache, FONT8X16, NO_INVERSED, 1);
 950   2                if(++data_cnt == 5000)
 951   2                {
 952   2                  ON_CLOSE = 1;
 953   2                  Bee();
 954   2                }
 955   2              }
 956   2              if(Trg == KEY1)
 957   2              {
 958   2                Trg = 0;
 959   2                ON_CLOSE = 1;
 960   2              }
 961   2              if(ON_CLOSE)
 962   2              {
 963   2                ON_CLOSE = 0;
 964   2                Ellipsoid_fitting_Process(&magnet_cal_data);    //椭球校准算法
 965   2                HMC5883L_Set_Calibration_Value(magnet_cal_data.X0, magnet_cal_data.Y0, magnet_cal_data.Z0, 
 966   2                                              magnet_cal_data.A / magnet_cal_data.B, 
 967   2                                              magnet_cal_data.A / magnet_cal_data.C);//设置校准参数
 968   2                config.cal_magnet_x0 = magnet_cal_data.X0;
 969   2                config.cal_magnet_y0 = magnet_cal_data.Y0;
 970   2                config.cal_magnet_z0 = magnet_cal_data.Z0;
 971   2                config.cal_magnet_ab = magnet_cal_data.A / magnet_cal_data.B;
 972   2                config.cal_magnet_ac = magnet_cal_data.A / magnet_cal_data.C;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 17  

 973   2                EEPROMWriteConfiguration(&config);
 974   2                data_cnt = 0;
 975   2                mode = 0;
 976   2                ON_RETURN = 1;
 977   2              }
 978   2            }
 979   2          }
 980   2          
 981   2          else if(func_num == BLUETOOTH)  //蓝牙    ok
 982   2          {
 983   2            unsigned char bluetooth_data[128] = "\0";
 984   2            static bit bluetooth_init = 0;
 985   2            static unsigned char y = 0;
 986   2            static unsigned char connected = 0;
 987   2            if(ON_OPEN)
 988   2            {
 989   2              ON_OPEN = 0;
 990   2              ClearCache(sub_cache2);
 991   2              ScreenPushAnimation(sub_cache2, LEFT);
 992   2              if(bluetooth_init == 0)
 993   2              {
 994   2                while(PW02Init() == 0);       //蓝牙初始化
 995   2                bluetooth_init = 1;
 996   2              }
 997   2              PW02SetMode(1);
 998   2              y = 0;
 999   2            }
1000   2            if(tick_20ms)
1001   2            {
1002   2              tick_20ms = 0;
1003   2              if(connected == 0)
1004   2              {
1005   2                if(PW02CheckConnection())
1006   2                {
1007   2                  connected = 1;
1008   2                  y = 6;
1009   2                }
1010   2              }
1011   2              if((connected == 1) && PW02GetRxData(bluetooth_data))
1012   2                y += ShowString(0, y, bluetooth_data, main_cache, FONT8X16, NO_INVERSED, 1);
1013   2            }
1014   2            if(Trg != 0)
1015   2            {
1016   2              switch(Trg)
1017   2              {
1018   2                case KEY1:
1019   2                {
1020   2                  ON_CLOSE = 1;
1021   2                  break;
1022   2                }
1023   2                case KEY2:
1024   2                {
1025   2                  ClearCache(main_cache);
1026   2                  y = 0;
1027   2                  y += ShowString(0, y, "Screen cleaned", main_cache, FONT8X16, NO_INVERSED, 1);
1028   2                  break;
1029   2                } 
1030   2              }
1031   2              Trg = 0;
1032   2            }
1033   2            if(ON_CLOSE)
1034   2            {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 18  

1035   2              ON_CLOSE = 0;
1036   2              if(connected == 0)
1037   2                while(PW02ExitATMode() == 0);
1038   2              else
1039   2                connected = 0;
1040   2              PW02SetMode(0);
1041   2              func_num = MENU;
1042   2              ON_RETURN = 1;
1043   2            }
1044   2          }
1045   2          else if(func_num == SPIRIT_LEVEL) //水平仪  ok
1046   2          {
1047   2            int x, y;
1048   2            unsigned char str[16];
1049   2            if(ON_OPEN)
1050   2            {
1051   2              ON_OPEN = 0;
1052   2              ClearCache(sub_cache2);
1053   2              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1054   2              ShowString(0, 0, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1055   2              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1056   2              ShowString(0, 1, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1057   2              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1058   2              ShowString(0, 2, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1059   2              BMPToCache(56, 3, 16, 16, CIRCLE16X16, sub_cache2, 0);
1060   2              ScreenPushAnimation(sub_cache2, LEFT);
1061   2              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
1062   2              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
1063   2              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
1064   2            }
1065   2            if(tick_8ms)
1066   2            {
1067   2              tick_8ms = 0;
1068   2              LSM6DSMReadGYRAndACC(&LSM6DSM);
1069   2              IMUupdate(&LSM6DSM);
1070   2            }
1071   2            if(tick_20ms)
1072   2            {
1073   2              tick_20ms = 0;
1074   2              ClearCache(main_cache);
1075   2              LSM6DSM.AngleX -= config.cal_anglex;
1076   2              LSM6DSM.AngleY -= config.cal_angley;
1077   2              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1078   2              ShowString(0, 0, str, main_cache, FONT6X8, NO_INVERSED, 0);
1079   2              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1080   2              ShowString(0, 1, str, main_cache, FONT6X8, NO_INVERSED, 0);
1081   2              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1082   2              ShowString(0, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
1083   2              BMPToCache(56, 3, 16, 16, CIRCLE16X16, main_cache, 0);
1084   2              x = 64 + LSM6DSM.AngleX;
1085   2              y = 32 + LSM6DSM.AngleY;
1086   2              if(x > 126)
1087   2                x = 126;
1088   2              else if(x < 1)
1089   2                x = 1;
1090   2              if(y > 62)
1091   2                y = 62;
1092   2              else if(y < 1)
1093   2                y = 1;
1094   2              if(x ==63 && y == 32)
1095   2                ScreenSetInverse(config.screen_inverse == NO_INVERSED?INVERSED:NO_INVERSED);
1096   2              else
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 19  

1097   2                ScreenSetInverse(config.screen_inverse);
1098   2              DrawDot(x, y);
1099   2              DrawDot(x - 1, y);
1100   2              DrawDot(x + 1, y);
1101   2              DrawDot(x, y + 1);
1102   2              DrawDot(x, y - 1);
1103   2              ScreenRefreshAll(main_cache);
1104   2            }
1105   2            if(Trg != 0)
1106   2            {
1107   2              switch(Trg)
1108   2              {
1109   2                case KEY1:
1110   2                {
1111   2                  ON_CLOSE = 1;
1112   2                  break;
1113   2                }
1114   2                case KEY2:
1115   2                {
1116   2                  config.cal_anglex = LSM6DSM.AngleX;
1117   2                  config.cal_angley = LSM6DSM.AngleY;
1118   2                  break;
1119   2                } 
1120   2                case KEY3:
1121   2                {
1122   2                  break;
1123   2                }
1124   2              }
1125   2              Trg = 0;
1126   2            }
1127   2            if(ON_CLOSE)
1128   2            {
1129   2              ON_CLOSE = 0;
1130   2              ScreenSetInverse(config.screen_inverse);
1131   2              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
1132   2              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
1133   2              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
1134   2              EEPROMWriteConfiguration(&config);
1135   2              func_num = MENU;
1136   2              ON_RETURN = 1;
1137   2            }
1138   2          }
1139   2        
1140   2          else if(func_num == FLASH_LIGHT)  //手电筒  ok
1141   2          {
1142   2            static char flash_mode = 0;
1143   2            static char flash_t_cnt = 0;
1144   2            static bit k = 0;
1145   2            if(ON_OPEN)
1146   2            {
1147   2              ON_OPEN = 0;
1148   2              ClearCache(sub_cache2);
1149   2              ShowString(28, 3, "Torch ON", sub_cache2, FONT8X16, NO_INVERSED, 0);
1150   2              ScreenPushAnimation(sub_cache2, LEFT);
1151   2              ScreenSetInverse(INVERSED);
1152   2              ScreenSetBrightness(255);
1153   2              LED(ON);
1154   2            }
1155   2            if(tick_20ms)
1156   2            {
1157   2              tick_20ms = 0;
1158   2              inactive_time = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 20  

1159   2              if(flash_mode)
1160   2              {
1161   2                if(flash_t_cnt++ == 5)
1162   2                {
1163   2                  flash_t_cnt = 0;
1164   2                  k = ~k;
1165   2                  LED(k);
1166   2                }
1167   2              }
1168   2            }
1169   2            if(Trg != 0)
1170   2            {
1171   2              switch(Trg)
1172   2              {
1173   2                case KEY1:
1174   2                {
1175   2                  ON_CLOSE = 1;
1176   2                  break;
1177   2                }
1178   2                case KEY2:
1179   2                {
1180   2                  if(flash_mode == 0)
1181   2                    flash_mode = 1;
1182   2                  else
1183   2                  {
1184   2                    flash_mode = 0;
1185   2                    LED(ON);
1186   2                  }
1187   2                  break;
1188   2                }
1189   2              }
1190   2              Trg = 0;
1191   2            }
1192   2            if(ON_CLOSE)
1193   2            {
1194   2              ON_CLOSE = 0;
1195   2              ScreenSetBrightness(config.screen_brightness);
1196   2              ScreenSetInverse(config.screen_inverse);
1197   2              LED(OFF);
1198   2              flash_mode = 0;
1199   2              flash_t_cnt = 0;
1200   2              func_num = MENU;
1201   2              ON_RETURN = 1;  
1202   2            }
1203   2          }
1204   2          else if(func_num == SETTING)      //设置    ok
1205   2          {
1206   2            static char index = 0;    //菜单的索引(0~MENU_MAX_ROW-1)
1207   2            static char pointer = 0;  //当前所选项在屏幕上的位置(0~3)
1208   2            static char mode = -1;
1209   2            unsigned char str[21];
1210   2            unsigned char *cache;
1211   2            if(mode == -1)  //设置菜单界面
1212   2            {
1213   2              if(ON_OPEN | ON_RETURN)
1214   2              {
1215   2                cache = &sub_cache2;
1216   2              }
1217   2              else
1218   2                cache = &main_cache;
1219   2              if(tick_20ms)
1220   2              {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 21  

1221   2                tick_20ms = 0;
1222   2                ClearCache(cache);
1223   2                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1224   2                ShowString(16, 0, SETTING_MENU[index - pointer], cache, FONT8X16, NO_INVERSED, 0);
1225   2                ShowString(16, 2, SETTING_MENU[index - pointer + 1], cache, FONT8X16, NO_INVERSED, 0);
1226   2                ShowString(16, 4, SETTING_MENU[index - pointer + 2], cache, FONT8X16, NO_INVERSED, 0);
1227   2                ShowString(16, 6, SETTING_MENU[index - pointer + 3], cache, FONT8X16, NO_INVERSED, 1);
1228   2                if(ON_OPEN)
1229   2                {
1230   2                  ScreenPushAnimation(sub_cache2, LEFT);
1231   2                  ON_OPEN = 0;
1232   2                }
1233   2                else if(ON_RETURN)
1234   2                {
1235   2                  ScreenPushAnimation(sub_cache2, RIGHT);
1236   2                  ON_RETURN = 0;
1237   2                } 
1238   2              }
1239   2              if(Trg != 0)
1240   2              {
1241   2                switch(Trg)
1242   2                {
1243   2                  case KEY1:
1244   2                  {
1245   2                    ON_CLOSE = 1;
1246   2                    break;
1247   2                  }
1248   2                  case KEY2:
1249   2                  {
1250   2                    index--;
1251   2                    if(--pointer < 0)
1252   2                    {
1253   2                      pointer = 0;
1254   2                      if(index != -1)
1255   2                      {
1256   2                        ClearCache(sub_cache2);
1257   2                        ShowString(16, 6, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1258   2                        ScreeRollDown(sub_cache2, 16);
1259   2                      }
1260   2                      else
1261   2                        index = 0;
1262   2                    }
1263   2                    break;
1264   2                  } 
1265   2                  case KEY3:
1266   2                  {
1267   2                    index++;
1268   2                    if(++pointer == 4)
1269   2                    {
1270   2                      pointer = 3;
1271   2                      if(index != MENU_MAX_ROW)
1272   2                      {
1273   2                        ClearCache(sub_cache2);
1274   2                        ShowString(16, 0, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1275   2                        ScreeRollUp(sub_cache2, 16);
1276   2                      }
1277   2                      else
1278   2                        index = MENU_MAX_ROW - 1;
1279   2                    }
1280   2                    break;
1281   2                  }
1282   2                  case DOUBLE_TAP:
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 22  

1283   2                  {
1284   2                    mode = index;
1285   2                    ON_OPEN = 1;
1286   2                    break;
1287   2                  }
1288   2                }
1289   2                Trg = 0;
1290   2              }
1291   2              if(ON_CLOSE)
1292   2              {
1293   2                ON_CLOSE = 0;
1294   2                func_num = MENU;
1295   2                ON_RETURN = 1;
1296   2              }
1297   2            }
1298   2            else if(mode == 0)  //设置时间
1299   2            {
1300   2              static char pointer = 0;
1301   2              static char set_index = 0;
1302   2              if(ON_OPEN)
1303   2              {
1304   2                ON_OPEN = 0;
1305   2                PCF8563ReadTime(&RTC);
1306   2                ClearCache(sub_cache2);
1307   2                ShowString(0, 0, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1308   2                sprintf(str, "%2d:%2d:%2d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1309   2                ShowString(16, 0, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1310   2                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1311   2                ShowString(16, 2, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1312   2                ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], sub_cache2, FONT6X8, NO_INVERSED, 0);
1313   2                ScreenPushAnimation(sub_cache2, LEFT);
1314   2              }
1315   2              if(tick_20ms)
1316   2              {
1317   2                tick_20ms = 0;
1318   2                ClearCache(main_cache);
1319   2                if(set_index == 0)
1320   2                  PCF8563ReadTime(&RTC);
1321   2                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1322   2                sprintf(str, "%02d:%02d:%02d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1323   2                ShowString(16, 0, str, main_cache, FONT8X16, NO_INVERSED, 0);
1324   2                if(pointer == 0 && set_index != 0)
1325   2                {
1326   2                  if(set_index == 1)
1327   2                  {
1328   2                    sprintf(str, "%02d", (int)RTC.hour);
1329   2                    ShowString(16, 0, str, main_cache, FONT8X16, INVERSED, 0);
1330   2                  }
1331   2                  else if(set_index == 2)
1332   2                  {
1333   2                    sprintf(str, "%02d", (int)RTC.minute);
1334   2                    ShowString(40, 0, str, main_cache, FONT8X16, INVERSED, 0);
1335   2                  }
1336   2                  else if(set_index == 3)
1337   2                  {
1338   2                    sprintf(str, "%02d", (int)RTC.second);
1339   2                    ShowString(64, 0, str, main_cache, FONT8X16, INVERSED, 0);
1340   2                  }
1341   2                }
1342   2                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1343   2                ShowString(16, 2, str, main_cache, FONT8X16, NO_INVERSED, 0);
1344   2                if(pointer == 1 && set_index != 0)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 23  

1345   2                {
1346   2                  if(set_index == 1)
1347   2                  {
1348   2                    sprintf(str, "%4d", (int)RTC.year);
1349   2                    ShowString(16, 2, str, main_cache, FONT8X16, INVERSED, 0);
1350   2                  }
1351   2                  else if(set_index == 2)
1352   2                  {
1353   2                    sprintf(str, "%2d", (int)RTC.month);
1354   2                    ShowString(56, 2, str, main_cache, FONT8X16, INVERSED, 0);
1355   2                  }
1356   2                  else if(set_index == 3)
1357   2                  {
1358   2                    sprintf(str, "%2d", (int)RTC.day);
1359   2                    ShowString(80, 2, str, main_cache, FONT8X16, INVERSED, 0);
1360   2                  }
1361   2                }
1362   2                if(pointer == 2 && set_index != 0)
1363   2                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, INVERSED, 1);
1364   2                else
1365   2                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, NO_INVERSED, 1);
1366   2              }
1367   2              if(Trg != 0)
1368   2              {
1369   2                switch(Trg)
1370   2                {
1371   2                  case KEY1:
1372   2                  {
1373   2                    if(set_index != 0)
1374   2                    {
1375   2                      set_index = 0;
1376   2                      PCF8563WriteTime(RTC.hour, RTC.minute, RTC.second);
1377   2                      PCF8563WriteDate(RTC.year, RTC.month, RTC.day, RTC.weekday);
1378   2                    }
1379   2                    else
1380   2                      ON_CLOSE = 1;
1381   2                    break;
1382   2                  }
1383   2                  case KEY2:
1384   2                  {
1385   2                    if(set_index == 0)
1386   2                    {
1387   2                      if(--pointer < 0)
1388   2                        pointer = 2;
1389   2                    }
1390   2                    else
1391   2                    {
1392   2                      if(pointer == 0)
1393   2                      {
1394   2                        if(set_index == 1)
1395   2                        {
1396   2                          if(++RTC.hour == 24)
1397   2                            RTC.hour = 0;
1398   2                        }
1399   2                        else if(set_index == 2)
1400   2                        {
1401   2                          if(++RTC.minute == 60)
1402   2                            RTC.minute = 0;
1403   2                        }
1404   2                        else if(set_index == 3)
1405   2                        {
1406   2                          if(++RTC.second == 60)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 24  

1407   2                            RTC.second = 0;
1408   2                        }
1409   2                      }
1410   2                      else if(pointer == 1)
1411   2                      {
1412   2                        if(set_index == 1)
1413   2                        {
1414   2                          if(++RTC.year == 2100)
1415   2                            RTC.year = 2000;
1416   2                        }
1417   2                        else if(set_index == 2)
1418   2                        {
1419   2                          if(++RTC.month == 13)
1420   2                            RTC.month = 1;
1421   2                        }
1422   2                        else if(set_index == 3)
1423   2                        {
1424   2                          if(++RTC.day == 32)
1425   2                            RTC.day = 1;
1426   2                        }
1427   2                      }
1428   2                      else if(pointer == 2)
1429   2                      {
1430   2                        if(set_index == 1)
1431   2                          if(++RTC.weekday == 8)
1432   2                            RTC.weekday = 1;
1433   2                      }
1434   2                    }
1435   2                    break;
1436   2                  }
1437   2                  case KEY3:
1438   2                  {
1439   2                    if(set_index == 0)
1440   2                    {
1441   2                      if(++pointer == 3)
1442   2                        pointer = 0;
1443   2                    }
1444   2                    else
1445   2                    {
1446   2                      if(pointer == 0)
1447   2                      {
1448   2                        if(set_index == 1)
1449   2                        {
1450   2                          if(--RTC.hour == 255)
1451   2                            RTC.hour = 23;
1452   2                        }
1453   2                        else if(set_index == 2)
1454   2                        {
1455   2                          if(--RTC.minute == 255)
1456   2                            RTC.minute = 59;
1457   2                        }
1458   2                        else if(set_index == 3)
1459   2                        {
1460   2                          if(--RTC.second == 255)
1461   2                            RTC.second = 59;
1462   2                        }
1463   2                      }
1464   2                      else if(pointer == 1)
1465   2                      {
1466   2                        if(set_index == 1)
1467   2                        {
1468   2                          if(--RTC.year == 1999)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 25  

1469   2                            RTC.year = 2099;
1470   2                        }
1471   2                        else if(set_index == 2)
1472   2                        {
1473   2                          if(--RTC.month == 255)
1474   2                            RTC.month = 12;
1475   2                        }
1476   2                        else if(set_index == 3)
1477   2                        {
1478   2                          if(--RTC.day == 255)
1479   2                            RTC.day = 31;
1480   2                        }
1481   2                      }
1482   2                      else if(pointer == 2)
1483   2                      {
1484   2                        if(set_index == 1)
1485   2                          if(--RTC.weekday == 0)
1486   2                            RTC.weekday = 7;
1487   2                      }
1488   2                    }
1489   2                    break;
1490   2                  }
1491   2                  case DOUBLE_TAP:
1492   2                  {
1493   2                    if(pointer < 2)
1494   2                    {
1495   2                      if(++set_index == 4)
1496   2                        set_index = 1;
1497   2                    }
1498   2                    else if(pointer == 2)
1499   2                    {
1500   2                      if(++set_index == 2)
1501   2                        set_index = 1;
1502   2                    }
1503   2                    break;
1504   2                  }
1505   2                }
1506   2                Trg = 0;
1507   2              }
1508   2              if(ON_CLOSE)
1509   2              {
1510   2                ON_CLOSE = 0;
1511   2                set_index = 0;
1512   2                pointer = 0;
1513   2                mode = -1;
1514   2                ON_RETURN = 1;
1515   2              }
1516   2            }
1517   2            else if(mode == 1)  //设置闹钟
1518   2            {
1519   2              static unsigned char pointer = 0;
1520   2              static unsigned char set_index = 0;
1521   2              if(ON_OPEN)
1522   2              {
1523   2                ON_OPEN = 0;
1524   2                ClearCache(sub_cache2);
1525   2                ShowString(16, 0, "Alarm:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1526   2                ShowString(0, 1, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1527   2                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1528   2                ShowString(16, 1, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1529   2                ShowString(16, 3, "Mode:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1530   2                ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], sub_cache2, FONT8X16, NO_INVERSED, 0);
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 26  

1531   2                ScreenPushAnimation(sub_cache2, LEFT);
1532   2              }
1533   2              if(tick_20ms)
1534   2              {
1535   2                tick_20ms = 0;
1536   2                ClearCache(main_cache);
1537   2                ShowString(0, 1 + pointer * 3, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1538   2                ShowString(16, 0, "Alarm:", main_cache, FONT6X8, NO_INVERSED, 0);
1539   2                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1540   2                ShowString(16, 1, str, main_cache, FONT8X16, NO_INVERSED, 0);
1541   2                if(pointer == 0 && set_index != 0)
1542   2                {
1543   2                  if(set_index == 1)
1544   2                  {
1545   2                    sprintf(str, "%02d", (int)config.alarm_hour);
1546   2                    ShowString(16, 1, str, main_cache, FONT8X16, INVERSED, 0);
1547   2                  }
1548   2                  else if(set_index == 2)
1549   2                  {
1550   2                    sprintf(str, "%02d", (int)config.alarm_min);
1551   2                    ShowString(40, 1, str, main_cache, FONT8X16, INVERSED, 0);
1552   2                  }
1553   2                }
1554   2                ShowString(16, 3, "Mode:", main_cache, FONT6X8, NO_INVERSED, 0);
1555   2                if(pointer == 1 && set_index != 0)
1556   2                {
1557   2                  
1558   2                  if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1559   2                  {
1560   2                    sprintf(str, "%02d", (int)config.alarm_day);
1561   2                    ShowString(16, 6, str, main_cache, FONT8X16, set_index==1?NO_INVERSED:INVERSED, 0);
1562   2                  }
1563   2                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, INVERSED, 1); 
1564   2                }
1565   2                else
1566   2                {
1567   2                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, NO_INVERSED, 1);            
1568   2                }
1569   2              }
1570   2              if(Trg != 0)
1571   2              {
1572   2                switch(Trg)
1573   2                {
1574   2                  case KEY1:
1575   2                  {
1576   2                    if(set_index != 0)
1577   2                      set_index = 0;
1578   2                    else
1579   2                      ON_CLOSE = 1;
1580   2                    break;
1581   2                  }
1582   2                  case KEY2:
1583   2                  {
1584   2                    if(set_index == 0)
1585   2                    {
1586   2                      if(++pointer == 2)
1587   2                        pointer = 0;
1588   2                    }
1589   2                    else
1590   2                    {
1591   2                      if(pointer == 0)
1592   2                      {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 27  

1593   2                        if(set_index == 1)
1594   2                        {
1595   2                          if(++config.alarm_hour == 24)
1596   2                            config.alarm_hour = 0;
1597   2                        }
1598   2                        else if(set_index == 2)
1599   2                        {
1600   2                          if(++config.alarm_min == 60)
1601   2                          config.alarm_min = 0;
1602   2                        }
1603   2                      }
1604   2                      else if(pointer == 1)
1605   2                      {
1606   2                        if(set_index == 1)
1607   2                        {
1608   2                          if(++config.alarm_mode == ALARM_MODE_NUM)
1609   2                            config.alarm_mode = 0;
1610   2                        }
1611   2                        else if(set_index == 2)
1612   2                        {
1613   2                          if(++config.alarm_day == 32)
1614   2                          {
1615   2                            config.alarm_day = 1;
1616   2                          }
1617   2                        }
1618   2                      }
1619   2                    }
1620   2                    break;
1621   2                  } 
1622   2                  case KEY3:
1623   2                  {
1624   2                    if(set_index == 0)
1625   2                    {
1626   2                      if(--pointer == 255)
1627   2                        pointer = 1;
1628   2                    }
1629   2                    else 
1630   2                    {
1631   2                      if(pointer == 0)
1632   2                      {
1633   2                        if(set_index == 1)
1634   2                        {
1635   2                          if(--config.alarm_hour == 255)
1636   2                            config.alarm_hour = 23;
1637   2                        }
1638   2                        else if(set_index == 2)
1639   2                        {
1640   2                          if(--config.alarm_min == 255)
1641   2                            config.alarm_min = 59;
1642   2                        }
1643   2                      }
1644   2                      else if(pointer == 1)
1645   2                      {
1646   2                        if(set_index == 1)
1647   2                        {
1648   2                          if(--config.alarm_mode == 255)
1649   2                            config.alarm_mode = ALARM_MODE_NUM - 1;
1650   2                        }
1651   2                        else if(set_index == 2)
1652   2                        {
1653   2                          if(--config.alarm_day == 0)
1654   2                          {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 28  

1655   2                            config.alarm_day = 31;
1656   2                          }
1657   2                        }
1658   2                      }
1659   2                    }
1660   2                    break;
1661   2                  }
1662   2                  case DOUBLE_TAP:
1663   2                  {
1664   2                    if(set_index == 0)
1665   2                      set_index ++;
1666   2                    else
1667   2                    {
1668   2                      if(pointer == 0)
1669   2                      {
1670   2                        if(++set_index == 3)
1671   2                          set_index = 1;
1672   2                      }
1673   2                      else if(pointer == 1)
1674   2                      {
1675   2                        if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1676   2                        {
1677   2                          if(++set_index == 3)
1678   2                          set_index = 1;
1679   2                        }
1680   2                      }
1681   2                    }
1682   2                    break;
1683   2                  }
1684   2                }
1685   2                Trg = 0;
1686   2              }
1687   2              if(ON_CLOSE)
1688   2              {
1689   2                ON_CLOSE = 0;
1690   2                set_index = 0;
1691   2                pointer = 0;
1692   2                if(config.alarm_mode != ALARM_DISABLE)
1693   2                {
1694   2                  if(config.alarm_mode == ALARM_WORKDAY)
1695   2                  {
1696   2                    PCF8563ReadTime(&RTC);
1697   2                    if(RTC.weekday > 5)
1698   2                      config.alarm_weekday = 1;
1699   2                    else
1700   2                    {
1701   2                      if((config.alarm_hour > RTC.hour) && (config.alarm_min > RTC.minute))
1702   2                        config.alarm_weekday = RTC.weekday;
1703   2                      else
1704   2                      {
1705   2                        if(RTC.weekday != 5)
1706   2                          config.alarm_weekday = RTC.weekday;
1707   2                        else
1708   2                          config.alarm_weekday = RTC.weekday + 1;
1709   2                      }
1710   2                    }
1711   2                  }
1712   2                  PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.
             -alarm_mode);
1713   2                }
1714   2                else
1715   2                  PCF8563DisableAlarm();
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 29  

1716   2                EEPROMWriteConfiguration(&config);
1717   2                mode = -1;
1718   2                ON_RETURN = 1;
1719   2              }
1720   2            }
1721   2            else if(mode == 2)  //设置亮度
1722   2            {
1723   2              static char temp;
1724   2              //unsigned char *cache;
1725   2              if(ON_OPEN)
1726   2              {
1727   2                ON_OPEN = 0;
1728   2                temp = config.screen_brightness / 50;
1729   2                ClearCache(sub_cache2);
1730   2                ShowString(0, 0, "Set the contrast ratio of the screen.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1731   2                sprintf(str, "%d", (int)temp);
1732   2                ShowString(56, 3, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1733   2                ScreenPushAnimation(sub_cache2, LEFT);
1734   2              }
1735   2              if(tick_20ms)
1736   2              {
1737   2                tick_20ms = 0;  
1738   2                ClearCache(main_cache);
1739   2                ShowString(0, 0, "Set the contrast ratio of the screen.", main_cache, FONT6X8, NO_INVERSED, 0);
1740   2                sprintf(str, "%d", (int)temp);
1741   2                ShowString(56, 3, str, main_cache, FONT8X16, NO_INVERSED, 1);
1742   2              }
1743   2              if(Trg != 0)
1744   2              {
1745   2                switch(Trg)
1746   2                {
1747   2                  case 0x01:
1748   2                  {
1749   2                    ON_CLOSE = 1;
1750   2                    break;
1751   2                  }
1752   2                  case 0x02:
1753   2                  {
1754   2                    if(++temp == 6)
1755   2                      temp = 5;
1756   2                    config.screen_brightness = temp * 50 + 1;
1757   2                    ScreenSetBrightness(config.screen_brightness);
1758   2                    break;
1759   2                  } 
1760   2                  case 0x04:
1761   2                  {
1762   2                    if(--temp < 0)
1763   2                      temp = 0;
1764   2                    config.screen_brightness = temp * 50 + 1;
1765   2                    ScreenSetBrightness(config.screen_brightness);
1766   2                    break;
1767   2                  }
1768   2                  case 0x08:
1769   2                    break;
1770   2                }
1771   2                Trg = 0;
1772   2              }
1773   2              if(ON_CLOSE)
1774   2              {
1775   2                ON_CLOSE = 0;
1776   2                EEPROMWriteConfiguration(&config);
1777   2                mode = -1;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 30  

1778   2                ON_RETURN = 1;
1779   2              }
1780   2            }
1781   2            else if(mode == 3)  //设置自动息屏时间
1782   2            {
1783   2              static int temp;
1784   2              if(ON_OPEN)
1785   2              {
1786   2                ON_OPEN = 0;
1787   2                temp = config.t_inactive_max;
1788   2                ClearCache(sub_cache2);
1789   2                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1790   2                sprintf(str, "%d", temp);
1791   2                ShowString(56, 5, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1792   2                ShowString(72, 6, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1793   2                ScreenPushAnimation(sub_cache2, LEFT);
1794   2              }
1795   2              if(tick_20ms)
1796   2              {
1797   2                tick_20ms = 0;
1798   2                ClearCache(main_cache);
1799   2                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", main_cache, FONT6X8, NO_INVERSED, 0);
1800   2                sprintf(str, "%d", temp);
1801   2                ShowString(56, 5, str, main_cache, FONT8X16, NO_INVERSED, 0);
1802   2                ShowString(72, 6, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1803   2              }
1804   2              if(Trg != 0)
1805   2              {
1806   2                switch(Trg)
1807   2                {
1808   2                  case KEY1:
1809   2                  {
1810   2                    ON_CLOSE = 1;
1811   2                    break;
1812   2                  }
1813   2                  case KEY2:
1814   2                  {
1815   2                    if(++temp == 100)
1816   2                      temp = 99;
1817   2                    break;
1818   2                  } 
1819   2                  case KEY3:
1820   2                  {
1821   2                    if(--temp < 0)
1822   2                      temp = 0;
1823   2                    break;
1824   2                  }
1825   2                }
1826   2                Trg = 0;
1827   2              }
1828   2              if(ON_CLOSE)
1829   2              {
1830   2                ON_CLOSE = 0;
1831   2                config.t_inactive_max = temp;
1832   2                EEPROMWriteConfiguration(&config);
1833   2                mode = -1;
1834   2                ON_RETURN = 1;
1835   2              }
1836   2            }
1837   2            else if(mode == 4)  //设置自动关机时间
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 31  

1838   2            {
1839   2              static int temp;
1840   2              if(ON_OPEN)
1841   2              {
1842   2                ON_OPEN = 0;
1843   2                temp = config.t_sleep_max;
1844   2                ClearCache(sub_cache2);
1845   2                ShowString(0, 0, "The time which mcu stay active for without any operation before power-down,when set
             - to 0,the mcu will never power down.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1846   2                sprintf(str, "%d", temp);
1847   2                ShowString(56, 6, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1848   2                ShowString(72, 7, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1849   2                ScreenPushAnimation(sub_cache2, LEFT);
1850   2              }
1851   2              if(tick_20ms)
1852   2              {
1853   2                tick_20ms = 0;
1854   2                ClearCache(main_cache);
1855   2                ShowString(0, 0, "The time which mcu stay active for before without any operation power-down,when set
             - to 0,the mcu will never power down.", main_cache, FONT6X8, NO_INVERSED, 0);
1856   2                sprintf(str, "%d", temp);
1857   2                ShowString(56, 6, str, main_cache, FONT8X16, NO_INVERSED, 0);
1858   2                ShowString(72, 7, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1859   2              }
1860   2              if(Trg != 0)
1861   2              {
1862   2                switch(Trg)
1863   2                {
1864   2                  case 0x01:
1865   2                  {
1866   2                    ON_CLOSE = 1;
1867   2                    break;
1868   2                  }
1869   2                  case 0x02:
1870   2                  {
1871   2                    if(++temp == 100)
1872   2                      temp = 99;
1873   2                    break;
1874   2                  } 
1875   2                  case 0x04:
1876   2                  {
1877   2                    if(--temp < 0)
1878   2                      temp = 0;
1879   2                    break;
1880   2                  }
1881   2                }
1882   2                Trg = 0;
1883   2              }
1884   2              if(ON_CLOSE)
1885   2              {
1886   2                ON_CLOSE = 0;
1887   2                config.t_sleep_max = temp;
1888   2                EEPROMWriteConfiguration(&config);
1889   2                mode = -1;
1890   2                ON_RETURN = 1;
1891   2              }
1892   2            }
1893   2            else if(mode == 5)  //设置屏幕反色
1894   2            {
1895   2              if(ON_OPEN)
1896   2              {
1897   2                ON_OPEN = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 32  

1898   2                ClearCache(sub_cache2);
1899   2                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", sub_cache2, FONT8X16, NO_INVERSED, 0)
             -;
1900   2                ScreenPushAnimation(sub_cache2, LEFT);
1901   2              }
1902   2              if(tick_20ms)
1903   2              {
1904   2                tick_20ms = 0;
1905   2                ClearCache(main_cache);
1906   2                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", main_cache, FONT8X16, NO_INVERSED, 1)
             -;
1907   2              }
1908   2              if(Trg != 0)
1909   2              {
1910   2                switch(Trg)
1911   2                {
1912   2                  case KEY1:
1913   2                  {
1914   2                    ON_CLOSE = 1;
1915   2                    break;
1916   2                  }
1917   2                  case DOUBLE_TAP:
1918   2                  {
1919   2                    if(config.screen_inverse == INVERSED)
1920   2                      config.screen_inverse = NO_INVERSED;
1921   2                    else
1922   2                      config.screen_inverse = INVERSED;
1923   2                    ScreenSetInverse(config.screen_inverse);
1924   2                    break;
1925   2                  } 
1926   2                }
1927   2                Trg = 0;
1928   2              }
1929   2              if(ON_CLOSE)
1930   2              {
1931   2                ON_CLOSE = 0;
1932   2                EEPROMWriteConfiguration(&config);
1933   2                mode = -1;
1934   2                ON_RETURN = 1;
1935   2              }
1936   2            }
1937   2            else if(mode == 6)  //设置屏幕方向
1938   2            {
1939   2              if(ON_OPEN)
1940   2              {
1941   2                ON_OPEN = 0;
1942   2                ClearCache(sub_cache2);
1943   2                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", sub_cache2, FONT8X16, NO
             -_INVERSED, 0);
1944   2                ScreenPushAnimation(sub_cache2, LEFT);
1945   2              }
1946   2              if(tick_20ms)
1947   2              {
1948   2                tick_20ms = 0;
1949   2                ClearCache(main_cache);
1950   2                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", main_cache, FONT8X16, NO
             -_INVERSED, 1);
1951   2              }
1952   2              if(Trg != 0)
1953   2              {
1954   2                switch(Trg)
1955   2                {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 33  

1956   2                  case KEY1:
1957   2                  {
1958   2                    ON_CLOSE = 1;
1959   2                    break;
1960   2                  }
1961   2                  case DOUBLE_TAP:
1962   2                  {
1963   2                    if(config.screen_direction == UPSIDEDOWN)
1964   2                      config.screen_direction = NORMAL;
1965   2                    else
1966   2                      config.screen_direction = UPSIDEDOWN;
1967   2                    ScreenSetDirection(config.screen_direction);
1968   2                    break;
1969   2                  } 
1970   2                }
1971   2                Trg = 0;
1972   2              }
1973   2              if(ON_CLOSE)
1974   2              {
1975   2                ON_CLOSE = 0;
1976   2                EEPROMWriteConfiguration(&config);
1977   2                mode = -1;
1978   2                ON_RETURN = 1;
1979   2              }
1980   2            }
1981   2            else if(mode == 7)  //设置按键音
1982   2            {
1983   2              if(ON_OPEN)
1984   2              {
1985   2                ON_OPEN = 0;
1986   2                ClearCache(sub_cache2);
1987   2                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", sub_cache2, FONT8X16, NO_INVERSED,
             - 0);
1988   2                ScreenPushAnimation(sub_cache2, LEFT);
1989   2              }
1990   2              if(tick_20ms)
1991   2              {
1992   2                tick_20ms = 0;
1993   2                ClearCache(main_cache);
1994   2                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", main_cache, FONT8X16, NO_INVERSED,
             - 1);
1995   2              }
1996   2              if(Trg != 0)
1997   2              {
1998   2                switch(Trg)
1999   2                {
2000   2                  case KEY1:
2001   2                  {
2002   2                    ON_CLOSE = 1;
2003   2                    break;
2004   2                  }
2005   2                  case DOUBLE_TAP:
2006   2                  {
2007   2                    if(config.key_sound == ON)
2008   2                      config.key_sound = OFF;
2009   2                    else
2010   2                      config.key_sound = ON;
2011   2                    EnableBuzzer(config.key_sound);
2012   2                    break;
2013   2                  }
2014   2                }
2015   2                Trg = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 34  

2016   2              }
2017   2              if(ON_CLOSE)
2018   2              {
2019   2                ON_CLOSE = 0;
2020   2                EEPROMWriteConfiguration(&config);
2021   2                mode = -1;
2022   2                ON_RETURN = 1;
2023   2              }
2024   2            }
2025   2            else if(mode == 8)  //单片机复位
2026   2            {
2027   2              MCUSoftReset();
2028   2            }
2029   2            else if(mode == 9)  //系统掉电
2030   2            {
2031   2              ON_OPEN = 0;
2032   2              active_flag = 0;
2033   2              action = 0;
2034   2              sleep_flag = 0;
2035   2              powerdown_flag = 0;
2036   2              inactive_time = 0;
2037   2              sleep_time = 0;
2038   2              deep_powerdown_flag = 1;
2039   2              mode = -1;
2040   2              func_num = WATCH;
2041   2            }
2042   2          }
2043   2          else if(func_num == SNAKES)       //贪吃蛇  ok
2044   2          {
2045   2            #define PANEL_WIDTH   92
2046   2            #define PANEL_HEIGHT  64
2047   2            #define MAX_SNAKE_SPEED 50
2048   2            unsigned char i = 0;
2049   2            unsigned char str[6];
2050   2            static unsigned char snake_direction = 0;//means sneak direction
2051   2            static unsigned char snake_speed = 10;
2052   2            static unsigned char past_x[256];
2053   2            static unsigned char past_y[256];
2054   2            static unsigned char snake_head_x = 64, snake_head_y = 32, snake_len = 20;
2055   2            static unsigned char test_now = 0, delicious_x= 80,delicious_y = 40;
2056   2            static unsigned char best_score = 0;
2057   2            static bit game_loop = 0;
2058   2            static bit game_over = 0;
2059   2            static bit game_pause = 0;
2060   2            if(ON_OPEN)
2061   2            {
2062   2              ON_OPEN = 0;
2063   2              ClearCache(sub_cache2);
2064   2              ScreenPushAnimation(sub_cache2, LEFT);//设定该界面左移进入屏幕
2065   2              snake_direction = 0;
2066   2              snake_head_x = 64;
2067   2              snake_head_y = 32;
2068   2              snake_len = 20;
2069   2              game_over = 0;
2070   2              game_pause = 0;
2071   2              for(i = 0; i < snake_len; i++)
2072   2              {
2073   2                past_x[i] = 64;
2074   2                past_y[i] = 32;
2075   2              }
2076   2              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
2077   2              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 35  

2078   2            }
2079   2            if(tick_8ms)
2080   2            {
2081   2              tick_8ms = 0;
2082   2              LSM6DSMReadGYRAndACC(&LSM6DSM);
2083   2              IMUupdate(&LSM6DSM);
2084   2            }
2085   2            if(tick_1ms)
2086   2            {
2087   2              static unsigned char t_cnt = 0;
2088   2              tick_1ms = 0;
2089   2              if(++t_cnt == (MAX_SNAKE_SPEED - snake_speed))
2090   2              {
2091   2                t_cnt = 0;
2092   2                game_loop = 1;
2093   2              }
2094   2            }
2095   2            if(game_loop)
2096   2            {
2097   2              game_loop = 0;
2098   2              inactive_time = 0;//to not close screen
2099   2              if(game_pause != 1)
2100   2              {
2101   2                ClearCache(main_cache);
2102   2                for(i = 0; i < PANEL_WIDTH; i++)  //画一个框
2103   2                {
2104   2                  DrawDot(i, 0);
2105   2                  DrawDot(i, PANEL_HEIGHT - 1);
2106   2                }
2107   2                for(i = 0; i < PANEL_HEIGHT; i++)
2108   2                {
2109   2                  DrawDot(0, i);
2110   2                  DrawDot(PANEL_WIDTH - 1, i);
2111   2                }
2112   2                ShowString(PANEL_WIDTH, 1, "Score:", main_cache, FONT6X8, NO_INVERSED, 0);
2113   2                sprintf(str, "%3d", (int)snake_len);
2114   2                ShowString(PANEL_WIDTH, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
2115   2                ShowString(PANEL_WIDTH, 5, "Best:", main_cache, FONT6X8, NO_INVERSED, 0);
2116   2                if(snake_len > best_score)
2117   2                  best_score = snake_len;
2118   2                sprintf(str, "%3d", (int)best_score);
2119   2                ShowString(PANEL_WIDTH, 6, str, main_cache, FONT6X8, NO_INVERSED, 0);
2120   2                if(snake_direction == 0)
2121   2                {
2122   2                  if(LSM6DSM.AngleY > 10)
2123   2                    snake_direction = 1;
2124   2                  else if(LSM6DSM.AngleY < -10)
2125   2                    snake_direction = 3;
2126   2                }
2127   2                else if(snake_direction == 1)
2128   2                {
2129   2                  if(LSM6DSM.AngleX > 10)
2130   2                    snake_direction = 0;
2131   2                  else if(LSM6DSM.AngleX < -10)
2132   2                    snake_direction = 2;
2133   2                }
2134   2                else if(snake_direction == 2)
2135   2                {
2136   2                  if(LSM6DSM.AngleY > 10)
2137   2                    snake_direction = 1;
2138   2                  else if(LSM6DSM.AngleY < -10)
2139   2                    snake_direction = 3;
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 36  

2140   2                }
2141   2                else if(snake_direction == 3)
2142   2                {
2143   2                  if(LSM6DSM.AngleX > 10)
2144   2                    snake_direction = 0;
2145   2                  else if(LSM6DSM.AngleX < -10)
2146   2                    snake_direction = 2;
2147   2                }
2148   2                //这段是按键程序解析后转换为方向以及点位置的程序，
2149   2                //sneak_direction是方向，test_x是头部的x轴值，test_y是头部的y轴值
2150   2                switch(snake_direction)
2151   2                {
2152   2                  case 0:   //右
2153   2                    snake_head_x++;
2154   2                    break;
2155   2                  case 1:   //下
2156   2                    snake_head_y++;
2157   2                    break;
2158   2                  case 2:   //左
2159   2                    snake_head_x--;
2160   2                    break;
2161   2                  case 3:   //上
2162   2                    snake_head_y--;
2163   2                    break;
2164   2                }
2165   2                if(snake_head_x >= PANEL_WIDTH)
2166   2                  snake_head_x = 1;
2167   2                else if(snake_head_x <= 0)
2168   2                  snake_head_x = PANEL_WIDTH - 1;
2169   2                if(snake_head_y >= PANEL_HEIGHT)
2170   2                  snake_head_y = 1;
2171   2                else if(snake_head_y <= 0)
2172   2                  snake_head_y = PANEL_HEIGHT - 1;
2173   2                //检查是否碰到自己的身体
2174   2                for(i = 0; i < snake_len; i++)
2175   2                {
2176   2                  if((snake_head_x == past_x[i]) && (snake_head_y == past_y[i]))
2177   2                  {
2178   2                    game_over = 1;
2179   2                    game_pause = 1;
2180   2                    break;
2181   2                  }
2182   2                }
2183   2                //这段是可以让贪吃蛇有可变长度尾巴的测试程序，test_num就是尾巴的数量，最大50，
2184   2                //程序原理是把每次过去的坐标都记录在数组里面。显示的时候就把过去的点也都显示出来
2185   2                test_now++;
2186   2                test_now = test_now % snake_len;
2187   2                past_x[test_now] = snake_head_x;
2188   2                past_y[test_now] = snake_head_y;
2189   2                for(i = 0; i < snake_len; i++)
2190   2                {
2191   2                  DrawDot(past_x[i], past_y[i]);
2192   2                }
2193   2                //这段程序放被吃掉的小东西，设计delicious_x,delicious_y为食物的坐标
2194   2                //吃掉食物以后会放一个新的食物，并且test_num也就是尾巴的数量会大1
2195   2                if((snake_head_x <= delicious_x+1) && (snake_head_y <= delicious_y+1) && (snake_head_x >= delicious_x
             --1) && (snake_head_y>=delicious_y-1))
2196   2                {
2197   2                  snake_len++;
2198   2                  past_x[snake_len - 1] = past_x[snake_len - 2];//解决小白点的问题
2199   2                  past_y[snake_len - 1] = past_y[snake_len - 2];
2200   2                  Bee();
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 37  

2201   2                  delicious_x = rand() % 92;
2202   2                  if(delicious_x > PANEL_WIDTH - 2)
2203   2                    delicious_x = PANEL_WIDTH - 2;
2204   2                  else if(delicious_x < 2)
2205   2                    delicious_x  = 2;
2206   2                  delicious_y = rand() % 64;
2207   2                  if(delicious_y > PANEL_HEIGHT - 2)
2208   2                    delicious_y = PANEL_HEIGHT - 2;
2209   2                  else if(delicious_y < 2)
2210   2                    delicious_y  = 2;
2211   2                }
2212   2                DrawDot(delicious_x,delicious_y);
2213   2                DrawDot(delicious_x+1,delicious_y);
2214   2                DrawDot(delicious_x-1,delicious_y);
2215   2                DrawDot(delicious_x,delicious_y+1);
2216   2                DrawDot(delicious_x+1,delicious_y+1);
2217   2                DrawDot(delicious_x-1,delicious_y+1);
2218   2                DrawDot(delicious_x,delicious_y-1);
2219   2                DrawDot(delicious_x+1,delicious_y-1);
2220   2                DrawDot(delicious_x-1,delicious_y-1);
2221   2                if(snake_len < 30)
2222   2                  snake_speed = 10;
2223   2                else if(snake_len < 40)
2224   2                  snake_speed = 20;
2225   2                else if(snake_len < 60)
2226   2                  snake_speed = 30;
2227   2                else if(snake_len < 90)
2228   2                  snake_speed = 35;
2229   2                else if(snake_len < 130)
2230   2                  snake_speed = 40;
2231   2                else
2232   2                  snake_speed = 45;
2233   2              }
2234   2              if(game_over)
2235   2              {
2236   2                ShowString(30, 2, "GAME", main_cache, FONT8X16, NO_INVERSED, 0);
2237   2                ShowString(30, 4, "OVER", main_cache, FONT8X16, NO_INVERSED, 0);
2238   2              }
2239   2              ScreenRefreshAll(main_cache);
2240   2            }
2241   2            if(Trg != 0)
2242   2            {
2243   2              switch(Trg)
2244   2              {
2245   2                case KEY1:
2246   2                {
2247   2                  ON_CLOSE = 1;
2248   2                  break;
2249   2                }
2250   2                case KEY2:
2251   2                {
2252   2                  if(game_over != 1)
2253   2                  {
2254   2                    if(game_pause)
2255   2                      game_pause = 0;
2256   2                    else
2257   2                      game_pause = 1;
2258   2                  }
2259   2                  break;
2260   2                }
2261   2                case KEY3:
2262   2                {
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 38  

2263   2                  ON_OPEN = 1;
2264   2                  break;
2265   2                }
2266   2              }
2267   2              Trg = 0;
2268   2            }
2269   2            if(ON_CLOSE)
2270   2            {
2271   2              ON_CLOSE = 0;
2272   2              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
2273   2              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
2274   2              func_num = MENU;
2275   2              ON_RETURN = 1;  
2276   2            }
2277   2          }
2278   2          if(action)          //系统在不同状态下对动作的处理
2279   2          {
2280   2            action = 0;
2281   2            if(active_flag)
2282   2              inactive_time = 0;
2283   2            else if(sleep_flag)
2284   2            {
2285   2              sleep_flag = 0;
2286   2              sleep_time = 0;
2287   2              active_flag = 1;
2288   2              ScreenOnOff(ON);
2289   2              screen_on_flag = 1;
2290   2            }
2291   2            else if(powerdown_flag)
2292   2            {
2293   2              powerdown_flag = 0;
2294   2              active_flag = 1;
2295   2              SystemPowerOn();
2296   2              ScreenOnOff(ON);
2297   2              screen_on_flag = 1;
2298   2              ON_OPEN = 1;
2299   2            }
2300   2            else if(deep_powerdown_flag)
2301   2            {
2302   2              deep_powerdown_flag = 0;
2303   2              active_flag = 1;
2304   2              SystemPowerOn();
2305   2              DisplayInit(&config);
2306   2              screen_on_flag = 1;
2307   2              SensorInit();
2308   2              PW02SetMode(0);
2309   2              PCF8563EnableTimer(TIMERCLK_1_60_HZ, 1);  //自动唤醒频率1min一次
2310   2              ON_OPEN = 1;
2311   2            }
2312   2            autowake_cnt = 0;
2313   2          }
2314   2          if(sleep_flag)
2315   2          {
2316   2            if(screen_on_flag)
2317   2            {
2318   2              ScreenOnOff(OFF);
2319   2              screen_on_flag = 0;
2320   2            }
2321   2          }
2322   2          if(powerdown_flag)    
2323   2          {
2324   2            if(ON_CLOSE == 0)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 39  

2325   2            {
2326   2              SystemPowerDown();
2327   2            }
2328   2          }
2329   2          if(deep_powerdown_flag)
2330   2          {
2331   2            if(ON_CLOSE == 0)
2332   2            {
2333   2              SystemDeepPowerDown();
2334   2            }
2335   2            Enable3V3Output(1);
2336   2            Delay1ms(10);
2337   2          }
2338   2          if(alarm_flag)
2339   2          {
2340   2            sleep_time = 0;     //闹铃被关掉前不会待机
2341   2          }
2342   2          if(timer_on_flag)
2343   2          {
2344   2            sleep_time = 0;     //计时器在工作时不会待机
2345   2          }
2346   2          if(PCF8563_int_flag)  //PCF8563产生了中断信号
2347   2          {
2348   2            unsigned char pcf8563_int_src;
2349   2            PCF8563_int_flag = 0;
2350   2            pcf8563_int_src = PCF8563ReadIntSrc();  //读PCF8563状态寄存器
2351   2            PCF8563ReadTime(&RTC);
2352   2            if(pcf8563_int_src & ALARM_INT)       //如果是闹钟中断
2353   2            {
2354   2              PCF8563ClearAlarmFlag();  //清除闹钟中断标志位
2355   2              action = 1;       //产生动作
2356   2              alarm_flag = 1;   //置位闹钟标志位
2357   2              Beebeebee();      //响铃
2358   2              Delay1ms(5);
2359   2              if(config.alarm_mode == ALARM_WORKDAY)
2360   2              {
2361   2                if(RTC.weekday + 1 > 5)
2362   2                  config.alarm_weekday = 1;
2363   2                else
2364   2                  config.alarm_weekday = RTC.weekday + 1;
2365   2                PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.a
             -larm_mode);
2366   2              }
2367   2              else if(config.alarm_mode != ALARM_EVERYDAY)  //如果闹钟模式不是每天都响
2368   2              {
2369   2                config.alarm_mode = ALARM_DISABLE;  //关闭闹钟
2370   2                PCF8563DisableAlarm();              //关闭闹钟
2371   2              }
2372   2              EEPROMWriteConfiguration(&config);
2373   2            }
2374   2            if(pcf8563_int_src & TIMER_INT)       //如果是定时器中断
2375   2            {
2376   2              PCF8563ClearTimerFlag();  //清除定时器中断标志位
2377   2              //PCF8563以固定的时间间隔唤醒MCU
2378   2              //唤醒之后执行以下内容
2379   2              battery_life = GetBatteryLife();
2380   2              if(active_flag || sleep_flag || powerdown_flag)
2381   2              {
2382   2                if((RTC.hour == 22) && (RTC.minute == 4))   //22:04,记录当天的步数数据
2383   2                {
2384   2                  char i, j;
2385   2                  for(i = 6; i > 0; i--)
C51 COMPILER V9.52.0.0   MAIN                                                              06/15/2021 23:50:05 PAGE 40  

2386   2                  {
2387   2                    for(j = 0; j < 10; j++)
2388   2                    {
2389   2                      config.history_step[i][j] = config.history_step[i - 1][j];
2390   2                    }
2391   2                  }
2392   2                  sprintf(config.history_step[0], "%d/%d %d", (int)RTC.month, (int)RTC.day, (int)LSM6DSMGetCurrentStep
             -());
2393   2                  EEPROMWriteConfiguration(&config);
2394   2                  LSM6DSMResetStepCounter();
2395   2                }
2396   2              }
2397   2              if(powerdown_flag)
2398   2              {
2399   2                if(++autowake_cnt >= 1440)    //1440分钟 = 1天
2400   2                {
2401   2                  autowake_cnt = 0;
2402   2                  powerdown_flag = 0;
2403   2                  PCF8563EnableTimer(TIMERCLK_1_60_HZ, 10); //自动唤醒频率改为10min一次，本来1min一次
2404   2                  deep_powerdown_flag = 1;
2405   2                }
2406   2              }
2407   2            }    
2408   2          }
2409   2            
2410   2          } 
2411   2        ********************/           
2412   2        }
2413   1      
2414   1      }
2415            
*** WARNING C230 IN LINE 2415 OF ..\User\main.c: 'LSM6DSM': uses undefined struct/union tag 'lsm6dsm_data'
*** WARNING C230 IN LINE 2415 OF ..\User\main.c: 'magnet_cal_data': uses undefined struct/union tag 'cal_data'
*** WARNING C230 IN LINE 2415 OF ..\User\main.c: 'RTC': uses undefined struct/union tag 'pcf8563_time'
*** WARNING C230 IN LINE 2415 OF ..\User\main.c: 'BME280': uses undefined struct/union tag 'bme280_data'


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    777    ----
   CONSTANT SIZE    =   8011    ----
   XDATA SIZE       =    137       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     16    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  15 WARNING(S),  0 ERROR(S)
