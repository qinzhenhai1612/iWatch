C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Objects\main.obj
COMPILER INVOKED BY: E:\install_files\keil\C51\BIN\C51.EXE ..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\
                    -oled;..\User\rtc;..\User\System;..\User;..\User\bluetooth;..\User\radio;..\User\sensor) DEBUG OBJECTEXTEND PRINT(..\List
                    -ings\main.lst) TABS(2) OBJECT(..\Objects\main.obj)

line level    source

   1          #include "Sys.h"
   2          #include "bmp.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "stdlib.h"
   6          #include "string.h"
   7          #include "math.h"
   8          #include "Delay.h"
   9          #include "PowerManage.h"
  10          #include "Buzzer.h"
  11          #include "Display.h"
  12          #include "PW02.h"
  13          #include "PCF8563.h"
  14          #include "BME280.h"                  
  15          #include "HMC5883L.h"                 
  16          #include "RDA5807M.h"
  17          #include "LSM6DSM.h"
  18          #include "Ellipsoid fitting.h"
  19          
  20          
  21          
  22          
  23          /***********************状态机相关变量*********************/
  24          enum function func_num = WATCH;    //功能号
  25          char func_index;               //功能索引
  26          bit ON_OPEN = 0;
  27          bit ON_CLOSE = 0;
  28          bit ON_RETURN = 0;
  29          /********************************************************/
  30          /************************时基信号************************/
  31          bit tick_1ms = 0;             //1000Hz
  32          bit tick_8ms = 0;             //125hz
  33          bit tick_20ms = 0;            //50hz
  34          
  35          /*************************工作状态相关变量*******************************/
  36          bit action = 0;             //动态标志位
  37          bit active_flag =1;       //活动标志位
  38          bit sleep_flag = 0;         //睡眠标志位
  39          bit powerdown_flag = 0;     //掉电标志位
  40          bit deep_powerdown_flag = 0;    //深度掉电标志位
  41          unsigned int inactive_time =0;  //自动息屏的时间
  42          unsigned int sleep_time = 0;    //自动待机时间
  43          unsigned int autowake_cnt = 0;  //自动唤醒的次数
  44          bit screen_on_flag = 1;     //屏幕状态标志位
  45          bit PCF8563_int_flag = 0;   //pcf8563中断产生标志位
  46          bit alarm_flag = 0;         //闹铃标志位
  47          bit radio_on_flag = 0;      //收音机工作标志位
  48          bit timer_on_flag = 0;      //计时器工作标志位
  49          /*************************按键相关变量*********************/
  50          unsigned char Trg = 0;      //按键触发值
  51          unsigned char Cont = 0;     //按键持续值
  52          /*************************显示缓存*******************************/
  53          extern unsigned char xdata main_cache[];
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 2   

  54          extern unsigned char xdata sub_cache1[];
  55          extern unsigned char xdata sub_cache2[];          
  56          
  57          struct sys_config config;   //设置信息结构体
  58          struct pcf8563_time RTC;    //时间信息结构体
  59          struct bme280_data BME280;  //bme280数据结构体
  60          struct lsm6dsm_data LSM6DSM;//LSM6DSM 数据结构体
  61          struct cal_data magnet_cal_data;  //磁力计叫做数据结构体
  62          float battery_life;         //电池电量
  63          unsigned int  timer_cnt = 0;//定时器0溢出次数
  64          
  65          
  66          void KeyScan(void)
  67          {
  68   1        unsigned char dat = 0x00;
  69   1        if(K1 == 0)
  70   1          dat |= KEY1;
  71   1        if(K2 == 0)
  72   1          dat |= KEY2;
  73   1        if(K3 ==0)
  74   1          dat |= KEY3;
  75   1        Trg = dat&(dat^Cont);
  76   1        Cont = dat;
  77   1      }
  78          
  79          void TM3_Ist()  interrupt 19 using 1    //  mcu定时器中断
  80          {
  81   1        static unsigned int t_count = 0;
  82   1        static unsigned int t_key_press =0; 
  83   1        AUXINTIF &= ~T3IF;                    //清除中断标志位
  84   1        if((K1 == 0) && (K2 == 0) && (K3 == 0))
  85   1        {
  86   2          while ((K1 == 0) ||(K2 == 0) ||(K3 == 0) ); //三个按键均抬起
  87   2            MCUSoftReset();                         //软复位MCU
  88   2        }
  89   1          if(t_count % 50 == 0)
  90   1        {
  91   2          KeyScan();
  92   2          if(Trg)
  93   2          {
  94   3            Bee();
  95   3            action = 1;
  96   3            if(sleep_flag || powerdown_flag || alarm_flag)
  97   3            {
  98   4              Trg = 0;
  99   4              if(alarm_flag)
 100   4              {
 101   5                alarm_flag = 0;
 102   5                LED(OFF);
 103   5              }
 104   4            }
 105   3          }
 106   2          if(Cont)
 107   2          {
 108   3            if(++t_key_press > 10)  //判断是否长按
 109   3              Trg = Cont;           //重复触发
 110   3          }
 111   2          else
 112   2            t_key_press = 0;
 113   2        }
 114   1        tick_1ms = 1;
 115   1        if(t_count % 8 == 0)
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 3   

 116   1          tick_8ms = 1;
 117   1        if(t_count % 20 == 0)
 118   1          tick_20ms = 1;
 119   1        if(++t_count == 1000)
 120   1        {
 121   2          t_count = 0;
 122   2          if(active_flag)
 123   2          {
 124   3            if(++inactive_time == config.t_inactive_max)
 125   3            {
 126   4              active_flag = 0;
 127   4              inactive_time = 0;
 128   4              sleep_flag = 1;
 129   4            }
 130   3          }
 131   2          if(sleep_flag)
 132   2          {
 133   3            if(++sleep_time == config.t_sleep_max)
 134   3            {
 135   4              sleep_flag = 0;
 136   4              sleep_time = 0;
 137   4              powerdown_flag = 1;
 138   4              ON_CLOSE = 1;
 139   4            }
 140   3          }
 141   2        }
 142   1      }
 143          
 144          //void INT0_Isr() interrupt 0           //PCF8563中断
 145          //{
 146          //  PCF8563_int_flag = 1;
 147          //}
 148          void TM0_Isr() interrupt 1 using 1    //计数器0溢出中断
 149          {
 150   1        timer_cnt++;
 151   1      }
 152          void INT1_Isr() interrupt 2 using 1   //双击中断
 153          {
 154   1        action = 1;
 155   1        alarm_flag = 0;
 156   1        Bee();
 157   1        if(sleep_flag || powerdown_flag || alarm_flag)
 158   1          Trg = 0;
 159   1        else
 160   1          Trg = DOUBLE_TAP;
 161   1        if(active_flag && func_num == WATCH)
 162   1        {
 163   2          action = 0;
 164   2          active_flag = 0;
 165   2          inactive_time = 0;
 166   2          ScreenOnOff(OFF);
 167   2          sleep_flag = 1;
 168   2        }
 169   1      }
 170          void INT2_Isr() interrupt 10 using 1  //抬腕唤醒中断
 171          {
 172   1        action = 1;
 173   1        if(sleep_flag || powerdown_flag)
 174   1        {Trg = 0;}
 175   1        else 
 176   1        {Trg = AWT;}
 177   1      }
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 4   

 178          void INT3_Isr() interrupt 11          //按键2中断
 179          {
 180   1        action = 1;
 181   1      }
 182          void SensorInit(void)
 183          {
 184   1        unsigned char y = 0;
 185   1        unsigned int time_out = 700;
 186   1        unsigned char error_count = 0;
 187   1        if(BME280Init() == 0)
 188   1        {
 189   2          y += ShowString(0, y, "BME280 ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 190   2          error_count++;
 191   2        }
 192   1        if(HMC5883L_Init() == 0)
 193   1        {
 194   2          y += ShowString(0, y, "HMC5883L ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 195   2          error_count++;
 196   2        }
 197   1        if(LSM6DSMInit() == 0)
 198   1        {
 199   2          y += ShowString(0, y, "LSM6DSM ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 200   2          error_count++;
 201   2        }
 202   1        if(RDA5807MInit() == 0)
 203   1        {
 204   2          y += ShowString(0, y, "RDA5807M ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 205   2          error_count++;
 206   2        }
 207   1        if(error_count != 0)
 208   1        {
 209   2          while(Trg == 0)
 210   2          {
 211   3            Delay1ms(1);
 212   3            if(--time_out == 0)
 213   3              break;
 214   3          }
 215   2        }
 216   1      }
 217          
 218          
 219          
 220          void  LED1_ON()
 221          {
 222   1        P35 = 1;
 223   1      }  
 224          void  LED1_OFF()
 225          {
 226   1        P35 = 0;
 227   1      }
 228          
 229          void BreathingLamp(void)
 230          {
 231   1        unsigned int  i=0,  j=0,num=500;
 232   1        for(i=0;i<num;i++)
 233   1          {
 234   2            for(j=0;j<num;j++)
 235   2            {
 236   3              if(i>j)
 237   3              {
 238   4                LED1_ON();
 239   4                Delay1us(1);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 5   

 240   4              }
 241   3              else
 242   3              {
 243   4                LED1_OFF();
 244   4                Delay1us(1);
 245   4              } 
 246   3            }
 247   2          }
 248   1          Delay1us(1);
 249   1          for(i=0;i<num;i++)
 250   1          {
 251   2            for(j=0;j<num;j++)
 252   2            {
 253   3              if(i>j)
 254   3              {
 255   4                LED1_OFF();
 256   4                Delay1us(1);
 257   4              }
 258   3            
 259   3              else
 260   3              {
 261   4                LED1_ON();
 262   4                Delay1us(1);
 263   4                
 264   4              } 
 265   3            }
 266   2          }
 267   1      }
 268          
 269          void main()
 270          { 
 271   1        
 272   1        
 273   1        SysInit();            //系统初始化
 274   1        DisplayInit(&config); //显示初始化     
 275   1        PCF8563Init();        //实时时钟初始化        
 276   1        SensorInit();         //传感器初始化
 277   1        ClearCache(main_cache); //清空主显存
 278   1        
 279   1        
 280   1        while(1)
 281   1        
 282   1        {
 283   2          FeedWatchDog();     //喂看门狗
 284   2          BreathingLamp();
 285   2       
 286   2          
 287   2          
 288   2      
 289   2                  
 290   2      
 291   2      
 292   2         
 293   2          
 294   2      
 295   2        
 296   2       
 297   2          if(func_num == WATCH)           //显示表盘
 298   2          {
 299   3            unsigned char x, n, m;
 300   3            unsigned char str[16];
 301   3            if(ON_OPEN)     //进入该功能时执行的内容
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 6   

 302   3            {
 303   4              ON_OPEN = 0;
 304   4              if(func_index == FIRST_FUNC)
 305   4                ScreenPushAnimation(sub_cache1, DOWN);
 306   4              else if(func_index == LAST_FUNC)
 307   4                ScreenPushAnimation(sub_cache1, UP);
 308   4              func_index = WATCH;
 309   4            }
 310   3            if(ON_RETURN)   //返回该功能时执行的内容
 311   3            {
 312   4              ON_RETURN = 0;
 313   4            }
 314   3            
 315   3            if(tick_20ms)   //在功能里时，每20ms执行一次功能内容
 316   3            {
 317   4              tick_20ms = 0;
 318   4              //显示时间
 319   4              PCF8563ReadTime(&RTC);
 320   4              //printf("%d:%d:%d\n", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
 321   4              DisplayTime(RTC.hour, RTC.minute, RTC.second);
 322   4              //显示小图标
 323   4              ClearCacheArea(0, 0, 35, 8, main_cache);
 324   4              x = 0;
 325   4              BMPToCache(x, 0, 8, 8, BLUETOOTH_SMALL_ICON, main_cache, 0);
 326   4              x += 9;
 327   4              if(timer_on_flag)
 328   4              {
 329   5                BMPToCache(x, 0, 8, 8, TIMER_SMALL_ICON, main_cache, 0);
 330   5                x += 9;
 331   5              }
 332   4              if(config.alarm_mode != ALARM_DISABLE)
 333   4              {
 334   5                BMPToCache(x, 0, 8, 8, CLOCK_SMALL_ICON, main_cache, 0);
 335   5                x += 9;
 336   5              }
 337   4              if(radio_on_flag)
 338   4                BMPToCache(x, 0, 8, 8, RADIO_SMALL_ICON, main_cache, 0);
 339   4              //显示日期，星期
 340   4              ClearCacheArea(0, 7, 128, 8, main_cache);
 341   4              sprintf(str, "%d/%d/%d ", (int)RTC.year, (int)RTC.month, (int)RTC.day);
 342   4              strcat(str, WEEKDAY_IN_STR[RTC.weekday - 1]);
 343   4              ShowString(0, 7, str, main_cache, FONT6X8, NO_INVERSED, 0);
 344   4              //显示电量
 345   4              battery_life = GetBatteryLife();
 346   4              for(n = 0; n < 24; n++)
 347   4                str[n] = BATTERY_LIFE_ICON[n];
 348   4              m = 18 * battery_life;
 349   4              for(n = 2; n < 2 + m; n++)
 350   4                str[n] |= 0x3c;
 351   4              BMPToCache(104, 0, 24, 8, str, main_cache, 0);
 352   4              sprintf(str, "%3d%%", (int)(battery_life * 100));
 353   4              ShowString(78, 0, str, main_cache, FONT6X8, NO_INVERSED, 1);
 354   4            }
 355   3            
 356   3            if(Trg != 0)    //在该功能下对按键事件的处理
 357   3            {
 358   4              switch(Trg)
 359   4              {
 360   5                case KEY1:
 361   5                {
 362   6                  func_num = SUB_MENU;
 363   6                  ON_CLOSE = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 7   

 364   6                  break;
 365   6                }
 366   5                case KEY2:
 367   5                {
 368   6                  func_index = FIRST_FUNC;
 369   6                  func_num = MENU;
 370   6                  ON_CLOSE = 1;
 371   6                  break;
 372   6                } 
 373   5                case KEY3:
 374   5                {
 375   6                  func_index = LAST_FUNC;
 376   6                  func_num = MENU;
 377   6                  ON_CLOSE = 1;
 378   6                  break;
 379   6                }
 380   5                case KEY13:
 381   5                {
 382   6                  active_flag = 0;
 383   6                  sleep_flag = 0;
 384   6                  powerdown_flag = 0;
 385   6                  inactive_time = 0;
 386   6                  sleep_time = 0;
 387   6                  deep_powerdown_flag = 1;
 388   6                  ON_CLOSE = 1;
 389   6                  break;
 390   6                }
 391   5              }
 392   4              Trg = 0;
 393   4            }
 394   3            if(ON_CLOSE)    //关闭该功能时执行的内容
 395   3            {
 396   4              ON_CLOSE = 0;
 397   4              SaveScreen();
 398   4              ON_OPEN = 1;
 399   4            }
 400   3          }
 401   2          else if(func_num == MENU)       //主菜单    ok
 402   2              {
 403   3            if(ON_OPEN)
 404   3            {
 405   4              ClearCache(sub_cache2);
 406   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 407   4              if(func_index == FIRST_FUNC)
 408   4                ScreenPushAnimation(sub_cache2, UP);
 409   4              else
 410   4                ScreenPushAnimation(sub_cache2, DOWN);
 411   4              ON_OPEN = 0;
 412   4            }
 413   3            if(ON_RETURN)
 414   3            {
 415   4              ON_RETURN = 0;
 416   4              ClearCache(sub_cache2);
 417   4              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 418   4              ScreenPushAnimation(sub_cache2, RIGHT);
 419   4            }
 420   3            if(Trg != 0)
 421   3            {
 422   4              switch(Trg)
 423   4              {
 424   5                case KEY1:
 425   5                {
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 8   

 426   6                  goto case_AWT;
 427   6                  break;
 428   6                }
 429   5                case KEY2:
 430   5                {
 431   6                  if(++func_index > FUNC_NUM_MAX - 1)
 432   6                  {
 433   7                    func_index = LAST_FUNC;
 434   7                    func_num = WATCH;
 435   7                    ON_CLOSE = 1;
 436   7                  }
 437   6                  else
 438   6                  {
 439   7                    ClearCache(sub_cache2);
 440   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 441   7                    ScreenPushAnimation(sub_cache2, UP);
 442   7                  }
 443   6                  break;
 444   6                }
 445   5                case KEY3:
 446   5                {
 447   6                  if(--func_index < 0)
 448   6                  {
 449   7                    func_index = FIRST_FUNC;
 450   7                    func_num = WATCH;
 451   7                    ON_CLOSE = 1;
 452   7                  }
 453   6                  else
 454   6                  {
 455   7                    ClearCache(sub_cache2);
 456   7                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 457   7                    ScreenPushAnimation(sub_cache2, DOWN);
 458   7                  }
 459   6                  break;
 460   6                }
 461   5                case DOUBLE_TAP:
 462   5                {
 463   6                  func_num = func_index;
 464   6                  ON_CLOSE= 1;
 465   6                  break;
 466   6                }
 467   5                case AWT:
 468   5                {
 469   6                  case_AWT:
 470   6                  if(func_index <= (FUNC_NUM_MAX - func_index))
 471   6                  {
 472   7                    while(func_index > 0)
 473   7                    {
 474   8                      func_index --;
 475   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 476   8                      ScreenPushAnimation(sub_cache2, DOWN);
 477   8                    }
 478   7                  }
 479   6                  else
 480   6                  {
 481   7                    while(func_index < FUNC_NUM_MAX - 1)
 482   7                    {
 483   8                      func_index ++;
 484   8                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 485   8                      ScreenPushAnimation(sub_cache2, UP);
 486   8                    }
 487   7                  }
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 9   

 488   6                  func_num = WATCH;
 489   6                  ON_CLOSE = 1;
 490   6                  break;
 491   6                }
 492   5              }
 493   4              Trg = 0;
 494   4            }
 495   3            if(ON_CLOSE)
 496   3            {
 497   4              ON_CLOSE = 0;
 498   4              ON_OPEN = 1;
 499   4            }
 500   3          }
 501   2          else if(func_num == SUB_MENU)   //次菜单    ok
 502   2          {
 503   3            
 504   3            char x, y;
 505   3            if(ON_OPEN)
 506   3            {
 507   4              ON_OPEN = 0;
 508   4              ClearCache(sub_cache2);
 509   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, sub_cache2, COVER);
 510   4              ScreenPushAnimation(sub_cache2, LEFT);
 511   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 512   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 513   4              LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 514   4            }
 515   3            if(tick_8ms)        //姿态解算频率：125hz
 516   3            {
 517   4              tick_8ms = 0;
 518   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
 519   4              IMUupdate(&LSM6DSM);
 520   4            }
 521   3            if(tick_20ms)
 522   3            {
 523   4              tick_20ms = 0;
 524   4              LSM6DSM.AngleX -= config.cal_anglex;  //倾角减去偏移
 525   4              LSM6DSM.AngleY -= config.cal_angley;  //倾角减去偏移
 526   4              LSM6DSM.AngleY -= 30;
 527   4              LSM6DSM.AngleX *= 3;      //调整一下横向灵敏度
 528   4              LSM6DSM.AngleY *= 2;      //调整一下纵向灵敏度
 529   4              if(LSM6DSM.AngleX > 63)   //对计算结果进行限幅
 530   4                LSM6DSM.AngleX = 63;
 531   4              else if(LSM6DSM.AngleX < -64)
 532   4                LSM6DSM.AngleX = -64;
 533   4              if(LSM6DSM.AngleY > 31)
 534   4                LSM6DSM.AngleY = 31;
 535   4              else if(LSM6DSM.AngleY < -31)
 536   4                LSM6DSM.AngleY = -31;
 537   4              x = 64 + LSM6DSM.AngleX;
 538   4              y = 32 + LSM6DSM.AngleY;
 539   4              if(x > 96)
 540   4                x = 96;
 541   4              if(y > 32)
 542   4                y = 32;
 543   4              ClearCache(main_cache);       //清空主缓存
 544   4              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, main_cache, COVER); //画菜单背景到主显存上
 545   4              DrawSelectionFrame(x, y);     //根据xy坐标画选择框到主显存上
 546   4              ScreenRefreshAll(main_cache); //将主显存刷新到OLED屏幕上
 547   4            }
 548   3            if(Cont == 0)
 549   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 10  

 550   4              func_index = (enum function)((x + 16) / 32 + ((y + 16) / 32) * 4);
 551   4              func_num = func_index;
 552   4              ON_CLOSE = 1;
 553   4            }
 554   3            if(ON_CLOSE)
 555   3            {
 556   4              ON_CLOSE = 0;
 557   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
 558   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 559   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 560   4              ON_OPEN = 1;
 561   4            }
 562   3          }
 563   2          else if(func_num == STOPWATCH)  //计时器    ok
 564   2          { 
 565   3            unsigned char t = 0, t_x = 0, t_y = 2;
 566   3            static int ms = 0, sec = 0, min = 0;
 567   3            static unsigned char n = 0, x = 0, y = 2;
 568   3            static unsigned char str1[10][11];
 569   3            unsigned char str2[10];
 570   3            if(ON_OPEN)
 571   3            {
 572   4              ON_OPEN = 0;
 573   4              ClearCache(sub_cache2);
 574   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 575   4              sec = ms / 100 % 60;
 576   4              min = sec / 60;
 577   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 578   4              ShowString(32, 0, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 579   4              if(n != 0)
 580   4              {
 581   5                for(t = 0; t < n; t++)
 582   5                {
 583   6                  if(t == 6)
 584   6                  {
 585   7                    t_x = 64;
 586   7                    t_y = 2;
 587   7                  }
 588   6                  ShowString(t_x, t_y++, str1[t], sub_cache2, FONT6X8, NO_INVERSED, 0);
 589   6                }
 590   5              }
 591   4              ScreenPushAnimation(sub_cache2, LEFT);
 592   4              ClearCache(sub_cache2);
 593   4            }
 594   3            if(tick_1ms)
 595   3            {
 596   4              tick_1ms = 0;
 597   4              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 598   4              sec = ms / 100;
 599   4              min = sec / 60;
 600   4              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 601   4              ShowString(32, 0, str2, main_cache, FONT8X16, NO_INVERSED, 1);
 602   4              sleep_time = 0;
 603   4            }
 604   3            if(Trg != 0)
 605   3            {
 606   4              switch(Trg)
 607   4              {
 608   5                case KEY1:
 609   5                {
 610   6                  ON_CLOSE = 1;
 611   6                  break;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 11  

 612   6                }
 613   5                case KEY2:
 614   5                {
 615   6                  if(TR0)
 616   6                  {
 617   7                    TR0 = 0;
 618   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, DISABLE_CLKOUT);
 619   7                    timer_on_flag = 0;
 620   7                  }
 621   6                  else
 622   6                  {
 623   7                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, ENABLE_CLKOUT);
 624   7                    TR0 = 1;
 625   7                    timer_on_flag = 1;
 626   7                  }
 627   6                  break;
 628   6                }
 629   5                case KEY3:
 630   5                {
 631   6                  timer_cnt = 0;
 632   6                  TH0 = 0;
 633   6                  TL0 = 0;
 634   6                  ms = 0;
 635   6                  sec = 0;
 636   6                  min = 0;
 637   6                  n = 0;
 638   6                  x = 0;
 639   6                  y = 2;
 640   6                  ClearCache(main_cache);
 641   6                  break;
 642   6                }
 643   5                case DOUBLE_TAP:
 644   5                {
 645   6                  if(n < 9 && timer_on_flag == 1)
 646   6                  {
 647   7                    if(n == 6)
 648   7                    {
 649   8                      x = 64;
 650   8                      y = 2;
 651   8                    }
 652   7                    sprintf(str1[n], "%d.%02d:%02d:%02d\0", (int)(n + 1), min, sec % 60, ms % 100);
 653   7                    ShowString(x + 0, y++, str1[n++], main_cache, FONT6X8, NO_INVERSED, 1);
 654   7                  }
 655   6                  break;
 656   6                }
 657   5              }
 658   4              Trg = 0;
 659   4            }
 660   3            if(ON_CLOSE)
 661   3            {
 662   4              ON_CLOSE = 0;
 663   4              func_num = MENU;
 664   4              ON_RETURN = 1;
 665   4            }
 666   3          }
 667   2          else if(func_num == PEDOMETER)  //计步器    ok
 668   2          {
 669   3            unsigned char n;
 670   3            unsigned int step;
 671   3            unsigned char buf[8];
 672   3            if(ON_OPEN)
 673   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 12  

 674   4              ON_OPEN = 0;
 675   4      //        PCF8563ReadTime(&RTC);
 676   4              ClearCache(sub_cache2);
 677   4              ShowString(0, 0, "Today:    History:", sub_cache2, FONT6X8, NO_INVERSED, 0);
 678   4              step = LSM6DSMGetCurrentStep();
 679   4              sprintf(buf, "%d ", step);
 680   4              ShowString(0, 1, buf, sub_cache2, FONT8X16, NO_INVERSED, 0);    
 681   4              ScreenPushAnimation(sub_cache2, LEFT);
 682   4            }
 683   3            if(tick_20ms)
 684   3            {
 685   4              tick_20ms = 0;
 686   4              step = LSM6DSMGetCurrentStep();
 687   4              sprintf(buf, "%d ", step);
 688   4              ShowString(0, 1, buf, main_cache, FONT8X16, NO_INVERSED, 0);
 689   4              for(n = 0; n < 7; n++)
 690   4              {
 691   5                ShowString(64, n + 1, config.history_step[n], main_cache, FONT6X8, NO_INVERSED, 1);
 692   5              }
 693   4            }
 694   3            if(Trg != 0)
 695   3            {
 696   4              switch(Trg)
 697   4              {
 698   5                case KEY1:
 699   5                {
 700   6                  ON_CLOSE = 1;
 701   6                  break;
 702   6                }
 703   5                case KEY2:
 704   5                {
 705   6                  //LSM6DSMResetStepCounter();
 706   6                  break;
 707   6                } 
 708   5              }
 709   4              Trg = 0;
 710   4            }
 711   3            if(ON_CLOSE)
 712   3            {
 713   4              ON_CLOSE = 0;
 714   4              func_num = MENU;
 715   4              ON_RETURN = 1;
 716   4            }
 717   3          }
 718   2          else if(func_num == THPMETER)   //温湿度计  ok
 719   2          {   
 720   3            float altitude;
 721   3            unsigned char str1[10] = {0};
 722   3            if(ON_OPEN)
 723   3            {
 724   4              ON_OPEN = 0;
 725   4              ClearCache(sub_cache2);
 726   4              BMPToCache(0, 0, 48, 64, T_H_P_A, sub_cache2, 0);
 727   4              sprintf(str1, "%.1f", BME280.temperature);
 728   4              ShowString(48, 0, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 729   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, sub_cache2, 0);
 730   4              sprintf(str1, "%.1f%%", BME280.humidity);
 731   4              ShowString(48, 2, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 732   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 733   4              ShowString(48, 4, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 734   4              ScreenPushAnimation(sub_cache2, LEFT);
 735   4              BME280ContinuousMeasurement(MS_125);    //连续测量模式，测量间隔125ms
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 13  

 736   4            }
 737   3            if(tick_20ms)
 738   3            {
 739   4              tick_20ms = 0;
 740   4              BME280GetSensorData(&BME280);         //读BME280测量数据并显示
 741   4              altitude = 44330.77 * (1 - pow((BME280.pressure / 101500), 0.190263));
 742   4              ClearCache(main_cache);
 743   4              BMPToCache(0, 0, 48, 64, T_H_P_A, main_cache, 0);
 744   4              sprintf(str1, "%.1f", BME280.temperature);
 745   4              ShowString(48, 0, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 746   4              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, main_cache, 0);
 747   4              sprintf(str1, "%.1f %%", BME280.humidity);
 748   4              ShowString(48, 2, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 749   4              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 750   4              ShowString(48, 4, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 751   4              sprintf(str1, "%d m", (int)altitude);
 752   4              ShowString(48, 6, str1, main_cache, FONT8X16, NO_INVERSED, 1);
 753   4            }
 754   3            if(Trg == KEY1)
 755   3            {
 756   4              Trg = 0;
 757   4              ON_CLOSE = 1;
 758   4            }
 759   3            if(ON_CLOSE)
 760   3            {
 761   4              ON_CLOSE = 0;
 762   4              BME280SetMode(SLEEP_MODE);
 763   4              func_num = MENU;
 764   4              ON_RETURN = 1;
 765   4            }
 766   3          }
 767   2          else if(func_num == RADIO)      //收音机    ok
 768   2          {
 769   3            static unsigned char index = 0;
 770   3            static bit searching_flag = 0;
 771   3            static unsigned char search_direction;
 772   3            float temp;
 773   3            unsigned char str2[16];
 774   3            if(ON_OPEN)
 775   3            {
 776   4              ON_OPEN = 0;
 777   4              ClearCache(sub_cache2);
 778   4              ShowString(80, 0, "volume", sub_cache2, FONT8X16, NO_INVERSED, 0);
 779   4              sprintf(str2,"%.1fMHz",config.radio_channel);
 780   4              ShowString(40, 3, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 781   4              ShowString(0, 6, "tune", sub_cache2, FONT8X16, NO_INVERSED, 0);
 782   4              ShowString(80, 6, "search", sub_cache2, FONT8X16, NO_INVERSED, 0);
 783   4              ShowString(0, 0, "close", main_cache, FONT8X16, NO_INVERSED, 0);
 784   4              ScreenPushAnimation(sub_cache2, LEFT);
 785   4              if(radio_on_flag != 1)
 786   4              {
 787   5                RDA5807MPowerUp();
 788   5                RDA5807MSetFq(config.radio_channel);
 789   5                if(config.radio_volume > 0x0f)
 790   5                  config.radio_volume = 0;
 791   5                RDA5807MSetVOLUME(config.radio_volume);
 792   5                radio_on_flag = 1;
 793   5              }
 794   4            }
 795   3            if(tick_20ms)
 796   3            {
 797   4              tick_20ms = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 14  

 798   4              ClearCache(main_cache);
 799   4              ShowString(80, 0, "volume", main_cache, FONT8X16, index == 0?INVERSED:NO_INVERSED, 0);
 800   4              sprintf(str2,"%.1fMHz", config.radio_channel);
 801   4              ShowString(40, 3, str2, main_cache, FONT8X16, NO_INVERSED, 0);
 802   4              if(searching_flag)
 803   4              {
 804   5                temp = RDA5807MSEEK(search_direction);
 805   5                if(temp == 0)
 806   5                  ShowString(28, 5, "searching...", main_cache, FONT6X8, NO_INVERSED, 0);
 807   5                else
 808   5                {
 809   6                  config.radio_channel = temp;
 810   6                  searching_flag = 0;
 811   6                }
 812   5              }
 813   4              ShowString(80, 6, "search", main_cache, FONT8X16, index == 1?INVERSED:NO_INVERSED, 0);
 814   4              ShowString(0, 6, "tune", main_cache, FONT8X16, index == 2?INVERSED:NO_INVERSED, 0);
 815   4              ShowString(0, 0, "close", main_cache, FONT8X16, index == 3?INVERSED:NO_INVERSED, 1);
 816   4            }
 817   3            if(Trg != 0)
 818   3            {
 819   4              switch(Trg)
 820   4              {
 821   5                case KEY1:
 822   5                {
 823   6                  ON_CLOSE = 1;
 824   6                  break;
 825   6                }
 826   5                case KEY2:
 827   5                {
 828   6                  if(index == 0)
 829   6                  {
 830   7                    if(++config.radio_volume > 0x0f)
 831   7                      config.radio_volume = 0x0f;
 832   7                    RDA5807MSetVOLUME(config.radio_volume);
 833   7                  }
 834   6                  else if(index == 1)
 835   6                  {
 836   7                    search_direction = UPWARD;
 837   7                    searching_flag = 1;
 838   7                  }
 839   6                  else if(index == 2)
 840   6                  {
 841   7                    config.radio_channel += 0.1;
 842   7                    if(config.radio_channel > 108)
 843   7                      config.radio_channel = 87;
 844   7                    RDA5807MSetFq(config.radio_channel);
 845   7                  }
 846   6                  break;
 847   6                } 
 848   5                case KEY3:
 849   5                {
 850   6                  if(index == 0)
 851   6                  {
 852   7                    if(--config.radio_volume == 255)
 853   7                      config.radio_volume = 0;
 854   7                    RDA5807MSetVOLUME(config.radio_volume);
 855   7                  }
 856   6                  else if(index == 1)
 857   6                  {
 858   7                    search_direction = DOWNWARD;
 859   7                    searching_flag = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 15  

 860   7                  }
 861   6                  else if(index == 2)
 862   6                  {
 863   7                    config.radio_channel -= 0.1;
 864   7                    if(config.radio_channel < 87)
 865   7                      config.radio_channel = 108;
 866   7                    RDA5807MSetFq(config.radio_channel);
 867   7                  }
 868   6                  break;
 869   6                }
 870   5                case DOUBLE_TAP:
 871   5                {
 872   6                  if(++index == 4)
 873   6                    index = 0;
 874   6                  break;
 875   6                }
 876   5              }
 877   4              Trg = 0;
 878   4            }
 879   3            if(ON_CLOSE)
 880   3            {
 881   4              ON_CLOSE = 0;
 882   4              if(powerdown_flag == 0 && index == 3)
 883   4              {
 884   5                RDA5807MPowerDown();
 885   5                radio_on_flag = 0;
 886   5                index = 0;  
 887   5                EEPROMWriteConfiguration(&config);
 888   5              }
 889   4              func_num = MENU;
 890   4              ON_RETURN = 1;
 891   4            }
 892   3          }
 893   2          else if(func_num == COMPASS)    //磁力计    ok
 894   2          {
 895   3            //显示角度和指针
 896   3            static char mode = 0;
 897   3            int magnet_data[3] = {0};
 898   3            unsigned char str3[16];
 899   3            if(mode == 0)     
 900   3            {
 901   4              unsigned char n;
 902   4              int angle_from_north;
 903   4              if(ON_OPEN)
 904   4              {
 905   5                ON_OPEN = 0;
 906   5                ClearCache(sub_cache2);
 907   5                sprintf(str3, "%d  ", angle_from_north);
 908   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 909   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 910   5                ScreenPushAnimation(sub_cache2, LEFT);
 911   5                //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 912   5                LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 913   5                LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 914   5                HMC5883L_Set_Mode(0);                   //设置连续测量模式
 915   5                HMC5883L_Set_Calibration_Value(config.cal_magnet_x0, config.cal_magnet_y0, config.cal_magnet_z0, 
 916   5                                              config.cal_magnet_ab, config.cal_magnet_ac);  //设置校准参数
 917   5              }
 918   4              if(ON_RETURN)
 919   4              {
 920   5                ON_RETURN = 0;
 921   5                ClearCache(sub_cache2);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 16  

 922   5                BMPToCache(16, 2, 32, 16, NESW[n], sub_cache2, COVER);
 923   5                sprintf(str3, "%d  ", angle_from_north);
 924   5                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, COVER);
 925   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 926   5                ScreenPushAnimation(sub_cache2, RIGHT);
 927   5              }
 928   4              if(tick_8ms)
 929   4              {
 930   5                tick_8ms = 0; 
 931   5                LSM6DSMReadGYRAndACC(&LSM6DSM);
 932   5                IMUupdate(&LSM6DSM);
 933   5              }
 934   4              if(tick_20ms)
 935   4              {
 936   5                tick_20ms = 0;
 937   5                Read_HMC5883L(magnet_data);
 938   5                angle_from_north = (int)HMC5883L_Get_AngleXY(magnet_data, (int)LSM6DSM.AngleX, (int)LSM6DSM.AngleY);
 939   5                angle_from_north += 90;
 940   5                if(angle_from_north >= 360)
 941   5                  angle_from_north -= 360;
 942   5                n = (angle_from_north + 22.5) / 45;
 943   5                if(n == 8)
 944   5                  n = 0;
 945   5                BMPToCache(16, 2, 32, 16, NESW[n], main_cache, 0);
 946   5                sprintf(str3, "%d  ", angle_from_north);
 947   5                ShowString(24, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 948   5                BMPToCache(64, 0, 64, 64, COMPASS_ICON, main_cache, 0);
 949   5                angle_from_north -= 90;
 950   5                if(angle_from_north < 0)
 951   5                  angle_from_north += 360;
 952   5                DrawArm(95, 31, 18, angle_from_north);
 953   5                ScreenRefreshAll(main_cache);
 954   5              }
 955   4              if(Trg != 0)
 956   4              {
 957   5                switch(Trg)
 958   5                {
 959   6                  case KEY1:
 960   6                  {
 961   7                    ON_CLOSE = 1;
 962   7                    break;
 963   7                  }
 964   6                  case KEY2:
 965   6                  {
 966   7                    mode = 1;
 967   7                    ON_OPEN = 1;
 968   7                    break;
 969   7                  } 
 970   6                }
 971   5                Trg = 0;
 972   5              }
 973   4              if(ON_CLOSE)
 974   4              {
 975   5                ON_CLOSE = 0;
 976   5                HMC5883L_Set_Mode(2);  //设置睡眠模式
 977   5                LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 978   5                LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 979   5                func_num = MENU;
 980   5                ON_RETURN = 1;
 981   5              }
 982   4            }
 983   3            else if(mode == 1)  //磁力计椭球校准
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 17  

 984   3            {
 985   4              static int data_cnt = 0;
 986   4              if(ON_OPEN)
 987   4              {
 988   5                ON_OPEN = 0;
 989   5                ClearCache(sub_cache2);
 990   5                sprintf(str3, "x:%d", magnet_data[0]);
 991   5                ShowString(0, 0, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 992   5                sprintf(str3, "y:%d", magnet_data[1]);
 993   5                ShowString(0, 2, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 994   5                sprintf(str3, "z:%d", magnet_data[2]);
 995   5                ShowString(0, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
 996   5                ScreenPushAnimation(sub_cache2, LEFT);
 997   5                ResetMatrix();
 998   5                HMC5883L_Set_Calibration_Value(0, 0, 0, 1, 1);  //清除校准参数
 999   5              }
1000   4              if(tick_20ms)
1001   4              {
1002   5                tick_20ms = 0;
1003   5                Read_HMC5883L(magnet_data);
1004   5                CalcData_Input(magnet_data[0], magnet_data[1], magnet_data[2]);
1005   5                sprintf(str3, "x:%d", magnet_data[0]);
1006   5                ShowString(0, 0, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1007   5                sprintf(str3, "y:%d", magnet_data[1]);
1008   5                ShowString(0, 2, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1009   5                sprintf(str3, "z:%d", magnet_data[2]);
1010   5                ShowString(0, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1011   5                sprintf(str3, "data_cnt:%d", data_cnt);
1012   5                ShowString(0, 6, str3, main_cache, FONT8X16, NO_INVERSED, 1);
1013   5                if(++data_cnt == 5000)
1014   5                {
1015   6                  ON_CLOSE = 1;
1016   6                  Bee();
1017   6                }
1018   5              }
1019   4              if(Trg == KEY1)
1020   4              {
1021   5                Trg = 0;
1022   5                ON_CLOSE = 1;
1023   5              }
1024   4              if(ON_CLOSE)
1025   4              {
1026   5                ON_CLOSE = 0;
1027   5                Ellipsoid_fitting_Process(&magnet_cal_data);    //椭球校准算法
1028   5                HMC5883L_Set_Calibration_Value(magnet_cal_data.X0, magnet_cal_data.Y0, magnet_cal_data.Z0, 
1029   5                                              magnet_cal_data.A / magnet_cal_data.B, 
1030   5                                              magnet_cal_data.A / magnet_cal_data.C);//设置校准参数
1031   5                config.cal_magnet_x0 = magnet_cal_data.X0;
1032   5                config.cal_magnet_y0 = magnet_cal_data.Y0;
1033   5                config.cal_magnet_z0 = magnet_cal_data.Z0;
1034   5                config.cal_magnet_ab = magnet_cal_data.A / magnet_cal_data.B;
1035   5                config.cal_magnet_ac = magnet_cal_data.A / magnet_cal_data.C;
1036   5                EEPROMWriteConfiguration(&config);
1037   5                data_cnt = 0;
1038   5                mode = 0;
1039   5                ON_RETURN = 1;
1040   5              }
1041   4            }
1042   3          }
1043   2          
1044   2          else if(func_num == BLUETOOTH)  //蓝牙    ok
1045   2          {
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 18  

1046   3            unsigned char bluetooth_data[128] = "\0";
1047   3            static bit bluetooth_init = 0;
1048   3            static unsigned char y = 0;
1049   3            static unsigned char connected = 0;
1050   3            if(ON_OPEN)
1051   3            {
1052   4              ON_OPEN = 0;
1053   4              ClearCache(sub_cache2);
1054   4              ScreenPushAnimation(sub_cache2, LEFT);
1055   4              if(bluetooth_init == 0)
1056   4              {
1057   5                while(PW02Init() == 0);       //蓝牙初始化
1058   5                bluetooth_init = 1;
1059   5              }
1060   4              PW02SetMode(1);
1061   4              y = 0;
1062   4            }
1063   3            if(tick_20ms)
1064   3            {
1065   4              tick_20ms = 0;
1066   4              if(connected == 0)
1067   4              {
1068   5                if(PW02CheckConnection())
1069   5                {
1070   6                  connected = 1;
1071   6                  y = 6;
1072   6                }
1073   5              }
1074   4              if((connected == 1) && PW02GetRxData(bluetooth_data))
1075   4                y += ShowString(0, y, bluetooth_data, main_cache, FONT8X16, NO_INVERSED, 1);
1076   4            }
1077   3            if(Trg != 0)
1078   3            {
1079   4              switch(Trg)
1080   4              {
1081   5                case KEY1:
1082   5                {
1083   6                  ON_CLOSE = 1;
1084   6                  break;
1085   6                }
1086   5                case KEY2:
1087   5                {
1088   6                  ClearCache(main_cache);
1089   6                  y = 0;
1090   6                  y += ShowString(0, y, "Screen cleaned", main_cache, FONT8X16, NO_INVERSED, 1);
1091   6                  break;
1092   6                } 
1093   5              }
1094   4              Trg = 0;
1095   4            }
1096   3            if(ON_CLOSE)
1097   3            {
1098   4              ON_CLOSE = 0;
1099   4              if(connected == 0)
1100   4                while(PW02ExitATMode() == 0);
1101   4              else
1102   4                connected = 0;
1103   4              PW02SetMode(0);
1104   4              func_num = MENU;
1105   4              ON_RETURN = 1;
1106   4            }
1107   3          }
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 19  

1108   2          else if(func_num == SPIRIT_LEVEL) //水平仪  ok
1109   2          {
1110   3            int x, y;
1111   3            unsigned char str[16];
1112   3            if(ON_OPEN)
1113   3            {
1114   4              ON_OPEN = 0;
1115   4              ClearCache(sub_cache2);
1116   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1117   4              ShowString(0, 0, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1118   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1119   4              ShowString(0, 1, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1120   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1121   4              ShowString(0, 2, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1122   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, sub_cache2, 0);
1123   4              ScreenPushAnimation(sub_cache2, LEFT);
1124   4              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
1125   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
1126   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
1127   4            }
1128   3            if(tick_8ms)
1129   3            {
1130   4              tick_8ms = 0;
1131   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
1132   4              IMUupdate(&LSM6DSM);
1133   4            }
1134   3            if(tick_20ms)
1135   3            {
1136   4              tick_20ms = 0;
1137   4              ClearCache(main_cache);
1138   4              LSM6DSM.AngleX -= config.cal_anglex;
1139   4              LSM6DSM.AngleY -= config.cal_angley;
1140   4              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1141   4              ShowString(0, 0, str, main_cache, FONT6X8, NO_INVERSED, 0);
1142   4              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1143   4              ShowString(0, 1, str, main_cache, FONT6X8, NO_INVERSED, 0);
1144   4              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1145   4              ShowString(0, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
1146   4              BMPToCache(56, 3, 16, 16, CIRCLE16X16, main_cache, 0);
1147   4              x = 64 + LSM6DSM.AngleX;
1148   4              y = 32 + LSM6DSM.AngleY;
1149   4              if(x > 126)
1150   4                x = 126;
1151   4              else if(x < 1)
1152   4                x = 1;
1153   4              if(y > 62)
1154   4                y = 62;
1155   4              else if(y < 1)
1156   4                y = 1;
1157   4              if(x ==63 && y == 32)
1158   4                ScreenSetInverse(config.screen_inverse == NO_INVERSED?INVERSED:NO_INVERSED);
1159   4              else
1160   4                ScreenSetInverse(config.screen_inverse);
1161   4              DrawDot(x, y);
1162   4              DrawDot(x - 1, y);
1163   4              DrawDot(x + 1, y);
1164   4              DrawDot(x, y + 1);
1165   4              DrawDot(x, y - 1);
1166   4              ScreenRefreshAll(main_cache);
1167   4            }
1168   3            if(Trg != 0)
1169   3            {
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 20  

1170   4              switch(Trg)
1171   4              {
1172   5                case KEY1:
1173   5                {
1174   6                  ON_CLOSE = 1;
1175   6                  break;
1176   6                }
1177   5                case KEY2:
1178   5                {
1179   6                  config.cal_anglex = LSM6DSM.AngleX;
1180   6                  config.cal_angley = LSM6DSM.AngleY;
1181   6                  break;
1182   6                } 
1183   5                case KEY3:
1184   5                {
1185   6                  break;
1186   6                }
1187   5              }
1188   4              Trg = 0;
1189   4            }
1190   3            if(ON_CLOSE)
1191   3            {
1192   4              ON_CLOSE = 0;
1193   4              ScreenSetInverse(config.screen_inverse);
1194   4              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
1195   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
1196   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
1197   4              EEPROMWriteConfiguration(&config);
1198   4              func_num = MENU;
1199   4              ON_RETURN = 1;
1200   4            }
1201   3          }
1202   2        
1203   2          else if(func_num == FLASH_LIGHT)  //手电筒  ok
1204   2          {
1205   3            static char flash_mode = 0;
1206   3            static char flash_t_cnt = 0;
1207   3            static bit k = 0;
1208   3            if(ON_OPEN)
1209   3            {
1210   4              ON_OPEN = 0;
1211   4              ClearCache(sub_cache2);
1212   4              ShowString(28, 3, "Torch ON", sub_cache2, FONT8X16, NO_INVERSED, 0);
1213   4              ScreenPushAnimation(sub_cache2, LEFT);
1214   4              ScreenSetInverse(INVERSED);
1215   4              ScreenSetBrightness(255);
1216   4              LED(ON);
1217   4            }
1218   3            if(tick_20ms)
1219   3            {
1220   4              tick_20ms = 0;
1221   4              inactive_time = 0;
1222   4              if(flash_mode)
1223   4              {
1224   5                if(flash_t_cnt++ == 5)
1225   5                {
1226   6                  flash_t_cnt = 0;
1227   6                  k = ~k;
1228   6                  LED(k);
1229   6                }
1230   5              }
1231   4            }
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 21  

1232   3            if(Trg != 0)
1233   3            {
1234   4              switch(Trg)
1235   4              {
1236   5                case KEY1:
1237   5                {
1238   6                  ON_CLOSE = 1;
1239   6                  break;
1240   6                }
1241   5                case KEY2:
1242   5                {
1243   6                  if(flash_mode == 0)
1244   6                    flash_mode = 1;
1245   6                  else
1246   6                  {
1247   7                    flash_mode = 0;
1248   7                    LED(ON);
1249   7                  }
1250   6                  break;
1251   6                }
1252   5              }
1253   4              Trg = 0;
1254   4            }
1255   3            if(ON_CLOSE)
1256   3            {
1257   4              ON_CLOSE = 0;
1258   4              ScreenSetBrightness(config.screen_brightness);
1259   4              ScreenSetInverse(config.screen_inverse);
1260   4              LED(OFF);
1261   4              flash_mode = 0;
1262   4              flash_t_cnt = 0;
1263   4              func_num = MENU;
1264   4              ON_RETURN = 1;  
1265   4            }
1266   3          }
1267   2          else if(func_num == SETTING)      //设置    ok
1268   2          {
1269   3            static char index = 0;    //菜单的索引(0~MENU_MAX_ROW-1)
1270   3            static char pointer = 0;  //当前所选项在屏幕上的位置(0~3)
1271   3            static char mode = -1;
1272   3            unsigned char str[21];
1273   3            unsigned char *cache;
1274   3            if(mode == -1)  //设置菜单界面
1275   3            {
1276   4              if(ON_OPEN | ON_RETURN)
1277   4              {
1278   5                cache = &sub_cache2;
1279   5              }
1280   4              else
1281   4                cache = &main_cache;
1282   4              if(tick_20ms)
1283   4              {
1284   5                tick_20ms = 0;
1285   5                ClearCache(cache);
1286   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1287   5                ShowString(16, 0, SETTING_MENU[index - pointer], cache, FONT8X16, NO_INVERSED, 0);
1288   5                ShowString(16, 2, SETTING_MENU[index - pointer + 1], cache, FONT8X16, NO_INVERSED, 0);
1289   5                ShowString(16, 4, SETTING_MENU[index - pointer + 2], cache, FONT8X16, NO_INVERSED, 0);
1290   5                ShowString(16, 6, SETTING_MENU[index - pointer + 3], cache, FONT8X16, NO_INVERSED, 1);
1291   5                if(ON_OPEN)
1292   5                {
1293   6                  ScreenPushAnimation(sub_cache2, LEFT);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 22  

1294   6                  ON_OPEN = 0;
1295   6                }
1296   5                else if(ON_RETURN)
1297   5                {
1298   6                  ScreenPushAnimation(sub_cache2, RIGHT);
1299   6                  ON_RETURN = 0;
1300   6                } 
1301   5              }
1302   4              if(Trg != 0)
1303   4              {
1304   5                switch(Trg)
1305   5                {
1306   6                  case KEY1:
1307   6                  {
1308   7                    ON_CLOSE = 1;
1309   7                    break;
1310   7                  }
1311   6                  case KEY2:
1312   6                  {
1313   7                    index--;
1314   7                    if(--pointer < 0)
1315   7                    {
1316   8                      pointer = 0;
1317   8                      if(index != -1)
1318   8                      {
1319   9                        ClearCache(sub_cache2);
1320   9                        ShowString(16, 6, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1321   9                        ScreeRollDown(sub_cache2, 16);
1322   9                      }
1323   8                      else
1324   8                        index = 0;
1325   8                    }
1326   7                    break;
1327   7                  } 
1328   6                  case KEY3:
1329   6                  {
1330   7                    index++;
1331   7                    if(++pointer == 4)
1332   7                    {
1333   8                      pointer = 3;
1334   8                      if(index != MENU_MAX_ROW)
1335   8                      {
1336   9                        ClearCache(sub_cache2);
1337   9                        ShowString(16, 0, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1338   9                        ScreeRollUp(sub_cache2, 16);
1339   9                      }
1340   8                      else
1341   8                        index = MENU_MAX_ROW - 1;
1342   8                    }
1343   7                    break;
1344   7                  }
1345   6                  case DOUBLE_TAP:
1346   6                  {
1347   7                    mode = index;
1348   7                    ON_OPEN = 1;
1349   7                    break;
1350   7                  }
1351   6                }
1352   5                Trg = 0;
1353   5              }
1354   4              if(ON_CLOSE)
1355   4              {
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 23  

1356   5                ON_CLOSE = 0;
1357   5                func_num = MENU;
1358   5                ON_RETURN = 1;
1359   5              }
1360   4            }
1361   3            else if(mode == 0)  //设置时间
1362   3            {
1363   4              static char pointer = 0;
1364   4              static char set_index = 0;
1365   4              if(ON_OPEN)
1366   4              {
1367   5                ON_OPEN = 0;
1368   5                PCF8563ReadTime(&RTC);
1369   5                ClearCache(sub_cache2);
1370   5                ShowString(0, 0, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1371   5                sprintf(str, "%2d:%2d:%2d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1372   5                ShowString(16, 0, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1373   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1374   5                ShowString(16, 2, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1375   5                ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], sub_cache2, FONT6X8, NO_INVERSED, 0);
1376   5                ScreenPushAnimation(sub_cache2, LEFT);
1377   5              }
1378   4              if(tick_20ms)
1379   4              {
1380   5                tick_20ms = 0;
1381   5                ClearCache(main_cache);
1382   5                if(set_index == 0)
1383   5                  PCF8563ReadTime(&RTC);
1384   5                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1385   5                sprintf(str, "%02d:%02d:%02d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1386   5                ShowString(16, 0, str, main_cache, FONT8X16, NO_INVERSED, 0);
1387   5                if(pointer == 0 && set_index != 0)
1388   5                {
1389   6                  if(set_index == 1)
1390   6                  {
1391   7                    sprintf(str, "%02d", (int)RTC.hour);
1392   7                    ShowString(16, 0, str, main_cache, FONT8X16, INVERSED, 0);
1393   7                  }
1394   6                  else if(set_index == 2)
1395   6                  {
1396   7                    sprintf(str, "%02d", (int)RTC.minute);
1397   7                    ShowString(40, 0, str, main_cache, FONT8X16, INVERSED, 0);
1398   7                  }
1399   6                  else if(set_index == 3)
1400   6                  {
1401   7                    sprintf(str, "%02d", (int)RTC.second);
1402   7                    ShowString(64, 0, str, main_cache, FONT8X16, INVERSED, 0);
1403   7                  }
1404   6                }
1405   5                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1406   5                ShowString(16, 2, str, main_cache, FONT8X16, NO_INVERSED, 0);
1407   5                if(pointer == 1 && set_index != 0)
1408   5                {
1409   6                  if(set_index == 1)
1410   6                  {
1411   7                    sprintf(str, "%4d", (int)RTC.year);
1412   7                    ShowString(16, 2, str, main_cache, FONT8X16, INVERSED, 0);
1413   7                  }
1414   6                  else if(set_index == 2)
1415   6                  {
1416   7                    sprintf(str, "%2d", (int)RTC.month);
1417   7                    ShowString(56, 2, str, main_cache, FONT8X16, INVERSED, 0);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 24  

1418   7                  }
1419   6                  else if(set_index == 3)
1420   6                  {
1421   7                    sprintf(str, "%2d", (int)RTC.day);
1422   7                    ShowString(80, 2, str, main_cache, FONT8X16, INVERSED, 0);
1423   7                  }
1424   6                }
1425   5                if(pointer == 2 && set_index != 0)
1426   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, INVERSED, 1);
1427   5                else
1428   5                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, NO_INVERSED, 1);
1429   5              }
1430   4              if(Trg != 0)
1431   4              {
1432   5                switch(Trg)
1433   5                {
1434   6                  case KEY1:
1435   6                  {
1436   7                    if(set_index != 0)
1437   7                    {
1438   8                      set_index = 0;
1439   8                      PCF8563WriteTime(RTC.hour, RTC.minute, RTC.second);
1440   8                      PCF8563WriteDate(RTC.year, RTC.month, RTC.day, RTC.weekday);
1441   8                    }
1442   7                    else
1443   7                      ON_CLOSE = 1;
1444   7                    break;
1445   7                  }
1446   6                  case KEY2:
1447   6                  {
1448   7                    if(set_index == 0)
1449   7                    {
1450   8                      if(--pointer < 0)
1451   8                        pointer = 2;
1452   8                    }
1453   7                    else
1454   7                    {
1455   8                      if(pointer == 0)
1456   8                      {
1457   9                        if(set_index == 1)
1458   9                        {
1459  10                          if(++RTC.hour == 24)
1460  10                            RTC.hour = 0;
1461  10                        }
1462   9                        else if(set_index == 2)
1463   9                        {
1464  10                          if(++RTC.minute == 60)
1465  10                            RTC.minute = 0;
1466  10                        }
1467   9                        else if(set_index == 3)
1468   9                        {
1469  10                          if(++RTC.second == 60)
1470  10                            RTC.second = 0;
1471  10                        }
1472   9                      }
1473   8                      else if(pointer == 1)
1474   8                      {
1475   9                        if(set_index == 1)
1476   9                        {
1477  10                          if(++RTC.year == 2100)
1478  10                            RTC.year = 2000;
1479  10                        }
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 25  

1480   9                        else if(set_index == 2)
1481   9                        {
1482  10                          if(++RTC.month == 13)
1483  10                            RTC.month = 1;
1484  10                        }
1485   9                        else if(set_index == 3)
1486   9                        {
1487  10                          if(++RTC.day == 32)
1488  10                            RTC.day = 1;
1489  10                        }
1490   9                      }
1491   8                      else if(pointer == 2)
1492   8                      {
1493   9                        if(set_index == 1)
1494   9                          if(++RTC.weekday == 8)
1495   9                            RTC.weekday = 1;
1496   9                      }
1497   8                    }
1498   7                    break;
1499   7                  }
1500   6                  case KEY3:
1501   6                  {
1502   7                    if(set_index == 0)
1503   7                    {
1504   8                      if(++pointer == 3)
1505   8                        pointer = 0;
1506   8                    }
1507   7                    else
1508   7                    {
1509   8                      if(pointer == 0)
1510   8                      {
1511   9                        if(set_index == 1)
1512   9                        {
1513  10                          if(--RTC.hour == 255)
1514  10                            RTC.hour = 23;
1515  10                        }
1516   9                        else if(set_index == 2)
1517   9                        {
1518  10                          if(--RTC.minute == 255)
1519  10                            RTC.minute = 59;
1520  10                        }
1521   9                        else if(set_index == 3)
1522   9                        {
1523  10                          if(--RTC.second == 255)
1524  10                            RTC.second = 59;
1525  10                        }
1526   9                      }
1527   8                      else if(pointer == 1)
1528   8                      {
1529   9                        if(set_index == 1)
1530   9                        {
1531  10                          if(--RTC.year == 1999)
1532  10                            RTC.year = 2099;
1533  10                        }
1534   9                        else if(set_index == 2)
1535   9                        {
1536  10                          if(--RTC.month == 255)
1537  10                            RTC.month = 12;
1538  10                        }
1539   9                        else if(set_index == 3)
1540   9                        {
1541  10                          if(--RTC.day == 255)
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 26  

1542  10                            RTC.day = 31;
1543  10                        }
1544   9                      }
1545   8                      else if(pointer == 2)
1546   8                      {
1547   9                        if(set_index == 1)
1548   9                          if(--RTC.weekday == 0)
1549   9                            RTC.weekday = 7;
1550   9                      }
1551   8                    }
1552   7                    break;
1553   7                  }
1554   6                  case DOUBLE_TAP:
1555   6                  {
1556   7                    if(pointer < 2)
1557   7                    {
1558   8                      if(++set_index == 4)
1559   8                        set_index = 1;
1560   8                    }
1561   7                    else if(pointer == 2)
1562   7                    {
1563   8                      if(++set_index == 2)
1564   8                        set_index = 1;
1565   8                    }
1566   7                    break;
1567   7                  }
1568   6                }
1569   5                Trg = 0;
1570   5              }
1571   4              if(ON_CLOSE)
1572   4              {
1573   5                ON_CLOSE = 0;
1574   5                set_index = 0;
1575   5                pointer = 0;
1576   5                mode = -1;
1577   5                ON_RETURN = 1;
1578   5              }
1579   4            }
1580   3            else if(mode == 1)  //设置闹钟
1581   3            {
1582   4              static unsigned char pointer = 0;
1583   4              static unsigned char set_index = 0;
1584   4              if(ON_OPEN)
1585   4              {
1586   5                ON_OPEN = 0;
1587   5                ClearCache(sub_cache2);
1588   5                ShowString(16, 0, "Alarm:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1589   5                ShowString(0, 1, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1590   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1591   5                ShowString(16, 1, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1592   5                ShowString(16, 3, "Mode:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1593   5                ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], sub_cache2, FONT8X16, NO_INVERSED, 0);
1594   5                ScreenPushAnimation(sub_cache2, LEFT);
1595   5              }
1596   4              if(tick_20ms)
1597   4              {
1598   5                tick_20ms = 0;
1599   5                ClearCache(main_cache);
1600   5                ShowString(0, 1 + pointer * 3, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1601   5                ShowString(16, 0, "Alarm:", main_cache, FONT6X8, NO_INVERSED, 0);
1602   5                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1603   5                ShowString(16, 1, str, main_cache, FONT8X16, NO_INVERSED, 0);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 27  

1604   5                if(pointer == 0 && set_index != 0)
1605   5                {
1606   6                  if(set_index == 1)
1607   6                  {
1608   7                    sprintf(str, "%02d", (int)config.alarm_hour);
1609   7                    ShowString(16, 1, str, main_cache, FONT8X16, INVERSED, 0);
1610   7                  }
1611   6                  else if(set_index == 2)
1612   6                  {
1613   7                    sprintf(str, "%02d", (int)config.alarm_min);
1614   7                    ShowString(40, 1, str, main_cache, FONT8X16, INVERSED, 0);
1615   7                  }
1616   6                }
1617   5                ShowString(16, 3, "Mode:", main_cache, FONT6X8, NO_INVERSED, 0);
1618   5                if(pointer == 1 && set_index != 0)
1619   5                {
1620   6                  
1621   6                  if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1622   6                  {
1623   7                    sprintf(str, "%02d", (int)config.alarm_day);
1624   7                    ShowString(16, 6, str, main_cache, FONT8X16, set_index==1?NO_INVERSED:INVERSED, 0);
1625   7                  }
1626   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, INVERSED, 1); 
1627   6                }
1628   5                else
1629   5                {
1630   6                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, NO_INVERSED, 1);            
1631   6                }
1632   5              }
1633   4              if(Trg != 0)
1634   4              {
1635   5                switch(Trg)
1636   5                {
1637   6                  case KEY1:
1638   6                  {
1639   7                    if(set_index != 0)
1640   7                      set_index = 0;
1641   7                    else
1642   7                      ON_CLOSE = 1;
1643   7                    break;
1644   7                  }
1645   6                  case KEY2:
1646   6                  {
1647   7                    if(set_index == 0)
1648   7                    {
1649   8                      if(++pointer == 2)
1650   8                        pointer = 0;
1651   8                    }
1652   7                    else
1653   7                    {
1654   8                      if(pointer == 0)
1655   8                      {
1656   9                        if(set_index == 1)
1657   9                        {
1658  10                          if(++config.alarm_hour == 24)
1659  10                            config.alarm_hour = 0;
1660  10                        }
1661   9                        else if(set_index == 2)
1662   9                        {
1663  10                          if(++config.alarm_min == 60)
1664  10                          config.alarm_min = 0;
1665  10                        }
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 28  

1666   9                      }
1667   8                      else if(pointer == 1)
1668   8                      {
1669   9                        if(set_index == 1)
1670   9                        {
1671  10                          if(++config.alarm_mode == ALARM_MODE_NUM)
1672  10                            config.alarm_mode = 0;
1673  10                        }
1674   9                        else if(set_index == 2)
1675   9                        {
1676  10                          if(++config.alarm_day == 32)
1677  10                          {
1678  11                            config.alarm_day = 1;
1679  11                          }
1680  10                        }
1681   9                      }
1682   8                    }
1683   7                    break;
1684   7                  } 
1685   6                  case KEY3:
1686   6                  {
1687   7                    if(set_index == 0)
1688   7                    {
1689   8                      if(--pointer == 255)
1690   8                        pointer = 1;
1691   8                    }
1692   7                    else 
1693   7                    {
1694   8                      if(pointer == 0)
1695   8                      {
1696   9                        if(set_index == 1)
1697   9                        {
1698  10                          if(--config.alarm_hour == 255)
1699  10                            config.alarm_hour = 23;
1700  10                        }
1701   9                        else if(set_index == 2)
1702   9                        {
1703  10                          if(--config.alarm_min == 255)
1704  10                            config.alarm_min = 59;
1705  10                        }
1706   9                      }
1707   8                      else if(pointer == 1)
1708   8                      {
1709   9                        if(set_index == 1)
1710   9                        {
1711  10                          if(--config.alarm_mode == 255)
1712  10                            config.alarm_mode = ALARM_MODE_NUM - 1;
1713  10                        }
1714   9                        else if(set_index == 2)
1715   9                        {
1716  10                          if(--config.alarm_day == 0)
1717  10                          {
1718  11                            config.alarm_day = 31;
1719  11                          }
1720  10                        }
1721   9                      }
1722   8                    }
1723   7                    break;
1724   7                  }
1725   6                  case DOUBLE_TAP:
1726   6                  {
1727   7                    if(set_index == 0)
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 29  

1728   7                      set_index ++;
1729   7                    else
1730   7                    {
1731   8                      if(pointer == 0)
1732   8                      {
1733   9                        if(++set_index == 3)
1734   9                          set_index = 1;
1735   9                      }
1736   8                      else if(pointer == 1)
1737   8                      {
1738   9                        if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1739   9                        {
1740  10                          if(++set_index == 3)
1741  10                          set_index = 1;
1742  10                        }
1743   9                      }
1744   8                    }
1745   7                    break;
1746   7                  }
1747   6                }
1748   5                Trg = 0;
1749   5              }
1750   4              if(ON_CLOSE)
1751   4              {
1752   5                ON_CLOSE = 0;
1753   5                set_index = 0;
1754   5                pointer = 0;
1755   5                if(config.alarm_mode != ALARM_DISABLE)
1756   5                {
1757   6                  if(config.alarm_mode == ALARM_WORKDAY)
1758   6                  {
1759   7                    PCF8563ReadTime(&RTC);
1760   7                    if(RTC.weekday > 5)
1761   7                      config.alarm_weekday = 1;
1762   7                    else
1763   7                    {
1764   8                      if((config.alarm_hour > RTC.hour) && (config.alarm_min > RTC.minute))
1765   8                        config.alarm_weekday = RTC.weekday;
1766   8                      else
1767   8                      {
1768   9                        if(RTC.weekday != 5)
1769   9                          config.alarm_weekday = RTC.weekday;
1770   9                        else
1771   9                          config.alarm_weekday = RTC.weekday + 1;
1772   9                      }
1773   8                    }
1774   7                  }
1775   6                  PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.
             -alarm_mode);
1776   6                }
1777   5                else
1778   5                  PCF8563DisableAlarm();
1779   5                EEPROMWriteConfiguration(&config);
1780   5                mode = -1;
1781   5                ON_RETURN = 1;
1782   5              }
1783   4            }
1784   3            else if(mode == 2)  //设置亮度
1785   3            {
1786   4              static char temp;
1787   4              //unsigned char *cache;
1788   4              if(ON_OPEN)
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 30  

1789   4              {
1790   5                ON_OPEN = 0;
1791   5                temp = config.screen_brightness / 50;
1792   5                ClearCache(sub_cache2);
1793   5                ShowString(0, 0, "Set the contrast ratio of the screen.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1794   5                sprintf(str, "%d", (int)temp);
1795   5                ShowString(56, 3, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1796   5                ScreenPushAnimation(sub_cache2, LEFT);
1797   5              }
1798   4              if(tick_20ms)
1799   4              {
1800   5                tick_20ms = 0;  
1801   5                ClearCache(main_cache);
1802   5                ShowString(0, 0, "Set the contrast ratio of the screen.", main_cache, FONT6X8, NO_INVERSED, 0);
1803   5                sprintf(str, "%d", (int)temp);
1804   5                ShowString(56, 3, str, main_cache, FONT8X16, NO_INVERSED, 1);
1805   5              }
1806   4              if(Trg != 0)
1807   4              {
1808   5                switch(Trg)
1809   5                {
1810   6                  case 0x01:
1811   6                  {
1812   7                    ON_CLOSE = 1;
1813   7                    break;
1814   7                  }
1815   6                  case 0x02:
1816   6                  {
1817   7                    if(++temp == 6)
1818   7                      temp = 5;
1819   7                    config.screen_brightness = temp * 50 + 1;
1820   7                    ScreenSetBrightness(config.screen_brightness);
1821   7                    break;
1822   7                  } 
1823   6                  case 0x04:
1824   6                  {
1825   7                    if(--temp < 0)
1826   7                      temp = 0;
1827   7                    config.screen_brightness = temp * 50 + 1;
1828   7                    ScreenSetBrightness(config.screen_brightness);
1829   7                    break;
1830   7                  }
1831   6                  case 0x08:
1832   6                    break;
1833   6                }
1834   5                Trg = 0;
1835   5              }
1836   4              if(ON_CLOSE)
1837   4              {
1838   5                ON_CLOSE = 0;
1839   5                EEPROMWriteConfiguration(&config);
1840   5                mode = -1;
1841   5                ON_RETURN = 1;
1842   5              }
1843   4            }
1844   3            else if(mode == 3)  //设置自动息屏时间
1845   3            {
1846   4              static int temp;
1847   4              if(ON_OPEN)
1848   4              {
1849   5                ON_OPEN = 0;
1850   5                temp = config.t_inactive_max;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 31  

1851   5                ClearCache(sub_cache2);
1852   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1853   5                sprintf(str, "%d", temp);
1854   5                ShowString(56, 5, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1855   5                ShowString(72, 6, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1856   5                ScreenPushAnimation(sub_cache2, LEFT);
1857   5              }
1858   4              if(tick_20ms)
1859   4              {
1860   5                tick_20ms = 0;
1861   5                ClearCache(main_cache);
1862   5                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", main_cache, FONT6X8, NO_INVERSED, 0);
1863   5                sprintf(str, "%d", temp);
1864   5                ShowString(56, 5, str, main_cache, FONT8X16, NO_INVERSED, 0);
1865   5                ShowString(72, 6, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1866   5              }
1867   4              if(Trg != 0)
1868   4              {
1869   5                switch(Trg)
1870   5                {
1871   6                  case KEY1:
1872   6                  {
1873   7                    ON_CLOSE = 1;
1874   7                    break;
1875   7                  }
1876   6                  case KEY2:
1877   6                  {
1878   7                    if(++temp == 100)
1879   7                      temp = 99;
1880   7                    break;
1881   7                  } 
1882   6                  case KEY3:
1883   6                  {
1884   7                    if(--temp < 0)
1885   7                      temp = 0;
1886   7                    break;
1887   7                  }
1888   6                }
1889   5                Trg = 0;
1890   5              }
1891   4              if(ON_CLOSE)
1892   4              {
1893   5                ON_CLOSE = 0;
1894   5                config.t_inactive_max = temp;
1895   5                EEPROMWriteConfiguration(&config);
1896   5                mode = -1;
1897   5                ON_RETURN = 1;
1898   5              }
1899   4            }
1900   3            else if(mode == 4)  //设置自动关机时间
1901   3            {
1902   4              static int temp;
1903   4              if(ON_OPEN)
1904   4              {
1905   5                ON_OPEN = 0;
1906   5                temp = config.t_sleep_max;
1907   5                ClearCache(sub_cache2);
1908   5                ShowString(0, 0, "The time which mcu stay active for without any operation before power-down,when set
             - to 0,the mcu will never power down.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1909   5                sprintf(str, "%d", temp);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 32  

1910   5                ShowString(56, 6, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1911   5                ShowString(72, 7, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1912   5                ScreenPushAnimation(sub_cache2, LEFT);
1913   5              }
1914   4              if(tick_20ms)
1915   4              {
1916   5                tick_20ms = 0;
1917   5                ClearCache(main_cache);
1918   5                ShowString(0, 0, "The time which mcu stay active for before without any operation power-down,when set
             - to 0,the mcu will never power down.", main_cache, FONT6X8, NO_INVERSED, 0);
1919   5                sprintf(str, "%d", temp);
1920   5                ShowString(56, 6, str, main_cache, FONT8X16, NO_INVERSED, 0);
1921   5                ShowString(72, 7, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1922   5              }
1923   4              if(Trg != 0)
1924   4              {
1925   5                switch(Trg)
1926   5                {
1927   6                  case 0x01:
1928   6                  {
1929   7                    ON_CLOSE = 1;
1930   7                    break;
1931   7                  }
1932   6                  case 0x02:
1933   6                  {
1934   7                    if(++temp == 100)
1935   7                      temp = 99;
1936   7                    break;
1937   7                  } 
1938   6                  case 0x04:
1939   6                  {
1940   7                    if(--temp < 0)
1941   7                      temp = 0;
1942   7                    break;
1943   7                  }
1944   6                }
1945   5                Trg = 0;
1946   5              }
1947   4              if(ON_CLOSE)
1948   4              {
1949   5                ON_CLOSE = 0;
1950   5                config.t_sleep_max = temp;
1951   5                EEPROMWriteConfiguration(&config);
1952   5                mode = -1;
1953   5                ON_RETURN = 1;
1954   5              }
1955   4            }
1956   3            else if(mode == 5)  //设置屏幕反色
1957   3            {
1958   4              if(ON_OPEN)
1959   4              {
1960   5                ON_OPEN = 0;
1961   5                ClearCache(sub_cache2);
1962   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", sub_cache2, FONT8X16, NO_INVERSED, 0)
             -;
1963   5                ScreenPushAnimation(sub_cache2, LEFT);
1964   5              }
1965   4              if(tick_20ms)
1966   4              {
1967   5                tick_20ms = 0;
1968   5                ClearCache(main_cache);
1969   5                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", main_cache, FONT8X16, NO_INVERSED, 1)
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 33  

             -;
1970   5              }
1971   4              if(Trg != 0)
1972   4              {
1973   5                switch(Trg)
1974   5                {
1975   6                  case KEY1:
1976   6                  {
1977   7                    ON_CLOSE = 1;
1978   7                    break;
1979   7                  }
1980   6                  case DOUBLE_TAP:
1981   6                  {
1982   7                    if(config.screen_inverse == INVERSED)
1983   7                      config.screen_inverse = NO_INVERSED;
1984   7                    else
1985   7                      config.screen_inverse = INVERSED;
1986   7                    ScreenSetInverse(config.screen_inverse);
1987   7                    break;
1988   7                  } 
1989   6                }
1990   5                Trg = 0;
1991   5              }
1992   4              if(ON_CLOSE)
1993   4              {
1994   5                ON_CLOSE = 0;
1995   5                EEPROMWriteConfiguration(&config);
1996   5                mode = -1;
1997   5                ON_RETURN = 1;
1998   5              }
1999   4            }
2000   3            else if(mode == 6)  //设置屏幕方向
2001   3            {
2002   4              if(ON_OPEN)
2003   4              {
2004   5                ON_OPEN = 0;
2005   5                ClearCache(sub_cache2);
2006   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", sub_cache2, FONT8X16, NO
             -_INVERSED, 0);
2007   5                ScreenPushAnimation(sub_cache2, LEFT);
2008   5              }
2009   4              if(tick_20ms)
2010   4              {
2011   5                tick_20ms = 0;
2012   5                ClearCache(main_cache);
2013   5                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", main_cache, FONT8X16, NO
             -_INVERSED, 1);
2014   5              }
2015   4              if(Trg != 0)
2016   4              {
2017   5                switch(Trg)
2018   5                {
2019   6                  case KEY1:
2020   6                  {
2021   7                    ON_CLOSE = 1;
2022   7                    break;
2023   7                  }
2024   6                  case DOUBLE_TAP:
2025   6                  {
2026   7                    if(config.screen_direction == UPSIDEDOWN)
2027   7                      config.screen_direction = NORMAL;
2028   7                    else
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 34  

2029   7                      config.screen_direction = UPSIDEDOWN;
2030   7                    ScreenSetDirection(config.screen_direction);
2031   7                    break;
2032   7                  } 
2033   6                }
2034   5                Trg = 0;
2035   5              }
2036   4              if(ON_CLOSE)
2037   4              {
2038   5                ON_CLOSE = 0;
2039   5                EEPROMWriteConfiguration(&config);
2040   5                mode = -1;
2041   5                ON_RETURN = 1;
2042   5              }
2043   4            }
2044   3            else if(mode == 7)  //设置按键音
2045   3            {
2046   4              if(ON_OPEN)
2047   4              {
2048   5                ON_OPEN = 0;
2049   5                ClearCache(sub_cache2);
2050   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", sub_cache2, FONT8X16, NO_INVERSED,
             - 0);
2051   5                ScreenPushAnimation(sub_cache2, LEFT);
2052   5              }
2053   4              if(tick_20ms)
2054   4              {
2055   5                tick_20ms = 0;
2056   5                ClearCache(main_cache);
2057   5                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", main_cache, FONT8X16, NO_INVERSED,
             - 1);
2058   5              }
2059   4              if(Trg != 0)
2060   4              {
2061   5                switch(Trg)
2062   5                {
2063   6                  case KEY1:
2064   6                  {
2065   7                    ON_CLOSE = 1;
2066   7                    break;
2067   7                  }
2068   6                  case DOUBLE_TAP:
2069   6                  {
2070   7                    if(config.key_sound == ON)
2071   7                      config.key_sound = OFF;
2072   7                    else
2073   7                      config.key_sound = ON;
2074   7                    EnableBuzzer(config.key_sound);
2075   7                    break;
2076   7                  }
2077   6                }
2078   5                Trg = 0;
2079   5              }
2080   4              if(ON_CLOSE)
2081   4              {
2082   5                ON_CLOSE = 0;
2083   5                EEPROMWriteConfiguration(&config);
2084   5                mode = -1;
2085   5                ON_RETURN = 1;
2086   5              }
2087   4            }
2088   3            else if(mode == 8)  //单片机复位
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 35  

2089   3            {
2090   4              MCUSoftReset();
2091   4            }
2092   3            else if(mode == 9)  //系统掉电
2093   3            {
2094   4              ON_OPEN = 0;
2095   4              active_flag = 0;
2096   4              action = 0;
2097   4              sleep_flag = 0;
2098   4              powerdown_flag = 0;
2099   4              inactive_time = 0;
2100   4              sleep_time = 0;
2101   4              deep_powerdown_flag = 1;
2102   4              mode = -1;
2103   4              func_num = WATCH;
2104   4            }
2105   3          }
2106   2          else if(func_num == SNAKES)       //贪吃蛇  ok
2107   2          {
2108   3            #define PANEL_WIDTH   92
2109   3            #define PANEL_HEIGHT  64
2110   3            #define MAX_SNAKE_SPEED 50
2111   3            unsigned char i = 0;
2112   3            unsigned char str[6];
2113   3            static unsigned char snake_direction = 0;//means sneak direction
2114   3            static unsigned char snake_speed = 10;
2115   3            static unsigned char past_x[256];
2116   3            static unsigned char past_y[256];
2117   3            static unsigned char snake_head_x = 64, snake_head_y = 32, snake_len = 20;
2118   3            static unsigned char test_now = 0, delicious_x= 80,delicious_y = 40;
2119   3            static unsigned char best_score = 0;
2120   3            static bit game_loop = 0;
2121   3            static bit game_over = 0;
2122   3            static bit game_pause = 0;
2123   3            if(ON_OPEN)
2124   3            {
2125   4              ON_OPEN = 0;
2126   4              ClearCache(sub_cache2);
2127   4              ScreenPushAnimation(sub_cache2, LEFT);//设定该界面左移进入屏幕
2128   4              snake_direction = 0;
2129   4              snake_head_x = 64;
2130   4              snake_head_y = 32;
2131   4              snake_len = 20;
2132   4              game_over = 0;
2133   4              game_pause = 0;
2134   4              for(i = 0; i < snake_len; i++)
2135   4              {
2136   5                past_x[i] = 64;
2137   5                past_y[i] = 32;
2138   5              }
2139   4              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
2140   4              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
2141   4            }
2142   3            if(tick_8ms)
2143   3            {
2144   4              tick_8ms = 0;
2145   4              LSM6DSMReadGYRAndACC(&LSM6DSM);
2146   4              IMUupdate(&LSM6DSM);
2147   4            }
2148   3            if(tick_1ms)
2149   3            {
2150   4              static unsigned char t_cnt = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 36  

2151   4              tick_1ms = 0;
2152   4              if(++t_cnt == (MAX_SNAKE_SPEED - snake_speed))
2153   4              {
2154   5                t_cnt = 0;
2155   5                game_loop = 1;
2156   5              }
2157   4            }
2158   3            if(game_loop)
2159   3            {
2160   4              game_loop = 0;
2161   4              inactive_time = 0;//to not close screen
2162   4              if(game_pause != 1)
2163   4              {
2164   5                ClearCache(main_cache);
2165   5                for(i = 0; i < PANEL_WIDTH; i++)  //画一个框
2166   5                {
2167   6                  DrawDot(i, 0);
2168   6                  DrawDot(i, PANEL_HEIGHT - 1);
2169   6                }
2170   5                for(i = 0; i < PANEL_HEIGHT; i++)
2171   5                {
2172   6                  DrawDot(0, i);
2173   6                  DrawDot(PANEL_WIDTH - 1, i);
2174   6                }
2175   5                ShowString(PANEL_WIDTH, 1, "Score:", main_cache, FONT6X8, NO_INVERSED, 0);
2176   5                sprintf(str, "%3d", (int)snake_len);
2177   5                ShowString(PANEL_WIDTH, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
2178   5                ShowString(PANEL_WIDTH, 5, "Best:", main_cache, FONT6X8, NO_INVERSED, 0);
2179   5                if(snake_len > best_score)
2180   5                  best_score = snake_len;
2181   5                sprintf(str, "%3d", (int)best_score);
2182   5                ShowString(PANEL_WIDTH, 6, str, main_cache, FONT6X8, NO_INVERSED, 0);
2183   5                if(snake_direction == 0)
2184   5                {
2185   6                  if(LSM6DSM.AngleY > 10)
2186   6                    snake_direction = 1;
2187   6                  else if(LSM6DSM.AngleY < -10)
2188   6                    snake_direction = 3;
2189   6                }
2190   5                else if(snake_direction == 1)
2191   5                {
2192   6                  if(LSM6DSM.AngleX > 10)
2193   6                    snake_direction = 0;
2194   6                  else if(LSM6DSM.AngleX < -10)
2195   6                    snake_direction = 2;
2196   6                }
2197   5                else if(snake_direction == 2)
2198   5                {
2199   6                  if(LSM6DSM.AngleY > 10)
2200   6                    snake_direction = 1;
2201   6                  else if(LSM6DSM.AngleY < -10)
2202   6                    snake_direction = 3;
2203   6                }
2204   5                else if(snake_direction == 3)
2205   5                {
2206   6                  if(LSM6DSM.AngleX > 10)
2207   6                    snake_direction = 0;
2208   6                  else if(LSM6DSM.AngleX < -10)
2209   6                    snake_direction = 2;
2210   6                }
2211   5                //这段是按键程序解析后转换为方向以及点位置的程序，
2212   5                //sneak_direction是方向，test_x是头部的x轴值，test_y是头部的y轴值
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 37  

2213   5                switch(snake_direction)
2214   5                {
2215   6                  case 0:   //右
2216   6                    snake_head_x++;
2217   6                    break;
2218   6                  case 1:   //下
2219   6                    snake_head_y++;
2220   6                    break;
2221   6                  case 2:   //左
2222   6                    snake_head_x--;
2223   6                    break;
2224   6                  case 3:   //上
2225   6                    snake_head_y--;
2226   6                    break;
2227   6                }
2228   5                if(snake_head_x >= PANEL_WIDTH)
2229   5                  snake_head_x = 1;
2230   5                else if(snake_head_x <= 0)
2231   5                  snake_head_x = PANEL_WIDTH - 1;
2232   5                if(snake_head_y >= PANEL_HEIGHT)
2233   5                  snake_head_y = 1;
2234   5                else if(snake_head_y <= 0)
2235   5                  snake_head_y = PANEL_HEIGHT - 1;
2236   5                //检查是否碰到自己的身体
2237   5                for(i = 0; i < snake_len; i++)
2238   5                {
2239   6                  if((snake_head_x == past_x[i]) && (snake_head_y == past_y[i]))
2240   6                  {
2241   7                    game_over = 1;
2242   7                    game_pause = 1;
2243   7                    break;
2244   7                  }
2245   6                }
2246   5                //这段是可以让贪吃蛇有可变长度尾巴的测试程序，test_num就是尾巴的数量，最大50，
2247   5                //程序原理是把每次过去的坐标都记录在数组里面。显示的时候就把过去的点也都显示出来
2248   5                test_now++;
2249   5                test_now = test_now % snake_len;
2250   5                past_x[test_now] = snake_head_x;
2251   5                past_y[test_now] = snake_head_y;
2252   5                for(i = 0; i < snake_len; i++)
2253   5                {
2254   6                  DrawDot(past_x[i], past_y[i]);
2255   6                }
2256   5                //这段程序放被吃掉的小东西，设计delicious_x,delicious_y为食物的坐标
2257   5                //吃掉食物以后会放一个新的食物，并且test_num也就是尾巴的数量会大1
2258   5                if((snake_head_x <= delicious_x+1) && (snake_head_y <= delicious_y+1) && (snake_head_x >= delicious_x
             --1) && (snake_head_y>=delicious_y-1))
2259   5                {
2260   6                  snake_len++;
2261   6                  past_x[snake_len - 1] = past_x[snake_len - 2];//解决小白点的问题
2262   6                  past_y[snake_len - 1] = past_y[snake_len - 2];
2263   6                  Bee();
2264   6                  delicious_x = rand() % 92;
2265   6                  if(delicious_x > PANEL_WIDTH - 2)
2266   6                    delicious_x = PANEL_WIDTH - 2;
2267   6                  else if(delicious_x < 2)
2268   6                    delicious_x  = 2;
2269   6                  delicious_y = rand() % 64;
2270   6                  if(delicious_y > PANEL_HEIGHT - 2)
2271   6                    delicious_y = PANEL_HEIGHT - 2;
2272   6                  else if(delicious_y < 2)
2273   6                    delicious_y  = 2;
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 38  

2274   6                }
2275   5                DrawDot(delicious_x,delicious_y);
2276   5                DrawDot(delicious_x+1,delicious_y);
2277   5                DrawDot(delicious_x-1,delicious_y);
2278   5                DrawDot(delicious_x,delicious_y+1);
2279   5                DrawDot(delicious_x+1,delicious_y+1);
2280   5                DrawDot(delicious_x-1,delicious_y+1);
2281   5                DrawDot(delicious_x,delicious_y-1);
2282   5                DrawDot(delicious_x+1,delicious_y-1);
2283   5                DrawDot(delicious_x-1,delicious_y-1);
2284   5                if(snake_len < 30)
2285   5                  snake_speed = 10;
2286   5                else if(snake_len < 40)
2287   5                  snake_speed = 20;
2288   5                else if(snake_len < 60)
2289   5                  snake_speed = 30;
2290   5                else if(snake_len < 90)
2291   5                  snake_speed = 35;
2292   5                else if(snake_len < 130)
2293   5                  snake_speed = 40;
2294   5                else
2295   5                  snake_speed = 45;
2296   5              }
2297   4              if(game_over)
2298   4              {
2299   5                ShowString(30, 2, "GAME", main_cache, FONT8X16, NO_INVERSED, 0);
2300   5                ShowString(30, 4, "OVER", main_cache, FONT8X16, NO_INVERSED, 0);
2301   5              }
2302   4              ScreenRefreshAll(main_cache);
2303   4            }
2304   3            if(Trg != 0)
2305   3            {
2306   4              switch(Trg)
2307   4              {
2308   5                case KEY1:
2309   5                {
2310   6                  ON_CLOSE = 1;
2311   6                  break;
2312   6                }
2313   5                case KEY2:
2314   5                {
2315   6                  if(game_over != 1)
2316   6                  {
2317   7                    if(game_pause)
2318   7                      game_pause = 0;
2319   7                    else
2320   7                      game_pause = 1;
2321   7                  }
2322   6                  break;
2323   6                }
2324   5                case KEY3:
2325   5                {
2326   6                  ON_OPEN = 1;
2327   6                  break;
2328   6                }
2329   5              }
2330   4              Trg = 0;
2331   4            }
2332   3            if(ON_CLOSE)
2333   3            {
2334   4              ON_CLOSE = 0;
2335   4              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 39  

2336   4              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
2337   4              func_num = MENU;
2338   4              ON_RETURN = 1;  
2339   4            }
2340   3          }
2341   2          if(action)          //系统在不同状态下对动作的处理
2342   2          {
2343   3            action = 0;
2344   3            if(active_flag)
2345   3              inactive_time = 0;
2346   3            else if(sleep_flag)
2347   3            {
2348   4              sleep_flag = 0;
2349   4              sleep_time = 0;
2350   4              active_flag = 1;
2351   4              ScreenOnOff(ON);
2352   4              screen_on_flag = 1;
2353   4            }
2354   3            else if(powerdown_flag)
2355   3            {
2356   4              powerdown_flag = 0;
2357   4              active_flag = 1;
2358   4              SystemPowerOn();
2359   4              ScreenOnOff(ON);
2360   4              screen_on_flag = 1;
2361   4              ON_OPEN = 1;
2362   4            }
2363   3            else if(deep_powerdown_flag)
2364   3            {
2365   4              deep_powerdown_flag = 0;
2366   4              active_flag = 1;
2367   4              SystemPowerOn();
2368   4              DisplayInit(&config);
2369   4              screen_on_flag = 1;
2370   4              SensorInit();
2371   4              PW02SetMode(0);
2372   4              PCF8563EnableTimer(TIMERCLK_1_60_HZ, 1);  //自动唤醒频率1min一次
2373   4              ON_OPEN = 1;
2374   4            }
2375   3            autowake_cnt = 0;
2376   3          }
2377   2          if(sleep_flag)
2378   2          {
2379   3            if(screen_on_flag)
2380   3            {
2381   4              ScreenOnOff(OFF);
2382   4              screen_on_flag = 0;
2383   4            }
2384   3          }
2385   2          if(powerdown_flag)    
2386   2          {
2387   3            if(ON_CLOSE == 0)
2388   3            {
2389   4              SystemPowerDown();
2390   4            }
2391   3          }
2392   2          if(deep_powerdown_flag)
2393   2          {
2394   3            if(ON_CLOSE == 0)
2395   3            {
2396   4              SystemDeepPowerDown();
*** WARNING C206 IN LINE 2396 OF ..\User\main.c: 'SystemDeepPowerDown': missing function-prototype
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 40  

2397   4            }
2398   3            Enable3V3Output(1);
2399   3            Delay1ms(10);
2400   3          }
2401   2          if(alarm_flag)
2402   2          {
2403   3            sleep_time = 0;     //闹铃被关掉前不会待机
2404   3          }
2405   2          if(timer_on_flag)
2406   2          {
2407   3            sleep_time = 0;     //计时器在工作时不会待机
2408   3          }
2409   2          if(PCF8563_int_flag)  //PCF8563产生了中断信号
2410   2          {
2411   3            unsigned char pcf8563_int_src;
2412   3            PCF8563_int_flag = 0;
2413   3            pcf8563_int_src = PCF8563ReadIntSrc();  //读PCF8563状态寄存器
2414   3            PCF8563ReadTime(&RTC);
2415   3            if(pcf8563_int_src & ALARM_INT)       //如果是闹钟中断
2416   3            {
2417   4              PCF8563ClearAlarmFlag();  //清除闹钟中断标志位
2418   4              action = 1;       //产生动作
2419   4              alarm_flag = 1;   //置位闹钟标志位
2420   4              Beebeebee();      //响铃
2421   4              Delay1ms(5);
2422   4              if(config.alarm_mode == ALARM_WORKDAY)
2423   4              {
2424   5                if(RTC.weekday + 1 > 5)
2425   5                  config.alarm_weekday = 1;
2426   5                else
2427   5                  config.alarm_weekday = RTC.weekday + 1;
2428   5                PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.a
             -larm_mode);
2429   5              }
2430   4              else if(config.alarm_mode != ALARM_EVERYDAY)  //如果闹钟模式不是每天都响
2431   4              {
2432   5                config.alarm_mode = ALARM_DISABLE;  //关闭闹钟
2433   5                PCF8563DisableAlarm();              //关闭闹钟
2434   5              }
2435   4              EEPROMWriteConfiguration(&config);
2436   4            }
2437   3            if(pcf8563_int_src & TIMER_INT)       //如果是定时器中断
2438   3            {
2439   4              PCF8563ClearTimerFlag();  //清除定时器中断标志位
2440   4              //PCF8563以固定的时间间隔唤醒MCU
2441   4              //唤醒之后执行以下内容
2442   4              battery_life = GetBatteryLife();
2443   4              if(active_flag || sleep_flag || powerdown_flag)
2444   4              {
2445   5                if((RTC.hour == 22) && (RTC.minute == 4))   //22:04,记录当天的步数数据
2446   5                {
2447   6                  char i, j;
2448   6                  for(i = 6; i > 0; i--)
2449   6                  {
2450   7                    for(j = 0; j < 10; j++)
2451   7                    {
2452   8                      config.history_step[i][j] = config.history_step[i - 1][j];
2453   8                    }
2454   7                  }
2455   6                  sprintf(config.history_step[0], "%d/%d %d", (int)RTC.month, (int)RTC.day, (int)LSM6DSMGetCurrentStep
             -());
2456   6                  EEPROMWriteConfiguration(&config);
C51 COMPILER V9.52.0.0   MAIN                                                              06/21/2021 07:22:01 PAGE 41  

2457   6                  LSM6DSMResetStepCounter();
2458   6                }
2459   5              }
2460   4              if(powerdown_flag)
2461   4              {
2462   5                if(++autowake_cnt >= 1440)    //1440分钟 = 1天
2463   5                {
2464   6                  autowake_cnt = 0;
2465   6                  powerdown_flag = 0;
2466   6                  PCF8563EnableTimer(TIMERCLK_1_60_HZ, 10); //自动唤醒频率改为10min一次，本来1min一次
2467   6                  deep_powerdown_flag = 1;
2468   6                }
2469   5              }
2470   4            }    
2471   3          }
2472   2            
2473   2          }           
2474   1        }
2475          
2476          
2477            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  18482    ----
   CONSTANT SIZE    =   9022    ----
   XDATA SIZE       =    862     138
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
