C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Objects\main.obj
COMPILER INVOKED BY: E:\install_files\keil\C51\BIN\C51.EXE ..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\
                    -oled;..\User\rtc;..\User\System;..\User;..\User\bluetooth;..\User\radio;..\User\sensor) DEBUG OBJECTEXTEND PRINT(..\List
                    -ings\main.lst) TABS(2) OBJECT(..\Objects\main.obj)

line level    source

   1          #include "Sys.h"
   2          #include "bmp.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "stdlib.h"
   6          #include "string.h"
   7          #include "math.h"
   8          #include "Delay.h"
   9          #include "PowerManage.h"
  10          #include "Buzzer.h"
  11          #include "Display.h"
  12          #include "PW02.h"
  13          #include "PCF8563.h"
  14          #include "BME280.h"                  
  15          #include "HMC5883L.h"                 
  16          #include "RDA5807M.h"
  17          #include "LSM6DSM.h"
  18          #include "Ellipsoid fitting.h"
  19          #include "stc8a.h"
  20          
  21          
  22          
  23          
  24          /***********************状态机相关变量*********************/
  25          enum function func_num = WATCH;    //功能号
  26          char func_index;               //功能索引
  27          bit ON_OPEN = 0;
  28          bit ON_CLOSE = 0;
  29          bit ON_RETURN = 0;
  30          /********************************************************/
  31          /************************时基信号************************/
  32          bit tick_1ms = 0;             //1000Hz
  33          bit tick_8ms = 0;             //125hz
  34          bit tick_20ms = 0;            //50hz
  35          
  36          /*************************工作状态相关变量*******************************/
  37          bit action = 0;             //动态标志位
  38          bit active_flag =1;       //活动标志位
  39          bit sleep_flag = 0;         //睡眠标志位
  40          bit powerdown_flag = 0;     //掉电标志位
  41          bit deep_powerdown_flag = 0;    //深度掉电标志位
  42          unsigned int inactive_time =0;  //自动息屏的时间
  43          unsigned int sleep_time = 0;    //自动待机时间
  44          unsigned int autowake_cnt = 0;  //自动唤醒的次数
  45          bit screen_on_flag = 1;     //屏幕状态标志位
  46          bit PCF8563_int_flag = 0;   //pcf8563中断产生标志位
  47          bit alarm_flag = 0;         //闹铃标志位
  48          bit radio_on_flag = 0;      //收音机工作标志位
  49          bit timer_on_flag = 0;      //计时器工作标志位
  50          /*************************按键相关变量*********************/
  51          unsigned char Trg = 0;      //按键触发值
  52          unsigned char Cont = 0;     //按键持续值
  53          /*************************显示缓存*******************************/
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 2   

  54          extern unsigned char xdata main_cache[];
  55          extern unsigned char xdata sub_cache1[];
  56          extern unsigned char xdata sub_cache2[];          
  57          
  58          struct sys_config config;   //设置信息结构体
  59          struct pcf8563_time RTC;    //时间信息结构体
  60          struct bme280_data BME280;  //bme280数据结构体
  61          struct lsm6dsm_data LSM6DSM;//LSM6DSM 数据结构体
  62          struct cal_data magnet_cal_data;  //磁力计叫做数据结构体
  63          float battery_life;         //电池电量
  64          unsigned int  timer_cnt = 0;//定时器0溢出次数
  65          
  66          
  67          void KeyScan(void)
  68          {
  69   1        unsigned char dat = 0x00;
  70   1        if(K1 == 0)
  71   1          dat |= KEY1;
  72   1        if(K2 == 0)
  73   1          dat |= KEY2;
  74   1        if(K3 ==0)
  75   1          dat |= KEY3;
  76   1        Trg = dat&(dat^Cont);
  77   1        Cont = dat;
  78   1      }
  79          
  80          void TM3_Ist()  interrupt 19 using 1    //  mcu定时器中断
  81          {
  82   1        static unsigned int t_count = 0;
  83   1        static unsigned int t_key_press =0; 
  84   1        AUXINTIF &= ~T3IF;                    //清除中断标志位
  85   1        if((K1 == 0) && (K2 == 0) && (K3 == 0))
  86   1        {
  87   2          while ((K1 == 0) ||(K2 == 0) ||(K3 == 0) ); //三个按键均抬起
  88   2            MCUSoftReset();                         //软复位MCU
  89   2        }
  90   1          if(t_count % 50 == 0)
  91   1        {
  92   2          KeyScan();
  93   2          if(Trg)
  94   2          {
  95   3            Bee();
  96   3            action = 1;
  97   3            if(sleep_flag || powerdown_flag || alarm_flag)
  98   3            {
  99   4              Trg = 0;
 100   4              if(alarm_flag)
 101   4              {
 102   5                alarm_flag = 0;
 103   5                LED(OFF);
 104   5              }
 105   4            }
 106   3          }
 107   2          if(Cont)
 108   2          {
 109   3            if(++t_key_press > 10)  //判断是否长按
 110   3              Trg = Cont;           //重复触发
 111   3          }
 112   2          else
 113   2            t_key_press = 0;
 114   2        }
 115   1        tick_1ms = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 3   

 116   1        if(t_count % 8 == 0)
 117   1          tick_8ms = 1;
 118   1        if(t_count % 20 == 0)
 119   1          tick_20ms = 1;
 120   1        if(++t_count == 1000)
 121   1        {
 122   2          t_count = 0;
 123   2          if(active_flag)
 124   2          {
 125   3            if(++inactive_time == config.t_inactive_max)
 126   3            {
 127   4              active_flag = 0;
 128   4              inactive_time = 0;
 129   4              sleep_flag = 1;
 130   4            }
 131   3          }
 132   2          if(sleep_flag)
 133   2          {
 134   3            if(++sleep_time == config.t_sleep_max)
 135   3            {
 136   4              sleep_flag = 0;
 137   4              sleep_time = 0;
 138   4              powerdown_flag = 1;
 139   4              ON_CLOSE = 1;
 140   4            }
 141   3          }
 142   2        }
 143   1      }
 144          
 145          //void INT0_Isr() interrupt 0           //PCF8563中断
 146          //{
 147          //  PCF8563_int_flag = 1;
 148          //}
 149          void TM0_Isr() interrupt 1 using 1    //计数器0溢出中断
 150          {
 151   1        timer_cnt++;
 152   1      }
 153          void INT1_Isr() interrupt 2 using 1   //双击中断
 154          {
 155   1        action = 1;
 156   1        alarm_flag = 0;
 157   1        Bee();
 158   1        if(sleep_flag || powerdown_flag || alarm_flag)
 159   1          Trg = 0;
 160   1        else
 161   1          Trg = DOUBLE_TAP;
 162   1        if(active_flag && func_num == WATCH)
 163   1        {
 164   2          action = 0;
 165   2          active_flag = 0;
 166   2          inactive_time = 0;
 167   2          ScreenOnOff(OFF);
 168   2          sleep_flag = 1;
 169   2        }
 170   1      }
 171          void INT2_Isr() interrupt 10 using 1  //抬腕唤醒中断
 172          {
 173   1        action = 1;
 174   1        if(sleep_flag || powerdown_flag)
 175   1        {Trg = 0;}
 176   1        else 
 177   1        {Trg = AWT;}
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 4   

 178   1      }
 179          void INT3_Isr() interrupt 11          //按键2中断
 180          {
 181   1        action = 1;
 182   1      }
 183          void SensorInit(void)
 184          {
 185   1        unsigned char y = 0;
 186   1        unsigned int time_out = 700;
 187   1        unsigned char error_count = 0;
 188   1        if(BME280Init() == 0)
 189   1        {
 190   2          y += ShowString(0, y, "BME280 ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 191   2          error_count++;
 192   2        }
 193   1        if(HMC5883L_Init() == 0)
 194   1        {
 195   2          y += ShowString(0, y, "HMC5883L ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 196   2          error_count++;
 197   2        }
 198   1        if(LSM6DSMInit() == 0)
 199   1        {
 200   2          y += ShowString(0, y, "LSM6DSM ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 201   2          error_count++;
 202   2        }
 203   1        if(RDA5807MInit() == 0)
 204   1        {
 205   2          y += ShowString(0, y, "RDA5807M ERROR", main_cache, FONT8X16, NO_INVERSED, 1);
 206   2          error_count++;
 207   2        }
 208   1        if(error_count != 0)
 209   1        {
 210   2          while(Trg == 0)
 211   2          {
 212   3            Delay1ms(1);
 213   3            if(--time_out == 0)
 214   3              break;
 215   3          }
 216   2        }
 217   1      }
 218          
 219          
 220          
 221          
 222          
 223          
 224          void  LED1_ON()
 225          {
 226   1        P35 = 1;
 227   1      }  
 228          void  LED1_OFF()
 229          {
 230   1        P35 = 0;
 231   1      }
 232          
 233          void BreathingLamp(void)
 234          {
 235   1        unsigned int  i=0,  j=0,num=500;
 236   1        for(i=0;i<num;i++)
 237   1          {
 238   2            for(j=0;j<num;j++)
 239   2            {
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 5   

 240   3              if(i>j)
 241   3              {
 242   4                LED1_ON();
 243   4                Delay1us(1);
 244   4              }
 245   3              else
 246   3              {
 247   4                LED1_OFF();
 248   4                Delay1us(1);
 249   4              } 
 250   3            }
 251   2          }
 252   1          Delay1us(1);
 253   1          for(i=0;i<num;i++)
 254   1          {
 255   2            for(j=0;j<num;j++)
 256   2            {
 257   3              if(i>j)
 258   3              {
 259   4                LED1_OFF();
 260   4                Delay1us(1);
 261   4              }
 262   3            
 263   3              else
 264   3              {
 265   4                LED1_ON();
 266   4                Delay1us(1);
 267   4                
 268   4              } 
 269   3            }
 270   2          }
 271   1      }
 272          
 273          
 274          void main()
 275          { 
 276   1        
 277   1        
 278   1      //  SysInit();            //系统初始化
 279   1      //  DisplayInit(&config); //显示初始化     
 280   1      //  PCF8563Init();        //实时时钟初始化        
 281   1      //  SensorInit();         //传感器初始化
 282   1      //  ClearCache(main_cache); //清空主显存
 283   1        
 284   1        //可以控制显示屏的相关控制信号，猜测是灯板的问题，待灯板回来后再重新贴装一个，测试
 285   1        
 286   1      //  OLED_RST_Set();
 287   1      //  OLED_RD_Set();
 288   1      //  OLED_WR_Set();
 289   1      //  OLED_DC_Set();
 290   1      //  P1 = 0x0c;
 291   1      //  P4 = 0x18;
 292   1        
 293   1      //  OLED_RST_Clr();
 294   1      //  OLED_WR_Clr();
 295   1      //  OLED_RD_Clr();                              
 296   1      //  OLED_DC_Clr();
 297   1        P1 = 0x00;
 298   1        P4 = 0x00;
 299   1        
 300   1        
 301   1        
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 6   

 302   1        while(1)
 303   1        
 304   1        {
 305   2          FeedWatchDog();     //喂看门狗
 306   2          BreathingLamp();
 307   2       
 308   2      /*******
 309   2       
 310   2          if(func_num == WATCH)           //显示表盘
 311   2          {
 312   2            unsigned char x, n, m;
 313   2            unsigned char str[16];
 314   2            if(ON_OPEN)     //进入该功能时执行的内容
 315   2            {
 316   2              ON_OPEN = 0;
 317   2              if(func_index == FIRST_FUNC)
 318   2                ScreenPushAnimation(sub_cache1, DOWN);
 319   2              else if(func_index == LAST_FUNC)
 320   2                ScreenPushAnimation(sub_cache1, UP);
 321   2              func_index = WATCH;
 322   2            }
 323   2            if(ON_RETURN)   //返回该功能时执行的内容
 324   2            {
 325   2              ON_RETURN = 0;
 326   2            }
 327   2            
 328   2            if(tick_20ms)   //在功能里时，每20ms执行一次功能内容
 329   2            {
 330   2              tick_20ms = 0;
 331   2              //显示时间
 332   2              PCF8563ReadTime(&RTC);
 333   2              //printf("%d:%d:%d\n", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
 334   2              DisplayTime(RTC.hour, RTC.minute, RTC.second);
 335   2              //显示小图标
 336   2              ClearCacheArea(0, 0, 35, 8, main_cache);
 337   2              x = 0;
 338   2              BMPToCache(x, 0, 8, 8, BLUETOOTH_SMALL_ICON, main_cache, 0);
 339   2              x += 9;
 340   2              if(timer_on_flag)
 341   2              {
 342   2                BMPToCache(x, 0, 8, 8, TIMER_SMALL_ICON, main_cache, 0);
 343   2                x += 9;
 344   2              }
 345   2              if(config.alarm_mode != ALARM_DISABLE)
 346   2              {
 347   2                BMPToCache(x, 0, 8, 8, CLOCK_SMALL_ICON, main_cache, 0);
 348   2                x += 9;
 349   2              }
 350   2              if(radio_on_flag)
 351   2                BMPToCache(x, 0, 8, 8, RADIO_SMALL_ICON, main_cache, 0);
 352   2              //显示日期，星期
 353   2              ClearCacheArea(0, 7, 128, 8, main_cache);
 354   2              sprintf(str, "%d/%d/%d ", (int)RTC.year, (int)RTC.month, (int)RTC.day);
 355   2              strcat(str, WEEKDAY_IN_STR[RTC.weekday - 1]);
 356   2              ShowString(0, 7, str, main_cache, FONT6X8, NO_INVERSED, 0);
 357   2              //显示电量
 358   2              battery_life = GetBatteryLife();
 359   2              for(n = 0; n < 24; n++)
 360   2                str[n] = BATTERY_LIFE_ICON[n];
 361   2              m = 18 * battery_life;
 362   2              for(n = 2; n < 2 + m; n++)
 363   2                str[n] |= 0x3c;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 7   

 364   2              BMPToCache(104, 0, 24, 8, str, main_cache, 0);
 365   2              sprintf(str, "%3d%%", (int)(battery_life * 100));
 366   2              ShowString(78, 0, str, main_cache, FONT6X8, NO_INVERSED, 1);
 367   2            }
 368   2            
 369   2            if(Trg != 0)    //在该功能下对按键事件的处理
 370   2            {
 371   2              switch(Trg)
 372   2              {
 373   2                case KEY1:
 374   2                {
 375   2                  func_num = SUB_MENU;
 376   2                  ON_CLOSE = 1;
 377   2                  break;
 378   2                }
 379   2                case KEY2:
 380   2                {
 381   2                  func_index = FIRST_FUNC;
 382   2                  func_num = MENU;
 383   2                  ON_CLOSE = 1;
 384   2                  break;
 385   2                } 
 386   2                case KEY3:
 387   2                {
 388   2                  func_index = LAST_FUNC;
 389   2                  func_num = MENU;
 390   2                  ON_CLOSE = 1;
 391   2                  break;
 392   2                }
 393   2                case KEY13:
 394   2                {
 395   2                  active_flag = 0;
 396   2                  sleep_flag = 0;
 397   2                  powerdown_flag = 0;
 398   2                  inactive_time = 0;
 399   2                  sleep_time = 0;
 400   2                  deep_powerdown_flag = 1;
 401   2                  ON_CLOSE = 1;
 402   2                  break;
 403   2                }
 404   2              }
 405   2              Trg = 0;
 406   2            }
 407   2            if(ON_CLOSE)    //关闭该功能时执行的内容
 408   2            {
 409   2              ON_CLOSE = 0;
 410   2              SaveScreen();
 411   2              ON_OPEN = 1;
 412   2            }
 413   2          }
 414   2          else if(func_num == MENU)       //主菜单    ok
 415   2              {
 416   2            if(ON_OPEN)
 417   2            {
 418   2              ClearCache(sub_cache2);
 419   2              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 420   2              if(func_index == FIRST_FUNC)
 421   2                ScreenPushAnimation(sub_cache2, UP);
 422   2              else
 423   2                ScreenPushAnimation(sub_cache2, DOWN);
 424   2              ON_OPEN = 0;
 425   2            }
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 8   

 426   2            if(ON_RETURN)
 427   2            {
 428   2              ON_RETURN = 0;
 429   2              ClearCache(sub_cache2);
 430   2              BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, COVER);
 431   2              ScreenPushAnimation(sub_cache2, RIGHT);
 432   2            }
 433   2            if(Trg != 0)
 434   2            {
 435   2              switch(Trg)
 436   2              {
 437   2                case KEY1:
 438   2                {
 439   2                  goto case_AWT;
 440   2                  break;
 441   2                }
 442   2                case KEY2:
 443   2                {
 444   2                  if(++func_index > FUNC_NUM_MAX - 1)
 445   2                  {
 446   2                    func_index = LAST_FUNC;
 447   2                    func_num = WATCH;
 448   2                    ON_CLOSE = 1;
 449   2                  }
 450   2                  else
 451   2                  {
 452   2                    ClearCache(sub_cache2);
 453   2                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 454   2                    ScreenPushAnimation(sub_cache2, UP);
 455   2                  }
 456   2                  break;
 457   2                }
 458   2                case KEY3:
 459   2                {
 460   2                  if(--func_index < 0)
 461   2                  {
 462   2                    func_index = FIRST_FUNC;
 463   2                    func_num = WATCH;
 464   2                    ON_CLOSE = 1;
 465   2                  }
 466   2                  else
 467   2                  {
 468   2                    ClearCache(sub_cache2);
 469   2                    BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 470   2                    ScreenPushAnimation(sub_cache2, DOWN);
 471   2                  }
 472   2                  break;
 473   2                }
 474   2                case DOUBLE_TAP:
 475   2                {
 476   2                  func_num = func_index;
 477   2                  ON_CLOSE= 1;
 478   2                  break;
 479   2                }
 480   2                case AWT:
 481   2                {
 482   2                  case_AWT:
 483   2                  if(func_index <= (FUNC_NUM_MAX - func_index))
 484   2                  {
 485   2                    while(func_index > 0)
 486   2                    {
 487   2                      func_index --;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 9   

 488   2                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 489   2                      ScreenPushAnimation(sub_cache2, DOWN);
 490   2                    }
 491   2                  }
 492   2                  else
 493   2                  {
 494   2                    while(func_index < FUNC_NUM_MAX - 1)
 495   2                    {
 496   2                      func_index ++;
 497   2                      BMPToCache(32, 0, 64, 64, FUNC_ICON[func_index], sub_cache2, 0);
 498   2                      ScreenPushAnimation(sub_cache2, UP);
 499   2                    }
 500   2                  }
 501   2                  func_num = WATCH;
 502   2                  ON_CLOSE = 1;
 503   2                  break;
 504   2                }
 505   2              }
 506   2              Trg = 0;
 507   2            }
 508   2            if(ON_CLOSE)
 509   2            {
 510   2              ON_CLOSE = 0;
 511   2              ON_OPEN = 1;
 512   2            }
 513   2          }
 514   2          else if(func_num == SUB_MENU)   //次菜单    ok
 515   2          {
 516   2            
 517   2            char x, y;
 518   2            if(ON_OPEN)
 519   2            {
 520   2              ON_OPEN = 0;
 521   2              ClearCache(sub_cache2);
 522   2              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, sub_cache2, COVER);
 523   2              ScreenPushAnimation(sub_cache2, LEFT);
 524   2              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 525   2              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 526   2              LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 527   2            }
 528   2            if(tick_8ms)        //姿态解算频率：125hz
 529   2            {
 530   2              tick_8ms = 0;
 531   2              LSM6DSMReadGYRAndACC(&LSM6DSM);
 532   2              IMUupdate(&LSM6DSM);
 533   2            }
 534   2            if(tick_20ms)
 535   2            {
 536   2              tick_20ms = 0;
 537   2              LSM6DSM.AngleX -= config.cal_anglex;  //倾角减去偏移
 538   2              LSM6DSM.AngleY -= config.cal_angley;  //倾角减去偏移
 539   2              LSM6DSM.AngleY -= 30;
 540   2              LSM6DSM.AngleX *= 3;      //调整一下横向灵敏度
 541   2              LSM6DSM.AngleY *= 2;      //调整一下纵向灵敏度
 542   2              if(LSM6DSM.AngleX > 63)   //对计算结果进行限幅
 543   2                LSM6DSM.AngleX = 63;
 544   2              else if(LSM6DSM.AngleX < -64)
 545   2                LSM6DSM.AngleX = -64;
 546   2              if(LSM6DSM.AngleY > 31)
 547   2                LSM6DSM.AngleY = 31;
 548   2              else if(LSM6DSM.AngleY < -31)
 549   2                LSM6DSM.AngleY = -31;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 10  

 550   2              x = 64 + LSM6DSM.AngleX;
 551   2              y = 32 + LSM6DSM.AngleY;
 552   2              if(x > 96)
 553   2                x = 96;
 554   2              if(y > 32)
 555   2                y = 32;
 556   2              ClearCache(main_cache);       //清空主缓存
 557   2              BMPToCache(0, 0, 128, 64, SUB_MENU_BMP, main_cache, COVER); //画菜单背景到主显存上
 558   2              DrawSelectionFrame(x, y);     //根据xy坐标画选择框到主显存上
 559   2              ScreenRefreshAll(main_cache); //将主显存刷新到OLED屏幕上
 560   2            }
 561   2            if(Cont == 0)
 562   2            {
 563   2              func_index = (enum function)((x + 16) / 32 + ((y + 16) / 32) * 4);
 564   2              func_num = func_index;
 565   2              ON_CLOSE = 1;
 566   2            }
 567   2            if(ON_CLOSE)
 568   2            {
 569   2              ON_CLOSE = 0;
 570   2              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
 571   2              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 572   2              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 573   2              ON_OPEN = 1;
 574   2            }
 575   2          }
 576   2          else if(func_num == STOPWATCH)  //计时器    ok
 577   2          { 
 578   2            unsigned char t = 0, t_x = 0, t_y = 2;
 579   2            static int ms = 0, sec = 0, min = 0;
 580   2            static unsigned char n = 0, x = 0, y = 2;
 581   2            static unsigned char str1[10][11];
 582   2            unsigned char str2[10];
 583   2            if(ON_OPEN)
 584   2            {
 585   2              ON_OPEN = 0;
 586   2              ClearCache(sub_cache2);
 587   2              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 588   2              sec = ms / 100 % 60;
 589   2              min = sec / 60;
 590   2              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 591   2              ShowString(32, 0, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 592   2              if(n != 0)
 593   2              {
 594   2                for(t = 0; t < n; t++)
 595   2                {
 596   2                  if(t == 6)
 597   2                  {
 598   2                    t_x = 64;
 599   2                    t_y = 2;
 600   2                  }
 601   2                  ShowString(t_x, t_y++, str1[t], sub_cache2, FONT6X8, NO_INVERSED, 0);
 602   2                }
 603   2              }
 604   2              ScreenPushAnimation(sub_cache2, LEFT);
 605   2              ClearCache(sub_cache2);
 606   2            }
 607   2            if(tick_1ms)
 608   2            {
 609   2              tick_1ms = 0;
 610   2              ms = (timer_cnt * 65536 + ((TH0 << 8) | TL0)) / 10.24;
 611   2              sec = ms / 100;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 11  

 612   2              min = sec / 60;
 613   2              sprintf(str2, "%02d:%02d:%02d", min, sec % 60, ms % 100);
 614   2              ShowString(32, 0, str2, main_cache, FONT8X16, NO_INVERSED, 1);
 615   2              sleep_time = 0;
 616   2            }
 617   2            if(Trg != 0)
 618   2            {
 619   2              switch(Trg)
 620   2              {
 621   2                case KEY1:
 622   2                {
 623   2                  ON_CLOSE = 1;
 624   2                  break;
 625   2                }
 626   2                case KEY2:
 627   2                {
 628   2                  if(TR0)
 629   2                  {
 630   2                    TR0 = 0;
 631   2                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, DISABLE_CLKOUT);
 632   2                    timer_on_flag = 0;
 633   2                  }
 634   2                  else
 635   2                  {
 636   2                    PCF8563EnableClockOuput(CLKOUT_1024_HZ, ENABLE_CLKOUT);
 637   2                    TR0 = 1;
 638   2                    timer_on_flag = 1;
 639   2                  }
 640   2                  break;
 641   2                }
 642   2                case KEY3:
 643   2                {
 644   2                  timer_cnt = 0;
 645   2                  TH0 = 0;
 646   2                  TL0 = 0;
 647   2                  ms = 0;
 648   2                  sec = 0;
 649   2                  min = 0;
 650   2                  n = 0;
 651   2                  x = 0;
 652   2                  y = 2;
 653   2                  ClearCache(main_cache);
 654   2                  break;
 655   2                }
 656   2                case DOUBLE_TAP:
 657   2                {
 658   2                  if(n < 9 && timer_on_flag == 1)
 659   2                  {
 660   2                    if(n == 6)
 661   2                    {
 662   2                      x = 64;
 663   2                      y = 2;
 664   2                    }
 665   2                    sprintf(str1[n], "%d.%02d:%02d:%02d\0", (int)(n + 1), min, sec % 60, ms % 100);
 666   2                    ShowString(x + 0, y++, str1[n++], main_cache, FONT6X8, NO_INVERSED, 1);
 667   2                  }
 668   2                  break;
 669   2                }
 670   2              }
 671   2              Trg = 0;
 672   2            }
 673   2            if(ON_CLOSE)
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 12  

 674   2            {
 675   2              ON_CLOSE = 0;
 676   2              func_num = MENU;
 677   2              ON_RETURN = 1;
 678   2            }
 679   2          }
 680   2          else if(func_num == PEDOMETER)  //计步器    ok
 681   2          {
 682   2            unsigned char n;
 683   2            unsigned int step;
 684   2            unsigned char buf[8];
 685   2            if(ON_OPEN)
 686   2            {
 687   2              ON_OPEN = 0;
 688   2      //        PCF8563ReadTime(&RTC);
 689   2              ClearCache(sub_cache2);
 690   2              ShowString(0, 0, "Today:    History:", sub_cache2, FONT6X8, NO_INVERSED, 0);
 691   2              step = LSM6DSMGetCurrentStep();
 692   2              sprintf(buf, "%d ", step);
 693   2              ShowString(0, 1, buf, sub_cache2, FONT8X16, NO_INVERSED, 0);    
 694   2              ScreenPushAnimation(sub_cache2, LEFT);
 695   2            }
 696   2            if(tick_20ms)
 697   2            {
 698   2              tick_20ms = 0;
 699   2              step = LSM6DSMGetCurrentStep();
 700   2              sprintf(buf, "%d ", step);
 701   2              ShowString(0, 1, buf, main_cache, FONT8X16, NO_INVERSED, 0);
 702   2              for(n = 0; n < 7; n++)
 703   2              {
 704   2                ShowString(64, n + 1, config.history_step[n], main_cache, FONT6X8, NO_INVERSED, 1);
 705   2              }
 706   2            }
 707   2            if(Trg != 0)
 708   2            {
 709   2              switch(Trg)
 710   2              {
 711   2                case KEY1:
 712   2                {
 713   2                  ON_CLOSE = 1;
 714   2                  break;
 715   2                }
 716   2                case KEY2:
 717   2                {
 718   2                  //LSM6DSMResetStepCounter();
 719   2                  break;
 720   2                } 
 721   2              }
 722   2              Trg = 0;
 723   2            }
 724   2            if(ON_CLOSE)
 725   2            {
 726   2              ON_CLOSE = 0;
 727   2              func_num = MENU;
 728   2              ON_RETURN = 1;
 729   2            }
 730   2          }
 731   2          else if(func_num == THPMETER)   //温湿度计  ok
 732   2          {   
 733   2            float altitude;
 734   2            unsigned char str1[10] = {0};
 735   2            if(ON_OPEN)
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 13  

 736   2            {
 737   2              ON_OPEN = 0;
 738   2              ClearCache(sub_cache2);
 739   2              BMPToCache(0, 0, 48, 64, T_H_P_A, sub_cache2, 0);
 740   2              sprintf(str1, "%.1f", BME280.temperature);
 741   2              ShowString(48, 0, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 742   2              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, sub_cache2, 0);
 743   2              sprintf(str1, "%.1f%%", BME280.humidity);
 744   2              ShowString(48, 2, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 745   2              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 746   2              ShowString(48, 4, str1, sub_cache2, FONT8X16, NO_INVERSED, 0);
 747   2              ScreenPushAnimation(sub_cache2, LEFT);
 748   2              BME280ContinuousMeasurement(MS_125);    //连续测量模式，测量间隔125ms
 749   2            }
 750   2            if(tick_20ms)
 751   2            {
 752   2              tick_20ms = 0;
 753   2              BME280GetSensorData(&BME280);         //读BME280测量数据并显示
 754   2              altitude = 44330.77 * (1 - pow((BME280.pressure / 101500), 0.190263));
 755   2              ClearCache(main_cache);
 756   2              BMPToCache(0, 0, 48, 64, T_H_P_A, main_cache, 0);
 757   2              sprintf(str1, "%.1f", BME280.temperature);
 758   2              ShowString(48, 0, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 759   2              BMPToCache(84, 0, 16, 16, CELSIUS_ICON, main_cache, 0);
 760   2              sprintf(str1, "%.1f %%", BME280.humidity);
 761   2              ShowString(48, 2, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 762   2              sprintf(str1, "%ld Pa", (long)BME280.pressure);
 763   2              ShowString(48, 4, str1, main_cache, FONT8X16, NO_INVERSED, 0);
 764   2              sprintf(str1, "%d m", (int)altitude);
 765   2              ShowString(48, 6, str1, main_cache, FONT8X16, NO_INVERSED, 1);
 766   2            }
 767   2            if(Trg == KEY1)
 768   2            {
 769   2              Trg = 0;
 770   2              ON_CLOSE = 1;
 771   2            }
 772   2            if(ON_CLOSE)
 773   2            {
 774   2              ON_CLOSE = 0;
 775   2              BME280SetMode(SLEEP_MODE);
 776   2              func_num = MENU;
 777   2              ON_RETURN = 1;
 778   2            }
 779   2          }
 780   2          else if(func_num == RADIO)      //收音机    ok
 781   2          {
 782   2            static unsigned char index = 0;
 783   2            static bit searching_flag = 0;
 784   2            static unsigned char search_direction;
 785   2            float temp;
 786   2            unsigned char str2[16];
 787   2            if(ON_OPEN)
 788   2            {
 789   2              ON_OPEN = 0;
 790   2              ClearCache(sub_cache2);
 791   2              ShowString(80, 0, "volume", sub_cache2, FONT8X16, NO_INVERSED, 0);
 792   2              sprintf(str2,"%.1fMHz",config.radio_channel);
 793   2              ShowString(40, 3, str2, sub_cache2, FONT8X16, NO_INVERSED, 0);
 794   2              ShowString(0, 6, "tune", sub_cache2, FONT8X16, NO_INVERSED, 0);
 795   2              ShowString(80, 6, "search", sub_cache2, FONT8X16, NO_INVERSED, 0);
 796   2              ShowString(0, 0, "close", main_cache, FONT8X16, NO_INVERSED, 0);
 797   2              ScreenPushAnimation(sub_cache2, LEFT);
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 14  

 798   2              if(radio_on_flag != 1)
 799   2              {
 800   2                RDA5807MPowerUp();
 801   2                RDA5807MSetFq(config.radio_channel);
 802   2                if(config.radio_volume > 0x0f)
 803   2                  config.radio_volume = 0;
 804   2                RDA5807MSetVOLUME(config.radio_volume);
 805   2                radio_on_flag = 1;
 806   2              }
 807   2            }
 808   2            if(tick_20ms)
 809   2            {
 810   2              tick_20ms = 0;
 811   2              ClearCache(main_cache);
 812   2              ShowString(80, 0, "volume", main_cache, FONT8X16, index == 0?INVERSED:NO_INVERSED, 0);
 813   2              sprintf(str2,"%.1fMHz", config.radio_channel);
 814   2              ShowString(40, 3, str2, main_cache, FONT8X16, NO_INVERSED, 0);
 815   2              if(searching_flag)
 816   2              {
 817   2                temp = RDA5807MSEEK(search_direction);
 818   2                if(temp == 0)
 819   2                  ShowString(28, 5, "searching...", main_cache, FONT6X8, NO_INVERSED, 0);
 820   2                else
 821   2                {
 822   2                  config.radio_channel = temp;
 823   2                  searching_flag = 0;
 824   2                }
 825   2              }
 826   2              ShowString(80, 6, "search", main_cache, FONT8X16, index == 1?INVERSED:NO_INVERSED, 0);
 827   2              ShowString(0, 6, "tune", main_cache, FONT8X16, index == 2?INVERSED:NO_INVERSED, 0);
 828   2              ShowString(0, 0, "close", main_cache, FONT8X16, index == 3?INVERSED:NO_INVERSED, 1);
 829   2            }
 830   2            if(Trg != 0)
 831   2            {
 832   2              switch(Trg)
 833   2              {
 834   2                case KEY1:
 835   2                {
 836   2                  ON_CLOSE = 1;
 837   2                  break;
 838   2                }
 839   2                case KEY2:
 840   2                {
 841   2                  if(index == 0)
 842   2                  {
 843   2                    if(++config.radio_volume > 0x0f)
 844   2                      config.radio_volume = 0x0f;
 845   2                    RDA5807MSetVOLUME(config.radio_volume);
 846   2                  }
 847   2                  else if(index == 1)
 848   2                  {
 849   2                    search_direction = UPWARD;
 850   2                    searching_flag = 1;
 851   2                  }
 852   2                  else if(index == 2)
 853   2                  {
 854   2                    config.radio_channel += 0.1;
 855   2                    if(config.radio_channel > 108)
 856   2                      config.radio_channel = 87;
 857   2                    RDA5807MSetFq(config.radio_channel);
 858   2                  }
 859   2                  break;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 15  

 860   2                } 
 861   2                case KEY3:
 862   2                {
 863   2                  if(index == 0)
 864   2                  {
 865   2                    if(--config.radio_volume == 255)
 866   2                      config.radio_volume = 0;
 867   2                    RDA5807MSetVOLUME(config.radio_volume);
 868   2                  }
 869   2                  else if(index == 1)
 870   2                  {
 871   2                    search_direction = DOWNWARD;
 872   2                    searching_flag = 1;
 873   2                  }
 874   2                  else if(index == 2)
 875   2                  {
 876   2                    config.radio_channel -= 0.1;
 877   2                    if(config.radio_channel < 87)
 878   2                      config.radio_channel = 108;
 879   2                    RDA5807MSetFq(config.radio_channel);
 880   2                  }
 881   2                  break;
 882   2                }
 883   2                case DOUBLE_TAP:
 884   2                {
 885   2                  if(++index == 4)
 886   2                    index = 0;
 887   2                  break;
 888   2                }
 889   2              }
 890   2              Trg = 0;
 891   2            }
 892   2            if(ON_CLOSE)
 893   2            {
 894   2              ON_CLOSE = 0;
 895   2              if(powerdown_flag == 0 && index == 3)
 896   2              {
 897   2                RDA5807MPowerDown();
 898   2                radio_on_flag = 0;
 899   2                index = 0;  
 900   2                EEPROMWriteConfiguration(&config);
 901   2              }
 902   2              func_num = MENU;
 903   2              ON_RETURN = 1;
 904   2            }
 905   2          }
 906   2          else if(func_num == COMPASS)    //磁力计    ok
 907   2          {
 908   2            //显示角度和指针
 909   2            static char mode = 0;
 910   2            int magnet_data[3] = {0};
 911   2            unsigned char str3[16];
 912   2            if(mode == 0)     
 913   2            {
 914   2              unsigned char n;
 915   2              int angle_from_north;
 916   2              if(ON_OPEN)
 917   2              {
 918   2                ON_OPEN = 0;
 919   2                ClearCache(sub_cache2);
 920   2                sprintf(str3, "%d  ", angle_from_north);
 921   2                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 16  

 922   2                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 923   2                ScreenPushAnimation(sub_cache2, LEFT);
 924   2                //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
 925   2                LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
 926   2                LSM6DSMConfigGyr(ACC_ODR_208_HZ, GYR_SCALE_500_DPS);
 927   2                HMC5883L_Set_Mode(0);                   //设置连续测量模式
 928   2                HMC5883L_Set_Calibration_Value(config.cal_magnet_x0, config.cal_magnet_y0, config.cal_magnet_z0, 
 929   2                                              config.cal_magnet_ab, config.cal_magnet_ac);  //设置校准参数
 930   2              }
 931   2              if(ON_RETURN)
 932   2              {
 933   2                ON_RETURN = 0;
 934   2                ClearCache(sub_cache2);
 935   2                BMPToCache(16, 2, 32, 16, NESW[n], sub_cache2, COVER);
 936   2                sprintf(str3, "%d  ", angle_from_north);
 937   2                ShowString(24, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, COVER);
 938   2                BMPToCache(64, 0, 64, 64, COMPASS_ICON, sub_cache2, COVER);
 939   2                ScreenPushAnimation(sub_cache2, RIGHT);
 940   2              }
 941   2              if(tick_8ms)
 942   2              {
 943   2                tick_8ms = 0; 
 944   2                LSM6DSMReadGYRAndACC(&LSM6DSM);
 945   2                IMUupdate(&LSM6DSM);
 946   2              }
 947   2              if(tick_20ms)
 948   2              {
 949   2                tick_20ms = 0;
 950   2                Read_HMC5883L(magnet_data);
 951   2                angle_from_north = (int)HMC5883L_Get_AngleXY(magnet_data, (int)LSM6DSM.AngleX, (int)LSM6DSM.AngleY);
 952   2                angle_from_north += 90;
 953   2                if(angle_from_north >= 360)
 954   2                  angle_from_north -= 360;
 955   2                n = (angle_from_north + 22.5) / 45;
 956   2                if(n == 8)
 957   2                  n = 0;
 958   2                BMPToCache(16, 2, 32, 16, NESW[n], main_cache, 0);
 959   2                sprintf(str3, "%d  ", angle_from_north);
 960   2                ShowString(24, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
 961   2                BMPToCache(64, 0, 64, 64, COMPASS_ICON, main_cache, 0);
 962   2                angle_from_north -= 90;
 963   2                if(angle_from_north < 0)
 964   2                  angle_from_north += 360;
 965   2                DrawArm(95, 31, 18, angle_from_north);
 966   2                ScreenRefreshAll(main_cache);
 967   2              }
 968   2              if(Trg != 0)
 969   2              {
 970   2                switch(Trg)
 971   2                {
 972   2                  case KEY1:
 973   2                  {
 974   2                    ON_CLOSE = 1;
 975   2                    break;
 976   2                  }
 977   2                  case KEY2:
 978   2                  {
 979   2                    mode = 1;
 980   2                    ON_OPEN = 1;
 981   2                    break;
 982   2                  } 
 983   2                }
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 17  

 984   2                Trg = 0;
 985   2              }
 986   2              if(ON_CLOSE)
 987   2              {
 988   2                ON_CLOSE = 0;
 989   2                HMC5883L_Set_Mode(2);  //设置睡眠模式
 990   2                LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
 991   2                LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
 992   2                func_num = MENU;
 993   2                ON_RETURN = 1;
 994   2              }
 995   2            }
 996   2            else if(mode == 1)  //磁力计椭球校准
 997   2            {
 998   2              static int data_cnt = 0;
 999   2              if(ON_OPEN)
1000   2              {
1001   2                ON_OPEN = 0;
1002   2                ClearCache(sub_cache2);
1003   2                sprintf(str3, "x:%d", magnet_data[0]);
1004   2                ShowString(0, 0, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
1005   2                sprintf(str3, "y:%d", magnet_data[1]);
1006   2                ShowString(0, 2, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
1007   2                sprintf(str3, "z:%d", magnet_data[2]);
1008   2                ShowString(0, 4, str3, sub_cache2, FONT8X16, NO_INVERSED, 0);
1009   2                ScreenPushAnimation(sub_cache2, LEFT);
1010   2                ResetMatrix();
1011   2                HMC5883L_Set_Calibration_Value(0, 0, 0, 1, 1);  //清除校准参数
1012   2              }
1013   2              if(tick_20ms)
1014   2              {
1015   2                tick_20ms = 0;
1016   2                Read_HMC5883L(magnet_data);
1017   2                CalcData_Input(magnet_data[0], magnet_data[1], magnet_data[2]);
1018   2                sprintf(str3, "x:%d", magnet_data[0]);
1019   2                ShowString(0, 0, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1020   2                sprintf(str3, "y:%d", magnet_data[1]);
1021   2                ShowString(0, 2, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1022   2                sprintf(str3, "z:%d", magnet_data[2]);
1023   2                ShowString(0, 4, str3, main_cache, FONT8X16, NO_INVERSED, 0);
1024   2                sprintf(str3, "data_cnt:%d", data_cnt);
1025   2                ShowString(0, 6, str3, main_cache, FONT8X16, NO_INVERSED, 1);
1026   2                if(++data_cnt == 5000)
1027   2                {
1028   2                  ON_CLOSE = 1;
1029   2                  Bee();
1030   2                }
1031   2              }
1032   2              if(Trg == KEY1)
1033   2              {
1034   2                Trg = 0;
1035   2                ON_CLOSE = 1;
1036   2              }
1037   2              if(ON_CLOSE)
1038   2              {
1039   2                ON_CLOSE = 0;
1040   2                Ellipsoid_fitting_Process(&magnet_cal_data);    //椭球校准算法
1041   2                HMC5883L_Set_Calibration_Value(magnet_cal_data.X0, magnet_cal_data.Y0, magnet_cal_data.Z0, 
1042   2                                              magnet_cal_data.A / magnet_cal_data.B, 
1043   2                                              magnet_cal_data.A / magnet_cal_data.C);//设置校准参数
1044   2                config.cal_magnet_x0 = magnet_cal_data.X0;
1045   2                config.cal_magnet_y0 = magnet_cal_data.Y0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 18  

1046   2                config.cal_magnet_z0 = magnet_cal_data.Z0;
1047   2                config.cal_magnet_ab = magnet_cal_data.A / magnet_cal_data.B;
1048   2                config.cal_magnet_ac = magnet_cal_data.A / magnet_cal_data.C;
1049   2                EEPROMWriteConfiguration(&config);
1050   2                data_cnt = 0;
1051   2                mode = 0;
1052   2                ON_RETURN = 1;
1053   2              }
1054   2            }
1055   2          }
1056   2          
1057   2          else if(func_num == BLUETOOTH)  //蓝牙    ok
1058   2          {
1059   2            unsigned char bluetooth_data[128] = "\0";
1060   2            static bit bluetooth_init = 0;
1061   2            static unsigned char y = 0;
1062   2            static unsigned char connected = 0;
1063   2            if(ON_OPEN)
1064   2            {
1065   2              ON_OPEN = 0;
1066   2              ClearCache(sub_cache2);
1067   2              ScreenPushAnimation(sub_cache2, LEFT);
1068   2              if(bluetooth_init == 0)
1069   2              {
1070   2                while(PW02Init() == 0);       //蓝牙初始化
1071   2                bluetooth_init = 1;
1072   2              }
1073   2              PW02SetMode(1);
1074   2              y = 0;
1075   2            }
1076   2            if(tick_20ms)
1077   2            {
1078   2              tick_20ms = 0;
1079   2              if(connected == 0)
1080   2              {
1081   2                if(PW02CheckConnection())
1082   2                {
1083   2                  connected = 1;
1084   2                  y = 6;
1085   2                }
1086   2              }
1087   2              if((connected == 1) && PW02GetRxData(bluetooth_data))
1088   2                y += ShowString(0, y, bluetooth_data, main_cache, FONT8X16, NO_INVERSED, 1);
1089   2            }
1090   2            if(Trg != 0)
1091   2            {
1092   2              switch(Trg)
1093   2              {
1094   2                case KEY1:
1095   2                {
1096   2                  ON_CLOSE = 1;
1097   2                  break;
1098   2                }
1099   2                case KEY2:
1100   2                {
1101   2                  ClearCache(main_cache);
1102   2                  y = 0;
1103   2                  y += ShowString(0, y, "Screen cleaned", main_cache, FONT8X16, NO_INVERSED, 1);
1104   2                  break;
1105   2                } 
1106   2              }
1107   2              Trg = 0;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 19  

1108   2            }
1109   2            if(ON_CLOSE)
1110   2            {
1111   2              ON_CLOSE = 0;
1112   2              if(connected == 0)
1113   2                while(PW02ExitATMode() == 0);
1114   2              else
1115   2                connected = 0;
1116   2              PW02SetMode(0);
1117   2              func_num = MENU;
1118   2              ON_RETURN = 1;
1119   2            }
1120   2          }
1121   2          else if(func_num == SPIRIT_LEVEL) //水平仪  ok
1122   2          {
1123   2            int x, y;
1124   2            unsigned char str[16];
1125   2            if(ON_OPEN)
1126   2            {
1127   2              ON_OPEN = 0;
1128   2              ClearCache(sub_cache2);
1129   2              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1130   2              ShowString(0, 0, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1131   2              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1132   2              ShowString(0, 1, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1133   2              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1134   2              ShowString(0, 2, str, sub_cache2, FONT6X8, NO_INVERSED, 0);
1135   2              BMPToCache(56, 3, 16, 16, CIRCLE16X16, sub_cache2, 0);
1136   2              ScreenPushAnimation(sub_cache2, LEFT);
1137   2              //LSM6DSMSetODR(ACC_ODR_208_HZ, GYR_ODR_208_HZ);
1138   2              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
1139   2              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
1140   2            }
1141   2            if(tick_8ms)
1142   2            {
1143   2              tick_8ms = 0;
1144   2              LSM6DSMReadGYRAndACC(&LSM6DSM);
1145   2              IMUupdate(&LSM6DSM);
1146   2            }
1147   2            if(tick_20ms)
1148   2            {
1149   2              tick_20ms = 0;
1150   2              ClearCache(main_cache);
1151   2              LSM6DSM.AngleX -= config.cal_anglex;
1152   2              LSM6DSM.AngleY -= config.cal_angley;
1153   2              sprintf(str, "x:%.1f  ", LSM6DSM.AngleX);
1154   2              ShowString(0, 0, str, main_cache, FONT6X8, NO_INVERSED, 0);
1155   2              sprintf(str, "y:%.1f  ", LSM6DSM.AngleY);
1156   2              ShowString(0, 1, str, main_cache, FONT6X8, NO_INVERSED, 0);
1157   2              sprintf(str, "z:%.1f  ", LSM6DSM.AngleZ);
1158   2              ShowString(0, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
1159   2              BMPToCache(56, 3, 16, 16, CIRCLE16X16, main_cache, 0);
1160   2              x = 64 + LSM6DSM.AngleX;
1161   2              y = 32 + LSM6DSM.AngleY;
1162   2              if(x > 126)
1163   2                x = 126;
1164   2              else if(x < 1)
1165   2                x = 1;
1166   2              if(y > 62)
1167   2                y = 62;
1168   2              else if(y < 1)
1169   2                y = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 20  

1170   2              if(x ==63 && y == 32)
1171   2                ScreenSetInverse(config.screen_inverse == NO_INVERSED?INVERSED:NO_INVERSED);
1172   2              else
1173   2                ScreenSetInverse(config.screen_inverse);
1174   2              DrawDot(x, y);
1175   2              DrawDot(x - 1, y);
1176   2              DrawDot(x + 1, y);
1177   2              DrawDot(x, y + 1);
1178   2              DrawDot(x, y - 1);
1179   2              ScreenRefreshAll(main_cache);
1180   2            }
1181   2            if(Trg != 0)
1182   2            {
1183   2              switch(Trg)
1184   2              {
1185   2                case KEY1:
1186   2                {
1187   2                  ON_CLOSE = 1;
1188   2                  break;
1189   2                }
1190   2                case KEY2:
1191   2                {
1192   2                  config.cal_anglex = LSM6DSM.AngleX;
1193   2                  config.cal_angley = LSM6DSM.AngleY;
1194   2                  break;
1195   2                } 
1196   2                case KEY3:
1197   2                {
1198   2                  break;
1199   2                }
1200   2              }
1201   2              Trg = 0;
1202   2            }
1203   2            if(ON_CLOSE)
1204   2            {
1205   2              ON_CLOSE = 0;
1206   2              ScreenSetInverse(config.screen_inverse);
1207   2              //LSM6DSMSetODR(ACC_ODR_416_HZ, GYR_POWER_DOWN);
1208   2              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
1209   2              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
1210   2              EEPROMWriteConfiguration(&config);
1211   2              func_num = MENU;
1212   2              ON_RETURN = 1;
1213   2            }
1214   2          }
1215   2        
1216   2          else if(func_num == FLASH_LIGHT)  //手电筒  ok
1217   2          {
1218   2            static char flash_mode = 0;
1219   2            static char flash_t_cnt = 0;
1220   2            static bit k = 0;
1221   2            if(ON_OPEN)
1222   2            {
1223   2              ON_OPEN = 0;
1224   2              ClearCache(sub_cache2);
1225   2              ShowString(28, 3, "Torch ON", sub_cache2, FONT8X16, NO_INVERSED, 0);
1226   2              ScreenPushAnimation(sub_cache2, LEFT);
1227   2              ScreenSetInverse(INVERSED);
1228   2              ScreenSetBrightness(255);
1229   2              LED(ON);
1230   2            }
1231   2            if(tick_20ms)
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 21  

1232   2            {
1233   2              tick_20ms = 0;
1234   2              inactive_time = 0;
1235   2              if(flash_mode)
1236   2              {
1237   2                if(flash_t_cnt++ == 5)
1238   2                {
1239   2                  flash_t_cnt = 0;
1240   2                  k = ~k;
1241   2                  LED(k);
1242   2                }
1243   2              }
1244   2            }
1245   2            if(Trg != 0)
1246   2            {
1247   2              switch(Trg)
1248   2              {
1249   2                case KEY1:
1250   2                {
1251   2                  ON_CLOSE = 1;
1252   2                  break;
1253   2                }
1254   2                case KEY2:
1255   2                {
1256   2                  if(flash_mode == 0)
1257   2                    flash_mode = 1;
1258   2                  else
1259   2                  {
1260   2                    flash_mode = 0;
1261   2                    LED(ON);
1262   2                  }
1263   2                  break;
1264   2                }
1265   2              }
1266   2              Trg = 0;
1267   2            }
1268   2            if(ON_CLOSE)
1269   2            {
1270   2              ON_CLOSE = 0;
1271   2              ScreenSetBrightness(config.screen_brightness);
1272   2              ScreenSetInverse(config.screen_inverse);
1273   2              LED(OFF);
1274   2              flash_mode = 0;
1275   2              flash_t_cnt = 0;
1276   2              func_num = MENU;
1277   2              ON_RETURN = 1;  
1278   2            }
1279   2          }
1280   2          else if(func_num == SETTING)      //设置    ok
1281   2          {
1282   2            static char index = 0;    //菜单的索引(0~MENU_MAX_ROW-1)
1283   2            static char pointer = 0;  //当前所选项在屏幕上的位置(0~3)
1284   2            static char mode = -1;
1285   2            unsigned char str[21];
1286   2            unsigned char *cache;
1287   2            if(mode == -1)  //设置菜单界面
1288   2            {
1289   2              if(ON_OPEN | ON_RETURN)
1290   2              {
1291   2                cache = &sub_cache2;
1292   2              }
1293   2              else
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 22  

1294   2                cache = &main_cache;
1295   2              if(tick_20ms)
1296   2              {
1297   2                tick_20ms = 0;
1298   2                ClearCache(cache);
1299   2                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1300   2                ShowString(16, 0, SETTING_MENU[index - pointer], cache, FONT8X16, NO_INVERSED, 0);
1301   2                ShowString(16, 2, SETTING_MENU[index - pointer + 1], cache, FONT8X16, NO_INVERSED, 0);
1302   2                ShowString(16, 4, SETTING_MENU[index - pointer + 2], cache, FONT8X16, NO_INVERSED, 0);
1303   2                ShowString(16, 6, SETTING_MENU[index - pointer + 3], cache, FONT8X16, NO_INVERSED, 1);
1304   2                if(ON_OPEN)
1305   2                {
1306   2                  ScreenPushAnimation(sub_cache2, LEFT);
1307   2                  ON_OPEN = 0;
1308   2                }
1309   2                else if(ON_RETURN)
1310   2                {
1311   2                  ScreenPushAnimation(sub_cache2, RIGHT);
1312   2                  ON_RETURN = 0;
1313   2                } 
1314   2              }
1315   2              if(Trg != 0)
1316   2              {
1317   2                switch(Trg)
1318   2                {
1319   2                  case KEY1:
1320   2                  {
1321   2                    ON_CLOSE = 1;
1322   2                    break;
1323   2                  }
1324   2                  case KEY2:
1325   2                  {
1326   2                    index--;
1327   2                    if(--pointer < 0)
1328   2                    {
1329   2                      pointer = 0;
1330   2                      if(index != -1)
1331   2                      {
1332   2                        ClearCache(sub_cache2);
1333   2                        ShowString(16, 6, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1334   2                        ScreeRollDown(sub_cache2, 16);
1335   2                      }
1336   2                      else
1337   2                        index = 0;
1338   2                    }
1339   2                    break;
1340   2                  } 
1341   2                  case KEY3:
1342   2                  {
1343   2                    index++;
1344   2                    if(++pointer == 4)
1345   2                    {
1346   2                      pointer = 3;
1347   2                      if(index != MENU_MAX_ROW)
1348   2                      {
1349   2                        ClearCache(sub_cache2);
1350   2                        ShowString(16, 0, SETTING_MENU[index], sub_cache2, FONT8X16, NO_INVERSED, 0);
1351   2                        ScreeRollUp(sub_cache2, 16);
1352   2                      }
1353   2                      else
1354   2                        index = MENU_MAX_ROW - 1;
1355   2                    }
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 23  

1356   2                    break;
1357   2                  }
1358   2                  case DOUBLE_TAP:
1359   2                  {
1360   2                    mode = index;
1361   2                    ON_OPEN = 1;
1362   2                    break;
1363   2                  }
1364   2                }
1365   2                Trg = 0;
1366   2              }
1367   2              if(ON_CLOSE)
1368   2              {
1369   2                ON_CLOSE = 0;
1370   2                func_num = MENU;
1371   2                ON_RETURN = 1;
1372   2              }
1373   2            }
1374   2            else if(mode == 0)  //设置时间
1375   2            {
1376   2              static char pointer = 0;
1377   2              static char set_index = 0;
1378   2              if(ON_OPEN)
1379   2              {
1380   2                ON_OPEN = 0;
1381   2                PCF8563ReadTime(&RTC);
1382   2                ClearCache(sub_cache2);
1383   2                ShowString(0, 0, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1384   2                sprintf(str, "%2d:%2d:%2d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1385   2                ShowString(16, 0, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1386   2                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1387   2                ShowString(16, 2, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1388   2                ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], sub_cache2, FONT6X8, NO_INVERSED, 0);
1389   2                ScreenPushAnimation(sub_cache2, LEFT);
1390   2              }
1391   2              if(tick_20ms)
1392   2              {
1393   2                tick_20ms = 0;
1394   2                ClearCache(main_cache);
1395   2                if(set_index == 0)
1396   2                  PCF8563ReadTime(&RTC);
1397   2                ShowString(0, pointer * 2, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1398   2                sprintf(str, "%02d:%02d:%02d", (int)RTC.hour, (int)RTC.minute, (int)RTC.second);
1399   2                ShowString(16, 0, str, main_cache, FONT8X16, NO_INVERSED, 0);
1400   2                if(pointer == 0 && set_index != 0)
1401   2                {
1402   2                  if(set_index == 1)
1403   2                  {
1404   2                    sprintf(str, "%02d", (int)RTC.hour);
1405   2                    ShowString(16, 0, str, main_cache, FONT8X16, INVERSED, 0);
1406   2                  }
1407   2                  else if(set_index == 2)
1408   2                  {
1409   2                    sprintf(str, "%02d", (int)RTC.minute);
1410   2                    ShowString(40, 0, str, main_cache, FONT8X16, INVERSED, 0);
1411   2                  }
1412   2                  else if(set_index == 3)
1413   2                  {
1414   2                    sprintf(str, "%02d", (int)RTC.second);
1415   2                    ShowString(64, 0, str, main_cache, FONT8X16, INVERSED, 0);
1416   2                  }
1417   2                }
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 24  

1418   2                sprintf(str, "%4d/%2d/%2d", (int)RTC.year, (int)RTC.month, (int)RTC.day);
1419   2                ShowString(16, 2, str, main_cache, FONT8X16, NO_INVERSED, 0);
1420   2                if(pointer == 1 && set_index != 0)
1421   2                {
1422   2                  if(set_index == 1)
1423   2                  {
1424   2                    sprintf(str, "%4d", (int)RTC.year);
1425   2                    ShowString(16, 2, str, main_cache, FONT8X16, INVERSED, 0);
1426   2                  }
1427   2                  else if(set_index == 2)
1428   2                  {
1429   2                    sprintf(str, "%2d", (int)RTC.month);
1430   2                    ShowString(56, 2, str, main_cache, FONT8X16, INVERSED, 0);
1431   2                  }
1432   2                  else if(set_index == 3)
1433   2                  {
1434   2                    sprintf(str, "%2d", (int)RTC.day);
1435   2                    ShowString(80, 2, str, main_cache, FONT8X16, INVERSED, 0);
1436   2                  }
1437   2                }
1438   2                if(pointer == 2 && set_index != 0)
1439   2                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, INVERSED, 1);
1440   2                else
1441   2                  ShowString(16, 4, WEEKDAY_IN_STR[RTC.weekday - 1], main_cache, FONT8X16, NO_INVERSED, 1);
1442   2              }
1443   2              if(Trg != 0)
1444   2              {
1445   2                switch(Trg)
1446   2                {
1447   2                  case KEY1:
1448   2                  {
1449   2                    if(set_index != 0)
1450   2                    {
1451   2                      set_index = 0;
1452   2                      PCF8563WriteTime(RTC.hour, RTC.minute, RTC.second);
1453   2                      PCF8563WriteDate(RTC.year, RTC.month, RTC.day, RTC.weekday);
1454   2                    }
1455   2                    else
1456   2                      ON_CLOSE = 1;
1457   2                    break;
1458   2                  }
1459   2                  case KEY2:
1460   2                  {
1461   2                    if(set_index == 0)
1462   2                    {
1463   2                      if(--pointer < 0)
1464   2                        pointer = 2;
1465   2                    }
1466   2                    else
1467   2                    {
1468   2                      if(pointer == 0)
1469   2                      {
1470   2                        if(set_index == 1)
1471   2                        {
1472   2                          if(++RTC.hour == 24)
1473   2                            RTC.hour = 0;
1474   2                        }
1475   2                        else if(set_index == 2)
1476   2                        {
1477   2                          if(++RTC.minute == 60)
1478   2                            RTC.minute = 0;
1479   2                        }
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 25  

1480   2                        else if(set_index == 3)
1481   2                        {
1482   2                          if(++RTC.second == 60)
1483   2                            RTC.second = 0;
1484   2                        }
1485   2                      }
1486   2                      else if(pointer == 1)
1487   2                      {
1488   2                        if(set_index == 1)
1489   2                        {
1490   2                          if(++RTC.year == 2100)
1491   2                            RTC.year = 2000;
1492   2                        }
1493   2                        else if(set_index == 2)
1494   2                        {
1495   2                          if(++RTC.month == 13)
1496   2                            RTC.month = 1;
1497   2                        }
1498   2                        else if(set_index == 3)
1499   2                        {
1500   2                          if(++RTC.day == 32)
1501   2                            RTC.day = 1;
1502   2                        }
1503   2                      }
1504   2                      else if(pointer == 2)
1505   2                      {
1506   2                        if(set_index == 1)
1507   2                          if(++RTC.weekday == 8)
1508   2                            RTC.weekday = 1;
1509   2                      }
1510   2                    }
1511   2                    break;
1512   2                  }
1513   2                  case KEY3:
1514   2                  {
1515   2                    if(set_index == 0)
1516   2                    {
1517   2                      if(++pointer == 3)
1518   2                        pointer = 0;
1519   2                    }
1520   2                    else
1521   2                    {
1522   2                      if(pointer == 0)
1523   2                      {
1524   2                        if(set_index == 1)
1525   2                        {
1526   2                          if(--RTC.hour == 255)
1527   2                            RTC.hour = 23;
1528   2                        }
1529   2                        else if(set_index == 2)
1530   2                        {
1531   2                          if(--RTC.minute == 255)
1532   2                            RTC.minute = 59;
1533   2                        }
1534   2                        else if(set_index == 3)
1535   2                        {
1536   2                          if(--RTC.second == 255)
1537   2                            RTC.second = 59;
1538   2                        }
1539   2                      }
1540   2                      else if(pointer == 1)
1541   2                      {
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 26  

1542   2                        if(set_index == 1)
1543   2                        {
1544   2                          if(--RTC.year == 1999)
1545   2                            RTC.year = 2099;
1546   2                        }
1547   2                        else if(set_index == 2)
1548   2                        {
1549   2                          if(--RTC.month == 255)
1550   2                            RTC.month = 12;
1551   2                        }
1552   2                        else if(set_index == 3)
1553   2                        {
1554   2                          if(--RTC.day == 255)
1555   2                            RTC.day = 31;
1556   2                        }
1557   2                      }
1558   2                      else if(pointer == 2)
1559   2                      {
1560   2                        if(set_index == 1)
1561   2                          if(--RTC.weekday == 0)
1562   2                            RTC.weekday = 7;
1563   2                      }
1564   2                    }
1565   2                    break;
1566   2                  }
1567   2                  case DOUBLE_TAP:
1568   2                  {
1569   2                    if(pointer < 2)
1570   2                    {
1571   2                      if(++set_index == 4)
1572   2                        set_index = 1;
1573   2                    }
1574   2                    else if(pointer == 2)
1575   2                    {
1576   2                      if(++set_index == 2)
1577   2                        set_index = 1;
1578   2                    }
1579   2                    break;
1580   2                  }
1581   2                }
1582   2                Trg = 0;
1583   2              }
1584   2              if(ON_CLOSE)
1585   2              {
1586   2                ON_CLOSE = 0;
1587   2                set_index = 0;
1588   2                pointer = 0;
1589   2                mode = -1;
1590   2                ON_RETURN = 1;
1591   2              }
1592   2            }
1593   2            else if(mode == 1)  //设置闹钟
1594   2            {
1595   2              static unsigned char pointer = 0;
1596   2              static unsigned char set_index = 0;
1597   2              if(ON_OPEN)
1598   2              {
1599   2                ON_OPEN = 0;
1600   2                ClearCache(sub_cache2);
1601   2                ShowString(16, 0, "Alarm:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1602   2                ShowString(0, 1, ">", sub_cache2, FONT8X16, NO_INVERSED, 0);
1603   2                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 27  

1604   2                ShowString(16, 1, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1605   2                ShowString(16, 3, "Mode:", sub_cache2, FONT6X8, NO_INVERSED, 0);
1606   2                ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], sub_cache2, FONT8X16, NO_INVERSED, 0);
1607   2                ScreenPushAnimation(sub_cache2, LEFT);
1608   2              }
1609   2              if(tick_20ms)
1610   2              {
1611   2                tick_20ms = 0;
1612   2                ClearCache(main_cache);
1613   2                ShowString(0, 1 + pointer * 3, ">", main_cache, FONT8X16, NO_INVERSED, 0);
1614   2                ShowString(16, 0, "Alarm:", main_cache, FONT6X8, NO_INVERSED, 0);
1615   2                sprintf(str, "%02d:%02d", (int)config.alarm_hour, (int)config.alarm_min);
1616   2                ShowString(16, 1, str, main_cache, FONT8X16, NO_INVERSED, 0);
1617   2                if(pointer == 0 && set_index != 0)
1618   2                {
1619   2                  if(set_index == 1)
1620   2                  {
1621   2                    sprintf(str, "%02d", (int)config.alarm_hour);
1622   2                    ShowString(16, 1, str, main_cache, FONT8X16, INVERSED, 0);
1623   2                  }
1624   2                  else if(set_index == 2)
1625   2                  {
1626   2                    sprintf(str, "%02d", (int)config.alarm_min);
1627   2                    ShowString(40, 1, str, main_cache, FONT8X16, INVERSED, 0);
1628   2                  }
1629   2                }
1630   2                ShowString(16, 3, "Mode:", main_cache, FONT6X8, NO_INVERSED, 0);
1631   2                if(pointer == 1 && set_index != 0)
1632   2                {
1633   2                  
1634   2                  if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1635   2                  {
1636   2                    sprintf(str, "%02d", (int)config.alarm_day);
1637   2                    ShowString(16, 6, str, main_cache, FONT8X16, set_index==1?NO_INVERSED:INVERSED, 0);
1638   2                  }
1639   2                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, INVERSED, 1); 
1640   2                }
1641   2                else
1642   2                {
1643   2                  ShowString(16, 4, ALARM_MODE_MENU[config.alarm_mode], main_cache, FONT8X16, NO_INVERSED, 1);            
1644   2                }
1645   2              }
1646   2              if(Trg != 0)
1647   2              {
1648   2                switch(Trg)
1649   2                {
1650   2                  case KEY1:
1651   2                  {
1652   2                    if(set_index != 0)
1653   2                      set_index = 0;
1654   2                    else
1655   2                      ON_CLOSE = 1;
1656   2                    break;
1657   2                  }
1658   2                  case KEY2:
1659   2                  {
1660   2                    if(set_index == 0)
1661   2                    {
1662   2                      if(++pointer == 2)
1663   2                        pointer = 0;
1664   2                    }
1665   2                    else
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 28  

1666   2                    {
1667   2                      if(pointer == 0)
1668   2                      {
1669   2                        if(set_index == 1)
1670   2                        {
1671   2                          if(++config.alarm_hour == 24)
1672   2                            config.alarm_hour = 0;
1673   2                        }
1674   2                        else if(set_index == 2)
1675   2                        {
1676   2                          if(++config.alarm_min == 60)
1677   2                          config.alarm_min = 0;
1678   2                        }
1679   2                      }
1680   2                      else if(pointer == 1)
1681   2                      {
1682   2                        if(set_index == 1)
1683   2                        {
1684   2                          if(++config.alarm_mode == ALARM_MODE_NUM)
1685   2                            config.alarm_mode = 0;
1686   2                        }
1687   2                        else if(set_index == 2)
1688   2                        {
1689   2                          if(++config.alarm_day == 32)
1690   2                          {
1691   2                            config.alarm_day = 1;
1692   2                          }
1693   2                        }
1694   2                      }
1695   2                    }
1696   2                    break;
1697   2                  } 
1698   2                  case KEY3:
1699   2                  {
1700   2                    if(set_index == 0)
1701   2                    {
1702   2                      if(--pointer == 255)
1703   2                        pointer = 1;
1704   2                    }
1705   2                    else 
1706   2                    {
1707   2                      if(pointer == 0)
1708   2                      {
1709   2                        if(set_index == 1)
1710   2                        {
1711   2                          if(--config.alarm_hour == 255)
1712   2                            config.alarm_hour = 23;
1713   2                        }
1714   2                        else if(set_index == 2)
1715   2                        {
1716   2                          if(--config.alarm_min == 255)
1717   2                            config.alarm_min = 59;
1718   2                        }
1719   2                      }
1720   2                      else if(pointer == 1)
1721   2                      {
1722   2                        if(set_index == 1)
1723   2                        {
1724   2                          if(--config.alarm_mode == 255)
1725   2                            config.alarm_mode = ALARM_MODE_NUM - 1;
1726   2                        }
1727   2                        else if(set_index == 2)
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 29  

1728   2                        {
1729   2                          if(--config.alarm_day == 0)
1730   2                          {
1731   2                            config.alarm_day = 31;
1732   2                          }
1733   2                        }
1734   2                      }
1735   2                    }
1736   2                    break;
1737   2                  }
1738   2                  case DOUBLE_TAP:
1739   2                  {
1740   2                    if(set_index == 0)
1741   2                      set_index ++;
1742   2                    else
1743   2                    {
1744   2                      if(pointer == 0)
1745   2                      {
1746   2                        if(++set_index == 3)
1747   2                          set_index = 1;
1748   2                      }
1749   2                      else if(pointer == 1)
1750   2                      {
1751   2                        if(config.alarm_mode == ALARM_SPECIFIC_DAY)
1752   2                        {
1753   2                          if(++set_index == 3)
1754   2                          set_index = 1;
1755   2                        }
1756   2                      }
1757   2                    }
1758   2                    break;
1759   2                  }
1760   2                }
1761   2                Trg = 0;
1762   2              }
1763   2              if(ON_CLOSE)
1764   2              {
1765   2                ON_CLOSE = 0;
1766   2                set_index = 0;
1767   2                pointer = 0;
1768   2                if(config.alarm_mode != ALARM_DISABLE)
1769   2                {
1770   2                  if(config.alarm_mode == ALARM_WORKDAY)
1771   2                  {
1772   2                    PCF8563ReadTime(&RTC);
1773   2                    if(RTC.weekday > 5)
1774   2                      config.alarm_weekday = 1;
1775   2                    else
1776   2                    {
1777   2                      if((config.alarm_hour > RTC.hour) && (config.alarm_min > RTC.minute))
1778   2                        config.alarm_weekday = RTC.weekday;
1779   2                      else
1780   2                      {
1781   2                        if(RTC.weekday != 5)
1782   2                          config.alarm_weekday = RTC.weekday;
1783   2                        else
1784   2                          config.alarm_weekday = RTC.weekday + 1;
1785   2                      }
1786   2                    }
1787   2                  }
1788   2                  PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.
             -alarm_mode);
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 30  

1789   2                }
1790   2                else
1791   2                  PCF8563DisableAlarm();
1792   2                EEPROMWriteConfiguration(&config);
1793   2                mode = -1;
1794   2                ON_RETURN = 1;
1795   2              }
1796   2            }
1797   2            else if(mode == 2)  //设置亮度
1798   2            {
1799   2              static char temp;
1800   2              //unsigned char *cache;
1801   2              if(ON_OPEN)
1802   2              {
1803   2                ON_OPEN = 0;
1804   2                temp = config.screen_brightness / 50;
1805   2                ClearCache(sub_cache2);
1806   2                ShowString(0, 0, "Set the contrast ratio of the screen.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1807   2                sprintf(str, "%d", (int)temp);
1808   2                ShowString(56, 3, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1809   2                ScreenPushAnimation(sub_cache2, LEFT);
1810   2              }
1811   2              if(tick_20ms)
1812   2              {
1813   2                tick_20ms = 0;  
1814   2                ClearCache(main_cache);
1815   2                ShowString(0, 0, "Set the contrast ratio of the screen.", main_cache, FONT6X8, NO_INVERSED, 0);
1816   2                sprintf(str, "%d", (int)temp);
1817   2                ShowString(56, 3, str, main_cache, FONT8X16, NO_INVERSED, 1);
1818   2              }
1819   2              if(Trg != 0)
1820   2              {
1821   2                switch(Trg)
1822   2                {
1823   2                  case 0x01:
1824   2                  {
1825   2                    ON_CLOSE = 1;
1826   2                    break;
1827   2                  }
1828   2                  case 0x02:
1829   2                  {
1830   2                    if(++temp == 6)
1831   2                      temp = 5;
1832   2                    config.screen_brightness = temp * 50 + 1;
1833   2                    ScreenSetBrightness(config.screen_brightness);
1834   2                    break;
1835   2                  } 
1836   2                  case 0x04:
1837   2                  {
1838   2                    if(--temp < 0)
1839   2                      temp = 0;
1840   2                    config.screen_brightness = temp * 50 + 1;
1841   2                    ScreenSetBrightness(config.screen_brightness);
1842   2                    break;
1843   2                  }
1844   2                  case 0x08:
1845   2                    break;
1846   2                }
1847   2                Trg = 0;
1848   2              }
1849   2              if(ON_CLOSE)
1850   2              {
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 31  

1851   2                ON_CLOSE = 0;
1852   2                EEPROMWriteConfiguration(&config);
1853   2                mode = -1;
1854   2                ON_RETURN = 1;
1855   2              }
1856   2            }
1857   2            else if(mode == 3)  //设置自动息屏时间
1858   2            {
1859   2              static int temp;
1860   2              if(ON_OPEN)
1861   2              {
1862   2                ON_OPEN = 0;
1863   2                temp = config.t_inactive_max;
1864   2                ClearCache(sub_cache2);
1865   2                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1866   2                sprintf(str, "%d", temp);
1867   2                ShowString(56, 5, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1868   2                ShowString(72, 6, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1869   2                ScreenPushAnimation(sub_cache2, LEFT);
1870   2              }
1871   2              if(tick_20ms)
1872   2              {
1873   2                tick_20ms = 0;
1874   2                ClearCache(main_cache);
1875   2                ShowString(0, 0, "The time which screen stay-ON for without any operation,when set to 0,the screen wi
             -ll never turn off.", main_cache, FONT6X8, NO_INVERSED, 0);
1876   2                sprintf(str, "%d", temp);
1877   2                ShowString(56, 5, str, main_cache, FONT8X16, NO_INVERSED, 0);
1878   2                ShowString(72, 6, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1879   2              }
1880   2              if(Trg != 0)
1881   2              {
1882   2                switch(Trg)
1883   2                {
1884   2                  case KEY1:
1885   2                  {
1886   2                    ON_CLOSE = 1;
1887   2                    break;
1888   2                  }
1889   2                  case KEY2:
1890   2                  {
1891   2                    if(++temp == 100)
1892   2                      temp = 99;
1893   2                    break;
1894   2                  } 
1895   2                  case KEY3:
1896   2                  {
1897   2                    if(--temp < 0)
1898   2                      temp = 0;
1899   2                    break;
1900   2                  }
1901   2                }
1902   2                Trg = 0;
1903   2              }
1904   2              if(ON_CLOSE)
1905   2              {
1906   2                ON_CLOSE = 0;
1907   2                config.t_inactive_max = temp;
1908   2                EEPROMWriteConfiguration(&config);
1909   2                mode = -1;
1910   2                ON_RETURN = 1;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 32  

1911   2              }
1912   2            }
1913   2            else if(mode == 4)  //设置自动关机时间
1914   2            {
1915   2              static int temp;
1916   2              if(ON_OPEN)
1917   2              {
1918   2                ON_OPEN = 0;
1919   2                temp = config.t_sleep_max;
1920   2                ClearCache(sub_cache2);
1921   2                ShowString(0, 0, "The time which mcu stay active for without any operation before power-down,when set
             - to 0,the mcu will never power down.", sub_cache2, FONT6X8, NO_INVERSED, 0);
1922   2                sprintf(str, "%d", temp);
1923   2                ShowString(56, 6, str, sub_cache2, FONT8X16, NO_INVERSED, 0);
1924   2                ShowString(72, 7, "s", sub_cache2, FONT6X8, NO_INVERSED, 0);
1925   2                ScreenPushAnimation(sub_cache2, LEFT);
1926   2              }
1927   2              if(tick_20ms)
1928   2              {
1929   2                tick_20ms = 0;
1930   2                ClearCache(main_cache);
1931   2                ShowString(0, 0, "The time which mcu stay active for before without any operation power-down,when set
             - to 0,the mcu will never power down.", main_cache, FONT6X8, NO_INVERSED, 0);
1932   2                sprintf(str, "%d", temp);
1933   2                ShowString(56, 6, str, main_cache, FONT8X16, NO_INVERSED, 0);
1934   2                ShowString(72, 7, "s", main_cache, FONT6X8, NO_INVERSED, 1);
1935   2              }
1936   2              if(Trg != 0)
1937   2              {
1938   2                switch(Trg)
1939   2                {
1940   2                  case 0x01:
1941   2                  {
1942   2                    ON_CLOSE = 1;
1943   2                    break;
1944   2                  }
1945   2                  case 0x02:
1946   2                  {
1947   2                    if(++temp == 100)
1948   2                      temp = 99;
1949   2                    break;
1950   2                  } 
1951   2                  case 0x04:
1952   2                  {
1953   2                    if(--temp < 0)
1954   2                      temp = 0;
1955   2                    break;
1956   2                  }
1957   2                }
1958   2                Trg = 0;
1959   2              }
1960   2              if(ON_CLOSE)
1961   2              {
1962   2                ON_CLOSE = 0;
1963   2                config.t_sleep_max = temp;
1964   2                EEPROMWriteConfiguration(&config);
1965   2                mode = -1;
1966   2                ON_RETURN = 1;
1967   2              }
1968   2            }
1969   2            else if(mode == 5)  //设置屏幕反色
1970   2            {
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 33  

1971   2              if(ON_OPEN)
1972   2              {
1973   2                ON_OPEN = 0;
1974   2                ClearCache(sub_cache2);
1975   2                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", sub_cache2, FONT8X16, NO_INVERSED, 0)
             -;
1976   2                ScreenPushAnimation(sub_cache2, LEFT);
1977   2              }
1978   2              if(tick_20ms)
1979   2              {
1980   2                tick_20ms = 0;
1981   2                ClearCache(main_cache);
1982   2                ShowString(56, 3, config.screen_inverse == INVERSED?"ON":"OFF", main_cache, FONT8X16, NO_INVERSED, 1)
             -;
1983   2              }
1984   2              if(Trg != 0)
1985   2              {
1986   2                switch(Trg)
1987   2                {
1988   2                  case KEY1:
1989   2                  {
1990   2                    ON_CLOSE = 1;
1991   2                    break;
1992   2                  }
1993   2                  case DOUBLE_TAP:
1994   2                  {
1995   2                    if(config.screen_inverse == INVERSED)
1996   2                      config.screen_inverse = NO_INVERSED;
1997   2                    else
1998   2                      config.screen_inverse = INVERSED;
1999   2                    ScreenSetInverse(config.screen_inverse);
2000   2                    break;
2001   2                  } 
2002   2                }
2003   2                Trg = 0;
2004   2              }
2005   2              if(ON_CLOSE)
2006   2              {
2007   2                ON_CLOSE = 0;
2008   2                EEPROMWriteConfiguration(&config);
2009   2                mode = -1;
2010   2                ON_RETURN = 1;
2011   2              }
2012   2            }
2013   2            else if(mode == 6)  //设置屏幕方向
2014   2            {
2015   2              if(ON_OPEN)
2016   2              {
2017   2                ON_OPEN = 0;
2018   2                ClearCache(sub_cache2);
2019   2                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", sub_cache2, FONT8X16, NO
             -_INVERSED, 0);
2020   2                ScreenPushAnimation(sub_cache2, LEFT);
2021   2              }
2022   2              if(tick_20ms)
2023   2              {
2024   2                tick_20ms = 0;
2025   2                ClearCache(main_cache);
2026   2                ShowString(40, 3, config.screen_direction == NORMAL?"NORMAL":"UP-SIDE-DOWN", main_cache, FONT8X16, NO
             -_INVERSED, 1);
2027   2              }
2028   2              if(Trg != 0)
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 34  

2029   2              {
2030   2                switch(Trg)
2031   2                {
2032   2                  case KEY1:
2033   2                  {
2034   2                    ON_CLOSE = 1;
2035   2                    break;
2036   2                  }
2037   2                  case DOUBLE_TAP:
2038   2                  {
2039   2                    if(config.screen_direction == UPSIDEDOWN)
2040   2                      config.screen_direction = NORMAL;
2041   2                    else
2042   2                      config.screen_direction = UPSIDEDOWN;
2043   2                    ScreenSetDirection(config.screen_direction);
2044   2                    break;
2045   2                  } 
2046   2                }
2047   2                Trg = 0;
2048   2              }
2049   2              if(ON_CLOSE)
2050   2              {
2051   2                ON_CLOSE = 0;
2052   2                EEPROMWriteConfiguration(&config);
2053   2                mode = -1;
2054   2                ON_RETURN = 1;
2055   2              }
2056   2            }
2057   2            else if(mode == 7)  //设置按键音
2058   2            {
2059   2              if(ON_OPEN)
2060   2              {
2061   2                ON_OPEN = 0;
2062   2                ClearCache(sub_cache2);
2063   2                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", sub_cache2, FONT8X16, NO_INVERSED,
             - 0);
2064   2                ScreenPushAnimation(sub_cache2, LEFT);
2065   2              }
2066   2              if(tick_20ms)
2067   2              {
2068   2                tick_20ms = 0;
2069   2                ClearCache(main_cache);
2070   2                ShowString(24, 3, config.key_sound == ON?"Buzzer ON":"Buzzer OFF", main_cache, FONT8X16, NO_INVERSED,
             - 1);
2071   2              }
2072   2              if(Trg != 0)
2073   2              {
2074   2                switch(Trg)
2075   2                {
2076   2                  case KEY1:
2077   2                  {
2078   2                    ON_CLOSE = 1;
2079   2                    break;
2080   2                  }
2081   2                  case DOUBLE_TAP:
2082   2                  {
2083   2                    if(config.key_sound == ON)
2084   2                      config.key_sound = OFF;
2085   2                    else
2086   2                      config.key_sound = ON;
2087   2                    EnableBuzzer(config.key_sound);
2088   2                    break;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 35  

2089   2                  }
2090   2                }
2091   2                Trg = 0;
2092   2              }
2093   2              if(ON_CLOSE)
2094   2              {
2095   2                ON_CLOSE = 0;
2096   2                EEPROMWriteConfiguration(&config);
2097   2                mode = -1;
2098   2                ON_RETURN = 1;
2099   2              }
2100   2            }
2101   2            else if(mode == 8)  //单片机复位
2102   2            {
2103   2              MCUSoftReset();
2104   2            }
2105   2            else if(mode == 9)  //系统掉电
2106   2            {
2107   2              ON_OPEN = 0;
2108   2              active_flag = 0;
2109   2              action = 0;
2110   2              sleep_flag = 0;
2111   2              powerdown_flag = 0;
2112   2              inactive_time = 0;
2113   2              sleep_time = 0;
2114   2              deep_powerdown_flag = 1;
2115   2              mode = -1;
2116   2              func_num = WATCH;
2117   2            }
2118   2          }
2119   2          else if(func_num == SNAKES)       //贪吃蛇  ok
2120   2          {
2121   2            #define PANEL_WIDTH   92
2122   2            #define PANEL_HEIGHT  64
2123   2            #define MAX_SNAKE_SPEED 50
2124   2            unsigned char i = 0;
2125   2            unsigned char str[6];
2126   2            static unsigned char snake_direction = 0;//means sneak direction
2127   2            static unsigned char snake_speed = 10;
2128   2            static unsigned char past_x[256];
2129   2            static unsigned char past_y[256];
2130   2            static unsigned char snake_head_x = 64, snake_head_y = 32, snake_len = 20;
2131   2            static unsigned char test_now = 0, delicious_x= 80,delicious_y = 40;
2132   2            static unsigned char best_score = 0;
2133   2            static bit game_loop = 0;
2134   2            static bit game_over = 0;
2135   2            static bit game_pause = 0;
2136   2            if(ON_OPEN)
2137   2            {
2138   2              ON_OPEN = 0;
2139   2              ClearCache(sub_cache2);
2140   2              ScreenPushAnimation(sub_cache2, LEFT);//设定该界面左移进入屏幕
2141   2              snake_direction = 0;
2142   2              snake_head_x = 64;
2143   2              snake_head_y = 32;
2144   2              snake_len = 20;
2145   2              game_over = 0;
2146   2              game_pause = 0;
2147   2              for(i = 0; i < snake_len; i++)
2148   2              {
2149   2                past_x[i] = 64;
2150   2                past_y[i] = 32;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 36  

2151   2              }
2152   2              LSM6DSMConfigAcc(ACC_ODR_208_HZ, ACC_SCALE_4_G);
2153   2              LSM6DSMConfigGyr(GYR_ODR_208_HZ, GYR_SCALE_500_DPS);
2154   2            }
2155   2            if(tick_8ms)
2156   2            {
2157   2              tick_8ms = 0;
2158   2              LSM6DSMReadGYRAndACC(&LSM6DSM);
2159   2              IMUupdate(&LSM6DSM);
2160   2            }
2161   2            if(tick_1ms)
2162   2            {
2163   2              static unsigned char t_cnt = 0;
2164   2              tick_1ms = 0;
2165   2              if(++t_cnt == (MAX_SNAKE_SPEED - snake_speed))
2166   2              {
2167   2                t_cnt = 0;
2168   2                game_loop = 1;
2169   2              }
2170   2            }
2171   2            if(game_loop)
2172   2            {
2173   2              game_loop = 0;
2174   2              inactive_time = 0;//to not close screen
2175   2              if(game_pause != 1)
2176   2              {
2177   2                ClearCache(main_cache);
2178   2                for(i = 0; i < PANEL_WIDTH; i++)  //画一个框
2179   2                {
2180   2                  DrawDot(i, 0);
2181   2                  DrawDot(i, PANEL_HEIGHT - 1);
2182   2                }
2183   2                for(i = 0; i < PANEL_HEIGHT; i++)
2184   2                {
2185   2                  DrawDot(0, i);
2186   2                  DrawDot(PANEL_WIDTH - 1, i);
2187   2                }
2188   2                ShowString(PANEL_WIDTH, 1, "Score:", main_cache, FONT6X8, NO_INVERSED, 0);
2189   2                sprintf(str, "%3d", (int)snake_len);
2190   2                ShowString(PANEL_WIDTH, 2, str, main_cache, FONT6X8, NO_INVERSED, 0);
2191   2                ShowString(PANEL_WIDTH, 5, "Best:", main_cache, FONT6X8, NO_INVERSED, 0);
2192   2                if(snake_len > best_score)
2193   2                  best_score = snake_len;
2194   2                sprintf(str, "%3d", (int)best_score);
2195   2                ShowString(PANEL_WIDTH, 6, str, main_cache, FONT6X8, NO_INVERSED, 0);
2196   2                if(snake_direction == 0)
2197   2                {
2198   2                  if(LSM6DSM.AngleY > 10)
2199   2                    snake_direction = 1;
2200   2                  else if(LSM6DSM.AngleY < -10)
2201   2                    snake_direction = 3;
2202   2                }
2203   2                else if(snake_direction == 1)
2204   2                {
2205   2                  if(LSM6DSM.AngleX > 10)
2206   2                    snake_direction = 0;
2207   2                  else if(LSM6DSM.AngleX < -10)
2208   2                    snake_direction = 2;
2209   2                }
2210   2                else if(snake_direction == 2)
2211   2                {
2212   2                  if(LSM6DSM.AngleY > 10)
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 37  

2213   2                    snake_direction = 1;
2214   2                  else if(LSM6DSM.AngleY < -10)
2215   2                    snake_direction = 3;
2216   2                }
2217   2                else if(snake_direction == 3)
2218   2                {
2219   2                  if(LSM6DSM.AngleX > 10)
2220   2                    snake_direction = 0;
2221   2                  else if(LSM6DSM.AngleX < -10)
2222   2                    snake_direction = 2;
2223   2                }
2224   2                //这段是按键程序解析后转换为方向以及点位置的程序，
2225   2                //sneak_direction是方向，test_x是头部的x轴值，test_y是头部的y轴值
2226   2                switch(snake_direction)
2227   2                {
2228   2                  case 0:   //右
2229   2                    snake_head_x++;
2230   2                    break;
2231   2                  case 1:   //下
2232   2                    snake_head_y++;
2233   2                    break;
2234   2                  case 2:   //左
2235   2                    snake_head_x--;
2236   2                    break;
2237   2                  case 3:   //上
2238   2                    snake_head_y--;
2239   2                    break;
2240   2                }
2241   2                if(snake_head_x >= PANEL_WIDTH)
2242   2                  snake_head_x = 1;
2243   2                else if(snake_head_x <= 0)
2244   2                  snake_head_x = PANEL_WIDTH - 1;
2245   2                if(snake_head_y >= PANEL_HEIGHT)
2246   2                  snake_head_y = 1;
2247   2                else if(snake_head_y <= 0)
2248   2                  snake_head_y = PANEL_HEIGHT - 1;
2249   2                //检查是否碰到自己的身体
2250   2                for(i = 0; i < snake_len; i++)
2251   2                {
2252   2                  if((snake_head_x == past_x[i]) && (snake_head_y == past_y[i]))
2253   2                  {
2254   2                    game_over = 1;
2255   2                    game_pause = 1;
2256   2                    break;
2257   2                  }
2258   2                }
2259   2                //这段是可以让贪吃蛇有可变长度尾巴的测试程序，test_num就是尾巴的数量，最大50，
2260   2                //程序原理是把每次过去的坐标都记录在数组里面。显示的时候就把过去的点也都显示出来
2261   2                test_now++;
2262   2                test_now = test_now % snake_len;
2263   2                past_x[test_now] = snake_head_x;
2264   2                past_y[test_now] = snake_head_y;
2265   2                for(i = 0; i < snake_len; i++)
2266   2                {
2267   2                  DrawDot(past_x[i], past_y[i]);
2268   2                }
2269   2                //这段程序放被吃掉的小东西，设计delicious_x,delicious_y为食物的坐标
2270   2                //吃掉食物以后会放一个新的食物，并且test_num也就是尾巴的数量会大1
2271   2                if((snake_head_x <= delicious_x+1) && (snake_head_y <= delicious_y+1) && (snake_head_x >= delicious_x
             --1) && (snake_head_y>=delicious_y-1))
2272   2                {
2273   2                  snake_len++;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 38  

2274   2                  past_x[snake_len - 1] = past_x[snake_len - 2];//解决小白点的问题
2275   2                  past_y[snake_len - 1] = past_y[snake_len - 2];
2276   2                  Bee();
2277   2                  delicious_x = rand() % 92;
2278   2                  if(delicious_x > PANEL_WIDTH - 2)
2279   2                    delicious_x = PANEL_WIDTH - 2;
2280   2                  else if(delicious_x < 2)
2281   2                    delicious_x  = 2;
2282   2                  delicious_y = rand() % 64;
2283   2                  if(delicious_y > PANEL_HEIGHT - 2)
2284   2                    delicious_y = PANEL_HEIGHT - 2;
2285   2                  else if(delicious_y < 2)
2286   2                    delicious_y  = 2;
2287   2                }
2288   2                DrawDot(delicious_x,delicious_y);
2289   2                DrawDot(delicious_x+1,delicious_y);
2290   2                DrawDot(delicious_x-1,delicious_y);
2291   2                DrawDot(delicious_x,delicious_y+1);
2292   2                DrawDot(delicious_x+1,delicious_y+1);
2293   2                DrawDot(delicious_x-1,delicious_y+1);
2294   2                DrawDot(delicious_x,delicious_y-1);
2295   2                DrawDot(delicious_x+1,delicious_y-1);
2296   2                DrawDot(delicious_x-1,delicious_y-1);
2297   2                if(snake_len < 30)
2298   2                  snake_speed = 10;
2299   2                else if(snake_len < 40)
2300   2                  snake_speed = 20;
2301   2                else if(snake_len < 60)
2302   2                  snake_speed = 30;
2303   2                else if(snake_len < 90)
2304   2                  snake_speed = 35;
2305   2                else if(snake_len < 130)
2306   2                  snake_speed = 40;
2307   2                else
2308   2                  snake_speed = 45;
2309   2              }
2310   2              if(game_over)
2311   2              {
2312   2                ShowString(30, 2, "GAME", main_cache, FONT8X16, NO_INVERSED, 0);
2313   2                ShowString(30, 4, "OVER", main_cache, FONT8X16, NO_INVERSED, 0);
2314   2              }
2315   2              ScreenRefreshAll(main_cache);
2316   2            }
2317   2            if(Trg != 0)
2318   2            {
2319   2              switch(Trg)
2320   2              {
2321   2                case KEY1:
2322   2                {
2323   2                  ON_CLOSE = 1;
2324   2                  break;
2325   2                }
2326   2                case KEY2:
2327   2                {
2328   2                  if(game_over != 1)
2329   2                  {
2330   2                    if(game_pause)
2331   2                      game_pause = 0;
2332   2                    else
2333   2                      game_pause = 1;
2334   2                  }
2335   2                  break;
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 39  

2336   2                }
2337   2                case KEY3:
2338   2                {
2339   2                  ON_OPEN = 1;
2340   2                  break;
2341   2                }
2342   2              }
2343   2              Trg = 0;
2344   2            }
2345   2            if(ON_CLOSE)
2346   2            {
2347   2              ON_CLOSE = 0;
2348   2              LSM6DSMConfigAcc(ACC_ODR_416_HZ, ACC_SCALE_4_G);
2349   2              LSM6DSMConfigGyr(GYR_POWER_DOWN, GYR_SCALE_500_DPS);
2350   2              func_num = MENU;
2351   2              ON_RETURN = 1;  
2352   2            }
2353   2          }
2354   2          if(action)          //系统在不同状态下对动作的处理
2355   2          {
2356   2            action = 0;
2357   2            if(active_flag)
2358   2              inactive_time = 0;
2359   2            else if(sleep_flag)
2360   2            {
2361   2              sleep_flag = 0;
2362   2              sleep_time = 0;
2363   2              active_flag = 1;
2364   2              ScreenOnOff(ON);
2365   2              screen_on_flag = 1;
2366   2            }
2367   2            else if(powerdown_flag)
2368   2            {
2369   2              powerdown_flag = 0;
2370   2              active_flag = 1;
2371   2              SystemPowerOn();
2372   2              ScreenOnOff(ON);
2373   2              screen_on_flag = 1;
2374   2              ON_OPEN = 1;
2375   2            }
2376   2            else if(deep_powerdown_flag)
2377   2            {
2378   2              deep_powerdown_flag = 0;
2379   2              active_flag = 1;
2380   2              SystemPowerOn();
2381   2              DisplayInit(&config);
2382   2              screen_on_flag = 1;
2383   2              SensorInit();
2384   2              PW02SetMode(0);
2385   2              PCF8563EnableTimer(TIMERCLK_1_60_HZ, 1);  //自动唤醒频率1min一次
2386   2              ON_OPEN = 1;
2387   2            }
2388   2            autowake_cnt = 0;
2389   2          }
2390   2          if(sleep_flag)
2391   2          {
2392   2            if(screen_on_flag)
2393   2            {
2394   2              ScreenOnOff(OFF);
2395   2              screen_on_flag = 0;
2396   2            }
2397   2          }   
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 40  

2398   2          if(powerdown_flag)    
2399   2          {
2400   2            if(ON_CLOSE == 0)
2401   2            {
2402   2              SystemPowerDown();
2403   2            }
2404   2          }
2405   2          if(deep_powerdown_flag)
2406   2          {
2407   2            if(ON_CLOSE == 0)
2408   2            {
2409   2              SystemDeepPowerDown();
2410   2            }
2411   2            Enable3V3Output(1);
2412   2            Delay1ms(10);
2413   2          }
2414   2          if(alarm_flag)
2415   2          {
2416   2            sleep_time = 0;     //闹铃被关掉前不会待机
2417   2          }
2418   2          if(timer_on_flag)
2419   2          {
2420   2            sleep_time = 0;     //计时器在工作时不会待机
2421   2          }
2422   2          if(PCF8563_int_flag)  //PCF8563产生了中断信号
2423   2          {
2424   2            unsigned char pcf8563_int_src;
2425   2            PCF8563_int_flag = 0;
2426   2            pcf8563_int_src = PCF8563ReadIntSrc();  //读PCF8563状态寄存器
2427   2            PCF8563ReadTime(&RTC);
2428   2            if(pcf8563_int_src & ALARM_INT)       //如果是闹钟中断
2429   2            {
2430   2              PCF8563ClearAlarmFlag();  //清除闹钟中断标志位
2431   2              action = 1;       //产生动作
2432   2              alarm_flag = 1;   //置位闹钟标志位
2433   2              Beebeebee();      //响铃
2434   2              Delay1ms(5);
2435   2              if(config.alarm_mode == ALARM_WORKDAY) 
2436   2              {
2437   2                if(RTC.weekday + 1 > 5)
2438   2                  config.alarm_weekday = 1;
2439   2                else
2440   2                  config.alarm_weekday = RTC.weekday + 1;
2441   2                PCF8563SetAlarm(config.alarm_hour, config.alarm_min, config.alarm_weekday, config.alarm_day, config.a
             -larm_mode);
2442   2              }
2443   2              else if(config.alarm_mode != ALARM_EVERYDAY)  //如果闹钟模式不是每天都响
2444   2              {
2445   2                config.alarm_mode = ALARM_DISABLE;  //关闭闹钟
2446   2                PCF8563DisableAlarm();              //关闭闹钟
2447   2              }
2448   2              EEPROMWriteConfiguration(&config);
2449   2            }
2450   2            if(pcf8563_int_src & TIMER_INT)       //如果是定时器中断
2451   2            {
2452   2              PCF8563ClearTimerFlag();  //清除定时器中断标志位
2453   2              //PCF8563以固定的时间间隔唤醒MCU
2454   2              //唤醒之后执行以下内容  
2455   2              battery_life = GetBatteryLife();
2456   2              if(active_flag || sleep_flag || powerdown_flag)      
2457   2              {
2458   2                if((RTC.hour == 22) && (RTC.minute == 4))   //22:04,记录当天的步数数据
C51 COMPILER V9.52.0.0   MAIN                                                              06/27/2021 08:53:57 PAGE 41  

2459   2                {
2460   2                  char i, j;
2461   2                  for(i = 6; i > 0; i--)
2462   2                  {
2463   2                    for(j = 0; j < 10; j++)
2464   2                    {
2465   2                      config.history_step[i][j] = config.history_step[i - 1][j];
2466   2                    }
2467   2                  }
2468   2                  sprintf(config.history_step[0], "%d/%d %d", (int)RTC.month, (int)RTC.day, (int)LSM6DSMGetCurrentStep
             -());
2469   2                  EEPROMWriteConfiguration(&config);
2470   2                  LSM6DSMResetStepCounter();
2471   2                }
2472   2              }
2473   2              if(powerdown_flag)
2474   2              {
2475   2                if(++autowake_cnt >= 1440)    //1440分钟 = 1天
2476   2                {
2477   2                  autowake_cnt = 0;
2478   2                  powerdown_flag = 0;
2479   2                  PCF8563EnableTimer(TIMERCLK_1_60_HZ, 10); //自动唤醒频率改为10min一次，本来1min一次
2480   2                  deep_powerdown_flag = 1;
2481   2                }
2482   2              }
2483   2            }    
2484   2          }
2485   2          *****/      
2486   2        }           
2487   1        
2488   1      }
2489          
2490          
2491            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1026    ----
   CONSTANT SIZE    =   8011    ----
   XDATA SIZE       =    200      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     16    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
